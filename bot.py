
ç”¨æˆ·è¯·æ±‚å®Œæ•´ä»£ç å¸®åŠ©
ä¿®å¾©Discordæ©Ÿå™¨äººå´©æ½°å•é¡Œ
æ·»åŠ æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ·èµ„æ–™åŠŸèƒ½
Discordæ©Ÿå™¨äººRailwayé›²ç«¯éƒ¨ç½²æŒ‡å—
çŒ¶å¤ªæ½”é£Ÿèªè­‰æµç¨‹æŒ‡å°
å°äº‘æœºå™¨äººäº‘ç«¯éƒ¨ç½²æŒ‡å—
SQLite GREATESTå‡½æ•°é”™è¯¯è§£å†³æ–¹æ¡ˆ
æ´»å‹•ç°½åˆ°ç³»çµ±éŒ¯èª¤åˆ†æèˆ‡ä¿®æ­£
image.png
Python Discordæ©Ÿæ¢°äººç°½åˆ°è©•æ ¸ç³»çµ±ä¿®æ­£
Python Syntax Error: Await Outside Async Function
ä¿®æ­£å°é›²æ©Ÿæ¢°äºº2.0å½©æ± è®€å–å•é¡Œ
Kosher Process for Multiple Wok Batches
Pythonä»£ç ä¸­Discord IDè¯­æ³•é”™è¯¯
æ•´åˆALBIONæ©Ÿå™¨äººåŠŸèƒ½æ¨¡çµ„
å…³äºäº§å“ç¼–å·æŸ¥è¯¢åŠè®¢å•é¢„ä¼°
å©‰æ‹’å½“å‰è®¢å•ï¼Œå¼•å¯¼æœªæ¥éœ€æ±‚
Dragon Albion æœºå™¨äººæ—¥å¿—æ£€æŸ¥å»ºè®®
é“ç½å·²å¤‡ï¼ŒBAR CODEé”™è¯¯éœ€æ›´æ­£
ç æµ·å¹³å®‰å¤œ5äººåƒå–ç©ä¹æ¨è
æ–°åŠ å¡å…±å’Œç†å·¥å­¸é™¢å­¸ç”Ÿå¹´é½¡å±¤åˆ†æ
å³çœ¼çš®è·³åŠ¨åŸå› åŠåº”å¯¹å»ºè®®
å…ƒæœ—ç¾é£Ÿæ¨èåŠæ”»ç•¥
AIå¹¿ä¸œè¯æ•…äº‹åˆ›ä½œæŒ‡å—
ä¿®æ”¹Google Docsé»˜è®¤èƒŒæ™¯ä¸ºé»‘è‰²
æ¨èç¡¬æ ¸ç”Ÿå­˜å»ºé€ ç±»æ¸¸æˆ
The Last Plagueæ±‰åŒ–æ–¹æ³•æŒ‡å—
ç”Ÿäº§æµç¨‹åŠRABBIå‚è§‚å®‰æ’è¯´æ˜
å† çå½±å­è®¡åˆ’æ´»åŠ¨å‡†å¤‡æŒ‡å—
Gitæäº¤é”™è¯¯åŠè§£å†³æ–¹æ³•
Git æœªå®‰è£æˆ– PATH æœªè¨­å®š
Discord Bot Module Loading Error Fix
Discordæœºå™¨äººç¼ºå¤±matplotlibæ¨¡å—é”™è¯¯
Discord æ©Ÿå™¨äººæ¨¡çµ„è¼‰å…¥éŒ¯èª¤åˆ†æ
Discordæœºå™¨äººæ¨¡å—åŠ è½½å¤±è´¥è§£å†³æ–¹æ³•
OEMã€ODMã€OBMæ¨¡å¼è§£æ
ç­¾åã€å§“åã€èŒåŠ¡ä¸­æ–‡è§£é‡Š
æ™ºåˆ©é¦–å•æäº¤COAè¦æ±‚
AEONåˆ†é”€å•†åœæ­¢è®¢å•åŸå› è°ƒæŸ¥æŠ¥å‘Š
ç·šä¸ŠæŠ½çæ´»å‹•æ¸¬è©¦é€šçŸ¥
è©•æ ¸ç³»çµ±èªæ³•éŒ¯èª¤åˆ†æ
æ ‡å‡†å±•ä½é…ç½®æ–¹æ¡ˆä¸­æ–‡å¯¹ç…§
å‚å±•å•†å±•ä½ä½¿ç”¨åŠè£…ä¿®æ³¨æ„äº‹é¡¹
ALBIONè©•æ ¸æ´»å‹•æŒ‡ä»¤éŒ¯èª¤åˆ†æ
Windows PowerShell pipå®‰è£…é”™è¯¯è§£å†³æ–¹æ¡ˆ
Discordæ©Ÿå™¨äººæ´»å‹•æ¸¬è©¦è¨˜éŒ„æˆªåœ–
SQL æŸ¥è©¢æ¬„ä½éŒ¯èª¤æ’æŸ¥æ–¹æ³•
Python Script Indentation Error Fix Guide
Discordæœºå™¨äººå¯åŠ¨æ—¥å¿—ä¸é—®é¢˜æ€»ç»“
å‡ºå€¼ç‡è¯„æ ¸ç³»ç»Ÿéœ€æ±‚è®¨è®º
è§£å†³Pipåœ¨PowerShellä¸­æ— æ³•è¯†åˆ«çš„é—®é¢˜
æ™šä¸Šç»§ç»­æ“ä½œä»»åŠ¡
å…­åˆå½©å·ç çƒæ’åˆ—è§„å¾‹åˆ†æ
DiscordæŠ½å¥–æœºå™¨äººè®¾è®¡æ–¹æ¡ˆ
å¯»æ‰¾ç±»ä¼¼Kenshiçš„å¼€æ”¾ä¸–ç•Œæ¸¸æˆæ¨è
å–æ¶ˆ1æœˆ17æ—¥æ—…è¡Œæé†’
Discordéšæœºåˆ†é˜Ÿæœºå™¨äººæ•™ç¨‹
å† çé†¬æ²¹æ¨™ç±¤å›æ”¶æ¨™èªŒä½¿ç”¨è«®è©¢
æ¨èåŒæ­¥åŠ¨ç”»è§£è¯´å¹³å°
Excelé…è£…è¡¨åˆ¶ä½œæ•™ç¨‹
ç¡®è®¤åˆ©ç‰©æµ¦æŠ½å¥–é‚®ä»¶å®‰å…¨æ€§
PVEå¦å…‹ä¸è¡¥å¸ˆæ•™å­¦æµç¨‹è‰ç¨¿
å°é›²ä¸Šä»™ä¼ æˆPVEå¦å…‹ä¸å¥¶å¦ˆå¿ƒæ³•
ç”¨æˆ·è¯¢é—®æ˜¯å¦ä½¿ç”¨GRAMMA AI
DeepSeekä½œä¸ºä¸»åŠ›AIå·¥å…·æ¨è
ETD èˆ‡ETS çš„åˆ†åˆ¥
ARKéº»é†‰é¢ä½¿ç”¨æ•™ç¨‹
è°ƒæ•´SET DAY TIMEæ—¶é•¿æ¯”ä¾‹
ä¹Œé¸¦å®šå¾‹ï¼šé€ƒé¿ä¸å¦‚æ”¹å˜
ALBION HELLGATEå°éšŠé•·æ‹›å‹Ÿå®£å‚³
è˜‡æ¢…é†¬çš„å¸¸è¦‹åˆ¥ç¨±ä»‹ç´¹
è’œæ’éª¨ç”¨è±†å£«é†¬åç¨±è§£æ
ç”¨æˆ·è¯·æ±‚ååŠ©ç»˜åˆ¶å›¾åƒ
COOä¸ŠHS Codeæ•°é‡å¡«å†™å»ºè®®
æŸ¥æ‰¾MILLMILKçš„è”ç³»æ–¹å¼
ç¶²ä¸Šå…è²»å®Œçµå°èªªæ¨è–¦åŠå¹³å°æŒ‡å—
è¯·æ±‚æˆæƒä½¿ç”¨è§†é¢‘å†…å®¹
æ–¹èˆŸç”Ÿå­˜è¿›åŒ–æ— é™å­å¼¹æŒ‡ä»¤æŒ‡å—
æ–¹èˆŸç”Ÿå­˜è¿›åŒ–æ— é™çŠ¶æ€æŒ‡ä»¤å…³é—­é—®é¢˜è§£å†³æ–¹æ³•
æˆ‘æ˜¯é–‹SERVER çš„äººåŠç®¡ç†å“¡, æˆ‘æƒ³æ‰¾éå–®æ©Ÿæ¨¡å¼çš„ç¬¬ä¸‰äººç¨±æŒ‡
é…±æ²¹å‚ä¼ä¸šäº¤æµæ´»åŠ¨è§„åˆ’å»ºè®®
IQNetè¯ä¹¦å®šä¹‰åŠä¼˜åŠ¿è§£æ
Excelç½‘ç»œé¢„è§ˆé—®é¢˜è§£å†³æ–¹æ¡ˆ
Excelæ–‡ä»¶é¢„è§ˆé—®é¢˜æ’æŸ¥ä¸è§£å†³æ–¹æ¡ˆ
Discordç§¯åˆ†ç³»ç»ŸBotæ¨èä¸è‡ªå®šä¹‰
POE2 0.3 åŒå¼€æ–¹æ³•è¯¦è§£
ä»½é‡ä¸åˆ†é‡çš„åŒºåˆ«è§£æ
é¦™æ¸¯è€ƒè½¦ç‰Œæ³Šè½¦æŠ€å·§å£è¯€
2025å¹´9æœˆ19æ—¥é‹ç¨‹åˆ†æ
è‹±æ–‡æ€»ç»“åŠä¼˜åŒ–å»ºè®®
é¦™æ¸¯è‡³ç¾æ¬§èˆ¹å…¬å¸THCæ”¶è´¹æŸ¥è¯¢
å¯»æ‰¾åˆæ³•å…è´¹ä¸‹è½½æ­Œæ›²çš„é€”å¾„
åŒæ¸…å…³åŒ…ç¨æœåŠ¡è§£æ
åŒæ¸…å…³åŒ…ç¨æµç¨‹åŠæ³¨æ„äº‹é¡¹
è‰æ‹Ÿè‹±æ–‡é‚®ä»¶å‚ä¸å…¨çƒè´§è¿æ‹›æ ‡
ç”¨æˆ·è¯¢é—®1985å¹´12æœˆ13æ—¥ç”Ÿæ—¥æ˜Ÿåº§
1985å¹´å†å²èƒŒæ™¯ä¸é‡è¦äº‹ä»¶å›é¡¾
Cover Letter Sample and Customization Tips
æ¾³é—¨èµŒåšè¿åŠ¿åˆ†æä¸å»ºè®®
AIå·¥å…·æ¨èç”ŸæˆPPT
å…«å­—åˆ†æä¸è¿åŠ¿é¢„æµ‹
æº–å‚™PRSENTATION. è¡Œæ¥­æ˜¯: FREIGHT FO
è½‰æ›æˆEXCEL æ–¹ä¾¿æˆ‘COPY
ç”¨æˆ·è¯·æ±‚å®Œæ•´ä»£ç å¸®åŠ©
å‰›å‰›é•·é“ä¸å¤ , è«‹çµ¦æˆ‘å®Œæ•´ä»£ç¢¼
æ‚¨å¥½ï¼æˆ‘æ³¨æ„åˆ°æ‚¨çš„è¨Šæ¯æ˜¯ç¹é«”ä¸­æ–‡ï¼Œä½†å…§å®¹ä¼¼ä¹ä¸å®Œæ•´ã€‚

æ‚¨æåˆ°ã€Œå‰›å‰›é•·é“ä¸å¤ ã€ï¼Œé€™å¯èƒ½æ˜¯ã€Œå‰›å‰›é•·é“ä¸å¤ ã€çš„ç­†èª¤ï¼Œæˆ–è€…æ˜¯ã€Œç¨‹å¼ç¢¼ä¸å¤ å®Œæ•´ã€çš„æ„æ€ï¼Ÿç”±æ–¼æ‚¨æ²’æœ‰æŒ‡å®šæ˜¯å“ªå€‹ç¨‹å¼èªè¨€æˆ–å“ªå€‹åŠŸèƒ½çš„ç¨‹å¼ç¢¼ï¼Œæˆ‘ç„¡æ³•ç›´æ¥æä¾›æ‚¨éœ€è¦çš„å®Œæ•´ç¨‹å¼ç¢¼ã€‚

ç‚ºäº†æ›´å¥½åœ°å¹«åŠ©æ‚¨ï¼Œè«‹å‘Šè¨´æˆ‘ï¼š

æ‚¨éœ€è¦ä»€éº¼èªè¨€çš„ç¨‹å¼ç¢¼ï¼Ÿï¼ˆPythonã€JavaScriptã€Javaã€C++ ç­‰ï¼‰

å…·é«”æ˜¯ä»€éº¼åŠŸèƒ½ï¼Ÿï¼ˆç¶²é é–‹ç™¼ã€è³‡æ–™è™•ç†ã€æ¼”ç®—æ³•ã€éŠæˆ²ç­‰ï¼‰

æ‚¨å·²ç¶“æœ‰çš„éƒ¨åˆ†æ˜¯ä»€éº¼ï¼Ÿé€™æ¨£æˆ‘å¯ä»¥å¹«æ‚¨è£œå……å®Œæ•´ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨éœ€è¦ä¸€å€‹ã€ŒPython çˆ¬èŸ²å®Œæ•´ç¨‹å¼ç¢¼ã€æˆ–ã€ŒReact å…ƒä»¶å®Œæ•´ç¨‹å¼ç¢¼ã€ï¼Œè«‹å…·é«”èªªæ˜ï¼Œæˆ‘æœƒå¾ˆæ¨‚æ„ç‚ºæ‚¨æä¾›å®Œæ•´çš„ç¨‹å¼ç¯„ä¾‹ï¼

è«‹è£œå……æ›´å¤šç´°ç¯€ï¼Œé€™æ¨£æˆ‘å°±èƒ½çµ¦æ‚¨æœ€æº–ç¢ºçš„å¹«åŠ©ï¼ ğŸ˜Š

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å°é›²ALBIONæ©Ÿæ¢°äºº - ç°¡åŒ–è©•æ ¸ç‰ˆæœ¬
ä¸»æŒäººæŒ‰EMOJIè©•æ ¸ï¼Œé è¨­ç‚ºæ™®é€šè©•ç´š
"""

import os
import discord
from discord.ext import commands
from discord import app_commands
import sys
import asyncio
import json
import random
from datetime import datetime, timedelta
from typing import Optional, List
import sqlite3
import time

# ========== è¨­å®š ==========
BOT_NAME = "å°é›²æ©Ÿæ¢°äºº"
OWNER_IDS = [337237662157242368]  # ä½ çš„ Discord ID

# è·æ¥­å°æ‡‰çš„EMOJI
PROFESSION_EMOJIS = {
    "ğŸ›¡ï¸": "å¦å…‹",
    "âš”ï¸": "è¾“å‡º", 
    "ğŸ’š": "æ²»ç–—",
    "ğŸ’›": "è¾…åŠ©"
}

# è©•æ ¸è©•åˆ†é¸é …
RATING_EMOJIS = {
    "â­": "å„ªç§€",
    "ğŸ‘": "è‰¯å¥½", 
    "ğŸ‘Œ": "æ™®é€š",  # é è¨­è©•ç´š
    "âŒ": "ä¸åˆæ ¼"
}

# è©•æ ¸çµæŸEMOJI
RATING_END_EMOJI = "ğŸ"

# ========== ç©åˆ†è¨­å®š ==========
SIGNUP_SCORE = 40  # ç°½åˆ°ç©åˆ†
PROFESSION_BONUS = {
    "å¦å…‹": 0,
    "è¾“å‡º": 0,
    "æ²»ç–—": 20,  # è£œå¸«+20ç©åˆ†
    "è¾…åŠ©": 0
}
RATING_SCORES = {
    "å„ªç§€": 40,    # å„ªç§€+40ç©åˆ†
    "è‰¯å¥½": 10,    # è‰¯å¥½+10ç©åˆ†
    "æ™®é€š": 0,     # æ™®é€š+0ç©åˆ†
    "ä¸åˆæ ¼": -5   # ä¸åˆæ ¼-5ç©åˆ†
}

# Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True
intents.presences = True

bot = commands.Bot(
    command_prefix='!',
    intents=intents,
    help_command=None,
    case_insensitive=True
)

# ========== è³‡æ–™åº«è¨­å®š ==========
DB_NAME = "bot_data.db"

def init_db():
    """åˆå§‹åŒ–è³‡æ–™åº«"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # ç”¨æˆ¶è³‡æ–™è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        total_score INTEGER DEFAULT 0,
        current_score INTEGER DEFAULT 0,
        join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        profession_counts TEXT DEFAULT '{}',
        activity_stats TEXT DEFAULT '{}',
        rating_stats TEXT DEFAULT '{}'
    )
    ''')
    
    # å½©æ± è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS prize_pool (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        prize_name TEXT NOT NULL,
        box_level TEXT NOT NULL,
        quantity INTEGER DEFAULT 1,
        remaining INTEGER DEFAULT 1,
        added_by INTEGER,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(prize_name, box_level)
    )
    ''')
    
    # æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS giveaways (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        prize TEXT,
        winner_count INTEGER DEFAULT 1,
        participants TEXT DEFAULT '[]',
        winners TEXT DEFAULT '[]',
        end_time TIMESTAMP,
        message_id INTEGER,
        channel_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_draws (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        score_cost INTEGER,
        box_level TEXT,
        participants TEXT DEFAULT '[]',
        winner_prize TEXT,
        winner_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†è½‰ç§»ç´€éŒ„
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_transfers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_user_id INTEGER,
        to_user_id INTEGER,
        amount INTEGER,
        reason TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # è©•æ ¸æ´»å‹•
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS evaluation_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        event_name TEXT,
        creator_id INTEGER,
        signup_message_id INTEGER,
        profession_message_id INTEGER,
        rating_message_id INTEGER,
        channel_id INTEGER,
        participants TEXT DEFAULT '[]',
        default_rated TEXT DEFAULT '[]',   --å·²é è¨­è©•ç´šçš„ç”¨æˆ¶
        professions TEXT DEFAULT '{}',
        ratings TEXT DEFAULT '{}',
        is_active BOOLEAN DEFAULT 1,
        start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        signup_end_time TIMESTAMP
    )
    ''')
    
    # æ·»åŠ ç¤ºä¾‹çå“
    sample_prizes = [
        ("æ™®é€šæ­¦å™¨", "ç¶ ç®±", 20),
        ("æ™®é€šè£å‚™", "ç¶ ç®±", 15),
        ("åˆç´šè—¥æ°´", "ç¶ ç®±", 30),
        ("ä¸­ç´šæ­¦å™¨", "è—ç®±", 10),
        ("ä¸­ç´šè£å‚™", "è—ç®±", 8),
        ("ä¸­ç´šè—¥æ°´", "è—ç®±", 15),
        ("é«˜ç´šæ­¦å™¨", "ç´«ç®±", 5),
        ("é«˜ç´šè£å‚™", "ç´«ç®±", 4),
        ("é«˜ç´šè—¥æ°´", "ç´«ç®±", 6),
        ("å‚³å¥‡æ­¦å™¨", "é‡‘ç®±", 2),
        ("å‚³å¥‡è£å‚™", "é‡‘ç®±", 1),
        ("å‚³èªªè—¥æ°´", "é‡‘ç®±", 3),
    ]
    
    for prize_name, box_level, quantity in sample_prizes:
        cursor.execute('''
            INSERT OR IGNORE INTO prize_pool (prize_name, box_level, quantity, remaining)
            VALUES (?, ?, ?, ?)
        ''', (prize_name, box_level, quantity, quantity))
    
    conn.commit()
    conn.close()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")

# ========== é€šç”¨å‡½æ•¸ ==========

def get_user_score(user_id):
    """å–å¾—ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        return result[0], result[1]
    return 0, 0

def update_user_score(user_id, username, amount, reason=""):
    """æ›´æ–°ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if not cursor.fetchone():
        cursor.execute(
            "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
            (user_id, username, max(amount, 0), max(amount, 0))
        )
    else:
        cursor.execute("UPDATE users SET current_score = current_score + ? WHERE user_id = ?", (amount, user_id))
        if amount > 0:
            cursor.execute("UPDATE users SET total_score = total_score + ? WHERE user_id = ?", (amount, user_id))
        cursor.execute("UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE user_id = ?", (user_id,))
    
    if amount < 0 or reason:
        cursor.execute(
            "INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason) VALUES (?, ?, ?, ?)",
            (user_id if amount < 0 else None, 
             user_id if amount > 0 else None, 
             abs(amount), 
             reason if reason else ("ç³»çµ±æ‰£é™¤" if amount < 0 else "ç³»çµ±å¢åŠ "))
        )
    
    conn.commit()
    conn.close()

def get_user_profile(user_id):
    """ç²å–ç”¨æˆ¶å®Œæ•´è³‡æ–™"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score, join_date, profession_counts, activity_stats, rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        current_score, total_score, join_date, profession_str, activity_str, rating_str = result
        
        try:
            join_date_str = datetime.strptime(join_date.split('.')[0], '%Y-%m-%d %H:%M:%S').strftime('%Y-%m-%d')
        except:
            join_date_str = join_date
        
        profession_counts = json.loads(profession_str) if profession_str else {}
        activity_stats = json.loads(activity_str) if activity_str else {}
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        return {
            'user_id': user_id,
            'current_score': current_score,
            'total_score': total_score,
            'join_date': join_date_str,
            'profession_counts': profession_counts,
            'activity_stats': activity_stats,
            'rating_stats': rating_stats
        }
    
    return None

def update_user_profession(user_id, profession):
    """æ›´æ–°ç”¨æˆ¶è·æ¥­çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT profession_counts FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        profession_str = result[0]
        profession_counts = json.loads(profession_str) if profession_str else {}
        
        if profession in profession_counts:
            profession_counts[profession] += 1
        else:
            profession_counts[profession] = 1
        
        bonus_score = PROFESSION_BONUS.get(profession, 0)
        if bonus_score > 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("UPDATE users SET current_score = current_score + ?, total_score = total_score + ? WHERE user_id = ?", 
                         (bonus_score, bonus_score, user_id))
        
        cursor.execute("UPDATE users SET profession_counts = ? WHERE user_id = ?", 
                      (json.dumps(profession_counts), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_activity(user_id, event_name, attended=True):
    """æ›´æ–°ç”¨æˆ¶æ´»å‹•çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT activity_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        activity_str = result[0]
        activity_stats = json.loads(activity_str) if activity_str else {}
        
        # ç²å–ç•¶å‰åŠæœˆæœŸ
        now = datetime.now()
        year_month = now.strftime("%Y-%m")
        day = now.day
        current_period = f"{year_month}-ä¸ŠåŠ" if day <= 15 else f"{year_month}-ä¸‹åŠ"
        
        if current_period not in activity_stats:
            activity_stats[current_period] = {"total": 0, "attended": 0}
        
        activity_stats[current_period]["total"] += 1
        if attended:
            activity_stats[current_period]["attended"] += 1
        
        cursor.execute("UPDATE users SET activity_stats = ? WHERE user_id = ?", 
                      (json.dumps(activity_stats), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_rating(user_id, rating_type):
    """æ›´æ–°ç”¨æˆ¶è©•æ ¸çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        rating_str = result[0]
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        if rating_type in rating_stats:
            rating_stats[rating_type] += 1
        else:
            rating_stats[rating_type] = 1
        
        score = RATING_SCORES.get(rating_type, 0)
        
        if score != 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("""
                UPDATE users 
                SET current_score = current_score + ?, 
                    total_score = CASE 
                                    WHEN total_score + ? > 0 THEN total_score + ?
                                    ELSE 0
                                  END
                WHERE user_id = ?
            """, (score, score, score, user_id))
        
        # ä¿®å¾©ï¼šæ›´æ–°è©•ç´šçµ±è¨ˆæ•¸æ“šåˆ°è³‡æ–™åº«
        cursor.execute("UPDATE users SET rating_stats = ? WHERE user_id = ?", 
                      (json.dumps(rating_stats), user_id))
        
        conn.commit()
    
    conn.close()

def get_current_half_month():
    """ç²å–ç•¶å‰åŠæœˆæœŸ"""
    now = datetime.now()
    year_month = now.strftime("%Y-%m")
    day = now.day
    
    if day <= 15:
        return f"{year_month}-ä¸ŠåŠ"
    else:
        return f"{year_month}-ä¸‹åŠ"

async def end_giveaway(message_id: int, manual: bool = False):
    """çµæŸæŠ½ç"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, creator_id, prize, winner_count, participants, winners, channel_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (message_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        giveaway_id, creator_id, prize, winner_count, participants_json, winners_json, channel_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        channel = bot.get_channel(channel_id)
        
        if not channel:
            conn.close()
            return
        
        try:
            message = await channel.fetch_message(message_id)
        except:
            conn.close()
            return
        
        if participants:
            if len(participants) <= winner_count:
                winners_list = participants
            else:
                winners_list = random.sample(participants, winner_count)
            
            cursor.execute("UPDATE giveaways SET winners = ?, is_active = 0 WHERE id = ?", 
                         (json.dumps(winners_list), giveaway_id))
            conn.commit()
            
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ ğŸ‰",
                description="é–‹çå®Œæˆï¼",
                color=0x00FF00
            )
            
            new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
            new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(len(winners_list)), inline=True)
            new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
            
            winners_text = ""
            for i, winner_id in enumerate(winners_list[:5], 1):
                winners_text += f"{i}. <@{winner_id}>\n"
            
            if len(winners_list) > 5:
                winners_text += f"... é‚„æœ‰ {len(winners_list) - 5} äºº"
            
            if winners_text:
                new_embed.add_field(name="ğŸ† ç²çè€…", value=winners_text, inline=False)
            
            await message.edit(embed=new_embed)
            await message.clear_reactions()
            
            for winner_id in winners_list:
                await channel.send(f"ğŸ‰ æ­å–œ <@{winner_id}> ç²å¾—äº† **{prize}**ï¼")
        else:
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ",
                description="ç„¡äººåƒèˆ‡æŠ½ç" + ("ï¼ˆæ‰‹å‹•çµæŸï¼‰" if manual else ""),
                color=0xFF0000
            )
            await message.edit(embed=new_embed)
            await message.clear_reactions()
        
        conn.close()
        
    except Exception as e:
        print(f"çµæŸæŠ½çéŒ¯èª¤: {e}")

async def end_evaluation(event_id, channel, event_name):
    """çµæŸè©•æ ¸æ´»å‹•"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # ç²å–æ´»å‹•æ•¸æ“š
        cursor.execute("""
            SELECT participants, professions, ratings, rating_message_id 
            FROM evaluation_events 
            WHERE id = ?
        """, (event_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        participants_json, professions_json, ratings_json, rating_message_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        professions = json.loads(professions_json) if professions_json else {}
        ratings = json.loads(ratings_json) if ratings_json else {}
        
        # æ¨™è¨˜æ´»å‹•ç‚ºä¸æ´»èº
        cursor.execute("UPDATE evaluation_events SET is_active = 0 WHERE id = ?", (event_id,))
        conn.commit()
        conn.close()
        
        # å˜—è©¦æ¸…é™¤è©•æ ¸è¨Šæ¯çš„åæ‡‰
        try:
            rating_message = await channel.fetch_message(rating_message_id)
            await rating_message.clear_reactions()
            
            # æ›´æ–°è©•æ ¸è¨Šæ¯
            end_embed = discord.Embed(
                title=f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸï¼š{event_name}",
                description="æ­¤æ´»å‹•çš„è©•æ ¸éšæ®µå·²ç¶“çµæŸï¼Œæ„Ÿè¬æ‰€æœ‰åƒèˆ‡è€…ï¼",
                color=discord.Color.green()
            )
            
            end_embed.add_field(name="ğŸ“Š çµ±è¨ˆä¿¡æ¯", value=f"**ç¸½åƒèˆ‡äººæ•¸ï¼š** {len(participants)} äºº", inline=False)
            
            # é¡¯ç¤ºè©•ç´šåˆ†ä½ˆ
            rating_summary = {}
            for user_id, rating_list in ratings.items():
                if rating_list:
                    latest_rating = rating_list[-1]["rating"]
                    rating_summary[latest_rating] = rating_summary.get(latest_rating, 0) + 1
            
            rating_text = ""
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_summary.get(rating_type, 0)
                if count > 0:
                    rating_text += f"**{rating_type}ï¼š** {count}äºº\n"
            
            if rating_text:
                end_embed.add_field(name="â­ è©•ç´šåˆ†ä½ˆ", value=rating_text, inline=False)
            
            await rating_message.edit(embed=end_embed)
            
        except Exception as e:
            print(f"æ›´æ–°è©•æ ¸è¨Šæ¯éŒ¯èª¤: {e}")
        
        # ç™¼é€çµæŸé€šçŸ¥
        summary_embed = discord.Embed(
            title=f"ğŸ æ´»å‹•ç¸½çµï¼š{event_name}",
            description="è©•æ ¸æ´»å‹•å·²æ­£å¼çµæŸï¼",
            color=discord.Color.gold()
        )
        
        summary_embed.add_field(name="ğŸ‘¥ åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ® è·æ¥­é¸æ“‡", value=f"{len(professions)} äºº", inline=True)
        summary_embed.add_field(name="â­ è©•æ ¸å®Œæˆ", value=f"{len(ratings)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ“Š è©•ç´šåˆ†ä½ˆ", value=f"{len(rating_summary)} ç¨®è©•ç´š", inline=True)
        
        await channel.send(embed=summary_embed)
        
        print(f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸ: {event_name}")
        
    except Exception as e:
        print(f"çµæŸè©•æ ¸æ´»å‹•éŒ¯èª¤: {e}")

# ========== äº‹ä»¶è™•ç† ==========

@bot.event
async def setup_hook():
    """æ©Ÿå™¨äººè¨­ç½®é‰¤å­ï¼Œåœ¨on_readyä¹‹å‰åŸ·è¡Œ"""
    print("ğŸ”„ æ­£åœ¨è¨­ç½®æŒ‡ä»¤æ¨¹...")
    
    # è¨»å†Šæ‰€æœ‰æŒ‡ä»¤
    await bot.tree.sync()
    print("âœ… æŒ‡ä»¤æ¨¹è¨­ç½®å®Œæˆ")

@bot.event
async def on_ready():
    """æ©Ÿå™¨äººä¸Šç·š"""
    print(f"\n{'='*60}")
    print(f"ğŸ¤– {BOT_NAME} å·²ä¸Šç·š")
    print(f"ğŸ“Š ä¼ºæœå™¨æ•¸é‡: {len(bot.guilds)}")
    print(f"{'='*60}")
    
    init_db()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")
    
    try:
        print("\nğŸ”„ æ­£åœ¨å¼·åˆ¶åŒæ­¥æŒ‡ä»¤...")
        # æ¸…é™¤æ‰€æœ‰ç¾æœ‰æŒ‡ä»¤
        bot.tree.clear_commands(guild=None)
        
        # é‡æ–°åŒæ­¥å…¨å±€æŒ‡ä»¤
        synced = await bot.tree.sync()
        
        # åŒæ­¥åˆ°æ¯å€‹ä¼ºæœå™¨
        for guild in bot.guilds:
            await bot.tree.sync(guild=guild)
            print(f"âœ… å·²åŒæ­¥æŒ‡ä»¤åˆ°ä¼ºæœå™¨: {guild.name}")
        
        print(f"âœ… å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        
        # é¡¯ç¤ºå¯ç”¨æŒ‡ä»¤
        print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
        for cmd in synced:
            print(f"  â€¢ /{cmd.name} - {cmd.description}")
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")
    
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="/help æŸ¥çœ‹æŒ‡ä»¤"
        )
    )
    
    print(f"\nğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼")

@bot.event
async def on_raw_reaction_add(payload):
    """è™•ç†åæ‡‰äº‹ä»¶ - ç°¡åŒ–è©•æ ¸ç‰ˆæœ¬"""
    if payload.user_id == bot.user.id:
        return
    
    try:
        emoji = str(payload.emoji)
        user_id = payload.user_id
        
        # å–å¾—é »é“
        channel = bot.get_channel(payload.channel_id)
        if not channel:
            return
        
        # ç²å–è¨Šæ¯
        try:
            message = await channel.fetch_message(payload.message_id)
        except:
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # å…ˆæª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸çµæŸåæ‡‰
        cursor.execute("""
            SELECT id, channel_id, event_name 
            FROM evaluation_events 
            WHERE rating_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        rating_event = cursor.fetchone()
        
        if rating_event and emoji == RATING_END_EMOJI:
            event_id, event_channel_id, event_name = rating_event
            
            # æª¢æŸ¥æ˜¯å¦ç‚ºç®¡ç†å“¡
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    # ä¸æ˜¯ç®¡ç†å“¡ï¼Œç§»é™¤åæ‡‰
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥çµæŸè©•æ ¸æ´»å‹•ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            # ç¢ºèªçµæŸè©•æ ¸
            confirm_embed = discord.Embed(
                title="ğŸ ç¢ºèªçµæŸè©•æ ¸æ´»å‹•",
                description=f"ä½ ç¢ºå®šè¦çµæŸ **{event_name}** çš„è©•æ ¸éšæ®µå—ï¼Ÿ\n\n"
                          f"çµæŸå¾Œå°‡ï¼š\n"
                          f"â€¢ ç„¡æ³•å†é€²è¡Œè©•æ ¸\n"
                          f"â€¢ æ¸…é™¤è©•æ ¸è¨Šæ¯çš„æ‰€æœ‰åæ‡‰\n"
                          f"â€¢ æ´»å‹•æ¨™è¨˜ç‚ºå·²å®Œæˆ",
                color=discord.Color.orange()
            )
            
            class ConfirmEndView(discord.ui.View):
                def __init__(self, event_id, channel, event_name):
                    super().__init__(timeout=60)
                    self.event_id = event_id
                    self.channel = channel
                    self.event_name = event_name
                
                @discord.ui.button(label="ç¢ºå®šçµæŸ", style=discord.ButtonStyle.danger, emoji="âœ…")
                async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.defer()
                    
                    # çµæŸè©•æ ¸æ´»å‹•
                    await end_evaluation(self.event_id, self.channel, self.event_name)
                    
                    # ç¦ç”¨æŒ‰éˆ•
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
                    
                    await interaction.followup.send(f"âœ… å·²æˆåŠŸçµæŸ **{self.event_name}** çš„è©•æ ¸éšæ®µï¼")
                
                @discord.ui.button(label="å–æ¶ˆ", style=discord.ButtonStyle.secondary, emoji="âŒ")
                async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.send_message("å·²å–æ¶ˆçµæŸè©•æ ¸æ´»å‹•", ephemeral=True)
                    
                    # ç¦ç”¨æŒ‰éˆ•
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
            
            view = ConfirmEndView(event_id, channel, event_name)
            await channel.send(f"<@{user_id}>", embed=confirm_embed, view=view)
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸åæ‡‰
        if rating_event and emoji in RATING_EMOJIS:
            event_id, event_channel_id, event_name = rating_event
            rating_type = RATING_EMOJIS[emoji]
            
            print(f"æª¢æ¸¬åˆ°è©•æ ¸åæ‡‰: event_id={event_id}, rating_type={rating_type}, user_id={user_id}")
            
            # æª¢æŸ¥æ˜¯å¦ç‚ºç®¡ç†å“¡
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    # ä¸æ˜¯ç®¡ç†å“¡ï¼Œç§»é™¤åæ‡‰
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥é€²è¡Œè©•æ ¸ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            participants = []
            if result and result[0]:
                participants = json.loads(result[0])
            
            if not participants:
                await channel.send("âŒ æ²’æœ‰åƒèˆ‡è€…å¯ä»¥è©•æ ¸", delete_after=5)
                conn.close()
                return
            
            print(f"æ´»å‹• {event_name} æœ‰ {len(participants)} ä½åƒèˆ‡è€…å¯ä»¥è©•æ ¸")
            
            # å‰µå»ºé¸æ“‡åƒèˆ‡è€…çš„è¦–çª—
            class ParticipantSelectView(discord.ui.View):
                def __init__(self, participants, event_id, rating_type, channel, bot_instance):
                    super().__init__(timeout=60)
                    self.participants = participants
                    self.event_id = event_id
                    self.rating_type = rating_type
                    self.channel = channel
                    self.bot = bot_instance
                    
                    # å»ºç«‹é¸é …
                    options = []
                    for pid in participants[:25]:  # Discordé™åˆ¶æœ€å¤š25å€‹é¸é …
                        member = self.bot.get_user(int(pid))
                        display_name = member.display_name if member else f"ç”¨æˆ¶ID: {pid}"
                        options.append(discord.SelectOption(
                            label=display_name[:100],  # Discordé™åˆ¶æ¨™é¡Œé•·åº¦
                            value=str(pid),
                            description=f"é»æ“Šé¸æ“‡æ­¤ç”¨æˆ¶é€²è¡Œ {rating_type} è©•æ ¸"
                        ))
                    
                    # å»ºç«‹é¸æ“‡å™¨
                    select = discord.ui.Select(
                        placeholder=f"é¸æ“‡è¦è©•æ ¸ç‚º {rating_type} çš„åƒèˆ‡è€…",
                        options=options,
                        min_values=1,
                        max_values=1
                    )
                    
                    # å®šç¾©å›èª¿å‡½æ•¸
                    async def select_callback(interaction: discord.Interaction):
                        if not interaction.user.guild_permissions.administrator:
                            await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                            return
                        
                        selected_user_id = int(select.values[0])
                        selected_member = self.bot.get_user(selected_user_id)
                        display_name = selected_member.display_name if selected_member else f"ç”¨æˆ¶ID: {selected_user_id}"
                        
                        print(f"é¸æ“‡äº†ç”¨æˆ¶ {display_name} ({selected_user_id}) é€²è¡Œ {rating_type} è©•æ ¸")
                        
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        
                        cursor.execute("SELECT ratings FROM evaluation_events WHERE id = ?", (self.event_id,))
                        result = cursor.fetchone()
                        
                        ratings = {}
                        if result and result[0]:
                            ratings = json.loads(result[0])
                        
                        # æª¢æŸ¥ä¹‹å‰çš„è©•ç´š
                        old_rating = None
                        if str(selected_user_id) in ratings and ratings[str(selected_user_id)]:
                            old_rating = ratings[str(selected_user_id)][-1]["rating"] if ratings[str(selected_user_id)] else None
                        
                        # æ›´æ–°è©•ç´š
                        if str(selected_user_id) not in ratings:
                            ratings[str(selected_user_id)] = []
                        
                        ratings[str(selected_user_id)].append({
                            "rater": interaction.user.id,
                            "rating": self.rating_type,
                            "time": datetime.now().isoformat()
                        })
                        
                        cursor.execute("UPDATE evaluation_events SET ratings = ? WHERE id = ?", 
                                     (json.dumps(ratings), self.event_id))
                        conn.commit()
                        conn.close()
                        
                        # æ›´æ–°ç”¨æˆ¶è©•æ ¸çµ±è¨ˆï¼ˆç§»é™¤èˆŠè©•ç´šç©åˆ†ï¼ŒåŠ ä¸Šæ–°è©•ç´šç©åˆ†ï¼‰
                        if old_rating and old_rating != self.rating_type:
                            # ç§»é™¤èˆŠè©•ç´šç©åˆ†
                            old_score = RATING_SCORES.get(old_rating, 0)
                            update_user_score(selected_user_id, display_name, -old_score, f"è©•ç´šè®Šæ›´: {old_rating} â†’ {self.rating_type}")
                            print(f"ç§»é™¤èˆŠè©•ç´šç©åˆ†: {old_rating} (-{old_score}åˆ†)")
                        
                        # åŠ ä¸Šæ–°è©•ç´šç©åˆ†
                        new_score = RATING_SCORES.get(self.rating_type, 0)
                        update_user_rating(selected_user_id, self.rating_type)
                        
                        if new_score != 0:
                            update_user_score(selected_user_id, display_name, new_score, f"æ´»å‹•è©•æ ¸: {self.rating_type}")
                            print(f"æ·»åŠ æ–°è©•ç´šç©åˆ†: {self.rating_type} (+{new_score}åˆ†)")
                        
                        # ç™¼é€çµæœ
                        score_change = RATING_SCORES.get(self.rating_type, 0)
                        score_text = f"ï¼ˆç©åˆ†è®Šå‹•: {'+' if score_change > 0 else ''}{score_change}åˆ†ï¼‰" if score_change != 0 else ""
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            result_text = f"å·²å°‡ <@{selected_user_id}> ({display_name}) çš„è©•ç´šå¾ **{old_rating}** ({old_score}åˆ†) è®Šæ›´ç‚º **{self.rating_type}** {score_text}"
                        else:
                            result_text = f"å·²ç‚º <@{selected_user_id}> ({display_name}) è©•æ ¸ï¼š**{self.rating_type}** {score_text}"
                        
                        result_embed = discord.Embed(
                            title="âœ… è©•æ ¸å®Œæˆ",
                            description=result_text,
                            color=discord.Color.green() if score_change >= 0 else discord.Color.red()
                        )
                        
                        result_embed.add_field(name="è©•æ ¸è€…", value=interaction.user.mention, inline=True)
                        result_embed.add_field(name="æ–°è©•ç´š", value=self.rating_type, inline=True)
                        result_embed.add_field(name="ç©åˆ†è®Šå‹•", value=f"{score_change} åˆ†", inline=True)
                        
                        await interaction.response.send_message(embed=result_embed)
                        
                        # ç¦ç”¨è¦–çª—
                        for child in self.children:
                            child.disabled = True
                        await interaction.message.edit(view=self)
                    
                    select.callback = select_callback
                    self.add_item(select)
            
            view = ParticipantSelectView(participants, event_id, rating_type, channel, bot)
            
            # ç™¼é€é¸æ“‡è¦–çª—
            select_message = await channel.send(f"<@{user_id}> è«‹é¸æ“‡è¦è©•æ ¸ç‚º **{rating_type}** çš„åƒèˆ‡è€…ï¼š", view=view)
            print(f"å·²ç™¼é€é¸æ“‡è¦–çª—: message_id={select_message.id}")
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºæŠ½çè¨Šæ¯
        cursor.execute("""
            SELECT id, participants, creator_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (payload.message_id,))
        giveaway = cursor.fetchone()
        
        if giveaway:
            giveaway_id, participants_json, creator_id = giveaway
            
            if emoji == "ğŸ«":
                participants = json.loads(participants_json) if participants_json else []
                
                if user_id not in participants:
                    participants.append(user_id)
                    cursor.execute("UPDATE giveaways SET participants = ? WHERE id = ?", 
                                 (json.dumps(participants), giveaway_id))
                    conn.commit()
                    
                    try:
                        if message.embeds:
                            embed = message.embeds[0]
                            
                            new_embed = discord.Embed(
                                title=embed.title,
                                description=embed.description,
                                color=embed.color
                            )
                            
                            for field in embed.fields:
                                if field.name == "ğŸ« åƒèˆ‡äººæ•¸":
                                    new_embed.add_field(
                                        name="ğŸ« åƒèˆ‡äººæ•¸", 
                                        value=f"{len(participants)} äºº", 
                                        inline=field.inline
                                    )
                                else:
                                    new_embed.add_field(
                                        name=field.name, 
                                        value=field.value, 
                                        inline=field.inline
                                    )
                            
                            if embed.footer:
                                new_embed.set_footer(text=embed.footer.text)
                            
                            await message.edit(embed=new_embed)
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            elif emoji == "â¹ï¸" and user_id == creator_id:
                await end_giveaway(payload.message_id, manual=True)
                await channel.send(f"â¹ï¸ ä¸»è¾¦äººæ‰‹å‹•çµæŸäº†æŠ½çï¼")
        
        # è™•ç†è©•æ ¸æ´»å‹•ç°½åˆ°
        cursor.execute("""
            SELECT id, participants, signup_end_time 
            FROM evaluation_events 
            WHERE signup_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        signup_event = cursor.fetchone()
        
        if signup_event and emoji == "âœ…":
            event_id, participants_json, signup_end_time_str = signup_event
            
            try:
                # å®‰å…¨è§£ææ™‚é–“
                if signup_end_time_str:
                    try:
                        signup_end_time = datetime.strptime(signup_end_time_str.split('.')[0], '%Y-%m-%d %H:%M:%S')
                    except:
                        try:
                            signup_end_time = datetime.strptime(signup_end_time_str, '%Y-%m-%d %H:%M:%S.%f')
                        except:
                            signup_end_time = None
                else:
                    signup_end_time = None
                
                if signup_end_time and datetime.now() > signup_end_time:
                    try:
                        await message.remove_reaction("âœ…", payload.member)
                        await channel.send(f"âŒ <@{user_id}> ç°½åˆ°æ™‚é–“å·²éï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as time_error:
                print(f"æ™‚é–“è§£æéŒ¯èª¤: {time_error}")
            
            participants = json.loads(participants_json) if participants_json else []
            
            if user_id not in participants:
                participants.append(user_id)
                cursor.execute("UPDATE evaluation_events SET participants = ? WHERE id = ?", 
                             (json.dumps(participants), event_id))
                conn.commit()
                
                print(f"âœ… ç”¨æˆ¶ {user_id} æˆåŠŸç°½åˆ°æ´»å‹• {event_id}")
                
                try:
                    if message.embeds:
                        embed = message.embeds[0]
                        
                        new_embed = discord.Embed(
                            title=embed.title,
                            description=embed.description,
                            color=embed.color
                        )
                        
                        for field in embed.fields:
                            if field.name == "ğŸ‘¥ å·²ç°½åˆ°":
                                new_embed.add_field(
                                    name="ğŸ‘¥ å·²ç°½åˆ°", 
                                    value=f"{len(participants)} äºº", 
                                    inline=field.inline
                                )
                            elif field.name == "â±ï¸ å‰©é¤˜æ™‚é–“":
                                new_embed.add_field(
                                    name=field.name,
                                    value=field.value,
                                    inline=field.inline
                                )
                            else:
                                new_embed.add_field(
                                    name=field.name, 
                                    value=field.value, 
                                    inline=field.inline
                                )
                        
                        if embed.footer:
                            new_embed.set_footer(text=embed.footer.text)
                        
                        await message.edit(embed=new_embed)
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
        
        # è™•ç†è·æ¥­é¸æ“‡
        cursor.execute("""
            SELECT id, professions 
            FROM evaluation_events 
            WHERE profession_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        profession_event = cursor.fetchone()
        
        if profession_event and emoji in PROFESSION_EMOJIS:
            event_id, professions_json = profession_event
            profession_name = PROFESSION_EMOJIS[emoji]
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            if result and result[0]:
                participants = json.loads(result[0])
                
                if user_id in participants:
                    professions = json.loads(professions_json) if professions_json else {}
                    
                    if str(user_id) not in professions:
                        professions[str(user_id)] = profession_name
                        cursor.execute("UPDATE evaluation_events SET professions = ? WHERE id = ?", 
                                     (json.dumps(professions), event_id))
                        conn.commit()
                        
                        update_user_profession(user_id, profession_name)
                        
                        try:
                            bonus = PROFESSION_BONUS.get(profession_name, 0)
                            bonus_text = f"ï¼ˆç²å¾—è·æ¥­åŠ æˆï¼š+{bonus}ç©åˆ†ï¼‰" if bonus > 0 else ""
                            await channel.send(f"âœ… <@{user_id}> å·²é¸æ“‡è·æ¥­ï¼š**{profession_name}**{bonus_text}", delete_after=5)
                        except:
                            pass
                    else:
                        try:
                            await message.remove_reaction(emoji, payload.member)
                            await channel.send(f"âš ï¸ <@{user_id}> ä½ å·²ç¶“é¸æ“‡éè·æ¥­äº†ï¼", delete_after=5)
                        except:
                            pass
                else:
                    try:
                        await message.remove_reaction(emoji, payload.member)
                        await channel.send(f"âŒ <@{user_id}> è«‹å…ˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼", delete_after=5)
                    except:
                        pass
        
        conn.close()
        
    except Exception as e:
        print(f"è™•ç†åæ‡‰éŒ¯èª¤: {e}")
        import traceback
        traceback.print_exc()

# ========== æ–œæ§“æŒ‡ä»¤ ==========

@bot.tree.command(name="sync", description="åŒæ­¥æ–œæ§“æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰")
async def sync_slash(interaction: discord.Interaction):
    """åŒæ­¥æŒ‡ä»¤"""
    await interaction.response.defer(ephemeral=True)
    
    if interaction.user.id not in OWNER_IDS:
        embed = discord.Embed(
            title="âŒ æ¬Šé™ä¸è¶³",
            description="åªæœ‰æ©Ÿå™¨äººæ“æœ‰è€…å¯ä»¥ä½¿ç”¨æ­¤æŒ‡ä»¤",
            color=0xFF0000
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        return
    
    try:
        print("ğŸ”„ å¼·åˆ¶åŒæ­¥æŒ‡ä»¤ä¸­...")
        bot.tree.clear_commands(guild=None)
        global_synced = await bot.tree.sync()
        
        # åŒæ­¥åˆ°æ‰€æœ‰ä¼ºæœå™¨
        for guild in bot.guilds:
            await bot.tree.sync(guild=guild)
            print(f"âœ… å·²åŒæ­¥æŒ‡ä»¤åˆ°ä¼ºæœå™¨: {guild.name}")
        
        embed = discord.Embed(
            title="ğŸ”„ æŒ‡ä»¤åŒæ­¥å®Œæˆ",
            description=f"å·²åŒæ­¥ {len(global_synced)} å€‹æŒ‡ä»¤åˆ°æ‰€æœ‰ä¼ºæœå™¨",
            color=0x43B581
        )
        
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åŒæ­¥å¤±æ•—",
            description=f"éŒ¯èª¤è¨Šæ¯: {str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed, ephemeral=True)

@bot.tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯ / å¹«åŠ©")
async def help_slash(interaction: discord.Interaction):
    """é¡¯ç¤ºå¹«åŠ©"""
    embed = discord.Embed(
        title="ğŸ¤– å°é›²æ©Ÿæ¢°äºº - å¹«åŠ©ä¸­å¿ƒ",
        description="ä»¥ä¸‹æ˜¯å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ï¼š",
        color=0x7289DA
    )
    
    embed.add_field(
        name="ğŸ‘¤ ç”¨æˆ¶æŒ‡ä»¤",
        value=(
            "`/help` - é¡¯ç¤ºæ­¤å¹«åŠ©è¨Šæ¯\n"
            "`/profile` - æŸ¥çœ‹æˆ‘çš„æ•¸æ“š\n"
            "`/giveaway [çå“] [æ™‚é–“]` - å‰µå»ºæŠ½ç\n"
            "`/score_draw` - ä½¿ç”¨ç©åˆ†æŠ½ç\n"
            "`/score_transfer [ç”¨æˆ¶] [ç©åˆ†]` - è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶\n"
            "`/prizelist` - æŸ¥çœ‹å½©æ± åˆ—è¡¨\n"
            "`/random_team [äººæ•¸] [çµ„æ•¸]` - éš¨æ©Ÿåˆ†çµ„"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ› ï¸ ç®¡ç†å“¡æŒ‡ä»¤",
        value=(
            "`/add_prize [åç¨±] [é¡å‹] [æ•¸é‡]` - èª¿æ•´å½©æ± \n"
            "`/add_score [ç”¨æˆ¶] [ç©åˆ†] [åŸå› ]` - åŠ æ¸›ç©åˆ†\n"
            "`/create_event [æ´»å‹•åç¨±]` - å‰µå»ºè©•æ ¸æ´»å‹•\n"
            "`/all_profiles [æ’åº] [æ•¸é‡]` - æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™\n"
            "`/attendance_stats [æœŸé–“]` - æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ’° ç©åˆ†ç³»çµ±",
        value=(
            "**ç°½åˆ°çå‹µï¼š** 40ç©åˆ†\n"
            "**è·æ¥­åŠ æˆï¼š** è£œå¸«+20ç©åˆ†ï¼ˆå…¶ä»–è·æ¥­ç„¡åŠ æˆï¼‰\n"
            "**è©•æ ¸çå‹µï¼š**\n"
            "  â€¢ å„ªç§€ï¼š+40ç©åˆ†\n"
            "  â€¢ è‰¯å¥½ï¼š+10ç©åˆ†\n"
            "  â€¢ æ™®é€šï¼š+0ç©åˆ†ï¼ˆé è¨­ï¼‰\n"
            "  â€¢ ä¸åˆæ ¼ï¼š-5ç©åˆ†"
        ),
        inline=False
    )
    
    embed.set_footer(text="ä½¿ç”¨ / é–‹é ­è¼¸å…¥æŒ‡ä»¤")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="profile", description="æŸ¥çœ‹æˆ‘çš„æ•¸æ“š / æˆ‘çš„æ•¸æ“š")
async def profile_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        user_id = interaction.user.id
        username = interaction.user.name
        
        profile = get_user_profile(user_id)
        
        if not profile:
            conn = sqlite3.connect(DB_NAME)
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
                (user_id, username, 0, 0)
            )
            conn.commit()
            conn.close()
            
            profile = {
                'user_id': user_id,
                'current_score': 0,
                'total_score': 0,
                'join_date': datetime.now().strftime('%Y-%m-%d'),
                'profession_counts': {},
                'activity_stats': {},
                'rating_stats': {}
            }
        
        current_score = profile['current_score']
        total_score = profile['total_score']
        join_date_str = profile['join_date']
        profession_counts = profile['profession_counts']
        activity_stats = profile['activity_stats']
        rating_stats = profile['rating_stats']
        
        current_period = get_current_half_month()
        period_data = activity_stats.get(current_period, {})
        total_events = period_data.get('total', 0)
        attended_events = period_data.get('attended', 0)
        attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
        
        embed = discord.Embed(
            title=f"ğŸ“Š {username} çš„è©•æ ¸æ•¸æ“š",
            color=0x43B581
        )
        
        attendance_info = (
            f"**ç•¶å‰åŠæœˆæœŸï¼š** {current_period}\n"
            f"**ç¸½æ´»å‹•æ•¸ï¼š** {total_events} æ¬¡\n"
            f"**å¯¦éš›å‡ºå¸­ï¼š** {attended_events} æ¬¡\n"
            f"**å‡ºå¸­ç‡ï¼š** {attendance_rate:.1f}%\n\n"
            f"**è¨ˆç®—å…¬å¼ï¼š** (å¯¦éš›å‡ºå¸­æ¬¡æ•¸ Ã· ç¸½æ´»å‹•æ•¸) Ã— 100%\n"
            f"**è¨»ï¼š** åƒ…è¨ˆç®—æ´»å‹•æ™‚é–“å…§ç°½åˆ°ï¼Œéæ™‚ç°½åˆ°ä¸è¨ˆå…¥"
        )
        
        embed.add_field(
            name="ğŸ“… åŠæœˆæœŸå‡ºå¸­ç‡",
            value=attendance_info,
            inline=False
        )
        
        score_info = f"**ç•¶å‰ç©åˆ†ï¼š** {current_score} åˆ†\n"
        score_info += f"**ç¸½ç²å¾—ç©åˆ†ï¼š** {total_score} åˆ†\n"
        score_info += f"**ç¾æœ‰ç©åˆ†å¯ç”¨ï¼š** {current_score} åˆ†\n\n"
        score_info += f"**ç©åˆ†è¦å‰‡ï¼š**\n"
        score_info += f"â€¢ ç°½åˆ°ï¼š+{SIGNUP_SCORE}åˆ†\n"
        for profession, bonus in PROFESSION_BONUS.items():
            if bonus > 0:
                score_info += f"â€¢ {profession}ï¼š+{bonus}åˆ†\n"
        score_info += f"â€¢ å„ªç§€ï¼š+{RATING_SCORES['å„ªç§€']}åˆ†\n"
        score_info += f"â€¢ è‰¯å¥½ï¼š+{RATING_SCORES['è‰¯å¥½']}åˆ†\n"
        score_info += f"â€¢ æ™®é€šï¼š{RATING_SCORES['æ™®é€š']}åˆ†ï¼ˆé è¨­ï¼‰\n"
        score_info += f"â€¢ ä¸åˆæ ¼ï¼š{RATING_SCORES['ä¸åˆæ ¼']}åˆ†"
        
        embed.add_field(
            name="ğŸ’° ç©åˆ†çµ±è¨ˆ",
            value=score_info,
            inline=False
        )
        
        if profession_counts:
            profession_info = ""
            total_plays = sum(profession_counts.values())
            for profession, count in profession_counts.items():
                percentage = (count / total_plays * 100) if total_plays > 0 else 0
                profession_info += f"**{profession}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
        else:
            profession_info = "å°šæœªè¨˜éŒ„è·æ¥­æ•¸æ“š"
        
        embed.add_field(
            name="ğŸ® è·æ¥­çµ±è¨ˆ",
            value=profession_info,
            inline=False
        )
        
        if rating_stats:
            rating_info = ""
            total_ratings = sum(rating_stats.values())
            total_rating_score = 0
            
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_stats.get(rating_type, 0)
                if count > 0:
                    percentage = (count / total_ratings * 100) if total_ratings > 0 else 0
                    score = RATING_SCORES.get(rating_type, 0)
                    rating_info += f"**{rating_type}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
                    total_rating_score += count * score
            
            if total_ratings > 0:
                rating_info += f"\n**è©•æ ¸ç¸½ç²å¾—ç©åˆ†ï¼š** {total_rating_score} åˆ†"
        else:
            rating_info = "å°šæœªæœ‰è©•æ ¸è¨˜éŒ„"
        
        embed.add_field(
            name="â­ è©•æ ¸çµ±è¨ˆ",
            value=rating_info,
            inline=False
        )
        
        embed.add_field(name="ç”¨æˆ¶ID", value=f"`{user_id}`", inline=True)
        embed.add_field(name="åŠ å…¥æ—¥æœŸ", value=join_date_str, inline=True)
        embed.add_field(name="DiscordåŠ å…¥", value=interaction.user.created_at.strftime('%Y-%m-%d'), inline=True)
        
        if interaction.user.avatar:
            embed.set_thumbnail(url=interaction.user.avatar.url)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ ç™¼ç”ŸéŒ¯èª¤",
            description=f"ç„¡æ³•è®€å–ç”¨æˆ¶è³‡æ–™ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="giveaway", description="å‰µå»ºæŠ½çæ´»å‹• / æŠ½ç")
@app_commands.describe(
    prize="çå“å…§å®¹",
    duration="æŠ½çæŒçºŒæ™‚é–“ï¼ˆä¾‹å¦‚ï¼š60s, 1m, 1h, 1dï¼‰",
    winners="ç²çäººæ•¸"
)
async def giveaway_slash(
    interaction: discord.Interaction,
    prize: str,
    duration: str = "1h",
    winners: int = 1
):
    """å‰µå»ºæŠ½ç"""
    await interaction.response.defer()
    
    try:
        # è§£ææ™‚é–“
        duration_lower = duration.lower().strip()
        seconds = 3600  # é è¨­1å°æ™‚
        
        if duration_lower.endswith('s'):
            seconds = int(duration_lower[:-1])
        elif duration_lower.endswith('m'):
            seconds = int(duration_lower[:-1]) * 60
        elif duration_lower.endswith('h'):
            seconds = int(duration_lower[:-1]) * 3600
        elif duration_lower.endswith('d'):
            seconds = int(duration_lower[:-1]) * 86400
        elif duration_lower.isdigit():
            seconds = int(duration_lower)
        
        if seconds < 10:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“å¿…é ˆè‡³å°‘10ç§’ï¼")
            return
        
        if seconds > 86400 * 7:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“ä¸èƒ½è¶…é7å¤©ï¼")
            return
        
        end_time = datetime.now() + timedelta(seconds=seconds)
        
        # æ ¼å¼åŒ–æ™‚é–“é¡¯ç¤º
        if seconds < 60:
            time_display = f"{seconds}ç§’"
        elif seconds < 3600:
            time_display = f"{seconds//60}åˆ†{seconds%60}ç§’"
        elif seconds < 86400:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            time_display = f"{hours}å°æ™‚{minutes}åˆ†"
        else:
            days = seconds // 86400
            hours = (seconds % 86400) // 3600
            time_display = f"{days}å¤©{hours}å°æ™‚"
        
        embed = discord.Embed(
            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
            color=0xFFD700
        )
        
        embed.add_field(name="ğŸ çå“", value=prize, inline=True)
        embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
        embed.add_field(name="â° çµæŸæ™‚é–“", value=time_display, inline=True)
        embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value="0 äºº", inline=True)
        embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
        embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
        
        creator_name = interaction.user.display_name
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
        giveaway_id = f"giveaway_{int(time.time())}_{random.randint(1000, 9999)}"
        
        embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{current_time}")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ«")
        await message.add_reaction("â¹ï¸")
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO giveaways (creator_id, prize, winner_count, end_time, message_id, channel_id)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (interaction.user.id, prize, winners, end_time, message.id, interaction.channel.id))
        conn.commit()
        conn.close()
        
        print(f"âœ… æŠ½çå·²å‰µå»º: çå“={prize}, æ™‚é–“={seconds}ç§’, è¨Šæ¯ID={message.id}")
        
        async def countdown_timer():
            remaining = seconds
            last_update = time.time()
            
            while remaining > 0:
                await asyncio.sleep(1)
                remaining -= 1
                
                if time.time() - last_update >= 30:
                    if remaining < 60:
                        time_display = f"{remaining}ç§’"
                    elif remaining < 3600:
                        time_display = f"{remaining//60}åˆ†{remaining%60}ç§’"
                    elif remaining < 86400:
                        hours = remaining // 3600
                        minutes = (remaining % 3600) // 60
                        time_display = f"{hours}å°æ™‚{minutes}åˆ†"
                    else:
                        days = remaining // 86400
                        hours = (remaining % 86400) // 3600
                        time_display = f"{days}å¤©{hours}å°æ™‚"
                    
                    try:
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        cursor.execute("SELECT participants FROM giveaways WHERE message_id = ?", (message.id,))
                        result = cursor.fetchone()
                        participants_count = 0
                        if result and result[0]:
                            participants = json.loads(result[0])
                            participants_count = len(participants)
                        conn.close()
                        
                        new_embed = discord.Embed(
                            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
                            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
                            color=0xFFD700
                        )
                        
                        new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
                        new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
                        new_embed.add_field(name="â° çµæŸæ™‚é–“", value=f"{time_display}å…§", inline=True)
                        new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{participants_count} äºº", inline=True)
                        new_embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
                        new_embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
                        
                        new_embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{datetime.now().strftime('%Y-%m-%d %H:%M')}")
                        
                        await message.edit(embed=new_embed)
                        last_update = time.time()
                        
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            await end_giveaway(message.id)
        
        asyncio.create_task(countdown_timer())
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)
        print(f"Giveaway error: {e}")

@bot.tree.command(name="score_draw", description="ä½¿ç”¨ç©åˆ†æŠ½ç / ç©åˆ†æŠ½ç")
async def score_draw_slash(interaction: discord.Interaction):
    """ç©åˆ†æŠ½ç"""
    await interaction.response.defer()
    
    try:
        current_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ² ç©åˆ†æŠ½çç³»çµ±",
            description="è«‹é¸æ“‡è¦æ‰£é™¤çš„ç©åˆ†é€²è¡ŒæŠ½çï¼š",
            color=0x9B59B6
        )
        
        embed.add_field(
            name="ğŸŸ¢ 50ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 70%\nâ€¢ è—ç®± 25%\nâ€¢ ç´«ç®± 4.5%\nâ€¢ é‡‘ç®± 0.5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ”µ 100ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 50%\nâ€¢ è—ç®± 40%\nâ€¢ ç´«ç®± 9%\nâ€¢ é‡‘ç®± 1%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸŸ£ 500ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 10%\nâ€¢ è—ç®± 65%\nâ€¢ ç´«ç®± 20%\nâ€¢ é‡‘ç®± 5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ’° ä½ çš„ç©åˆ†",
            value=f"{current_score} åˆ†",
            inline=False
        )
        
        embed.set_footer(text="é»æ“Šä¸‹æ–¹å°æ‡‰çš„emojié¸æ“‡æŠ½çé¡å‹")
        
        class ScoreDrawView(discord.ui.View):
            def __init__(self, user_id):
                super().__init__(timeout=60)
                self.user_id = user_id
            
            @discord.ui.button(label="50åˆ†", style=discord.ButtonStyle.success, emoji="ğŸŸ¢", row=0)
            async def fifty_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 50)
            
            @discord.ui.button(label="100åˆ†", style=discord.ButtonStyle.primary, emoji="ğŸ”µ", row=0)
            async def hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 100)
            
            @discord.ui.button(label="500åˆ†", style=discord.ButtonStyle.secondary, emoji="ğŸŸ£", row=1)
            async def five_hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 500)
            
            async def process_draw(self, interaction: discord.Interaction, score_cost: int):
                if interaction.user.id != self.user_id:
                    await interaction.response.send_message("âŒ é€™ä¸æ˜¯ä½ çš„æŠ½çï¼", ephemeral=True)
                    return
                
                current_score, _ = get_user_score(interaction.user.id)
                if current_score < score_cost:
                    await interaction.response.send_message(
                        f"âŒ ç©åˆ†ä¸è¶³ï¼éœ€è¦ {score_cost} åˆ†ï¼Œä½ ç›®å‰æœ‰ {current_score} åˆ†",
                        ephemeral=True
                    )
                    return
                
                weights = {
                    50: {"ç¶ ç®±": 70, "è—ç®±": 25, "ç´«ç®±": 4.5, "é‡‘ç®±": 0.5},
                    100: {"ç¶ ç®±": 50, "è—ç®±": 40, "ç´«ç®±": 9, "é‡‘ç®±": 1},
                    500: {"ç¶ ç®±": 10, "è—ç®±": 65, "ç´«ç®±": 20, "é‡‘ç®±": 5}
                }
                
                box_weights = weights[score_cost]
                box_types = list(box_weights.keys())
                box_weights_list = list(box_weights.values())
                selected_box = random.choices(box_types, weights=box_weights_list, k=1)[0]
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute(
                    "SELECT id, prize_name FROM prize_pool WHERE box_level = ? AND remaining > 0 ORDER BY RANDOM() LIMIT 1",
                    (selected_box,)
                )
                result = cursor.fetchone()
                
                if not result:
                    await interaction.response.send_message(f"âŒ {selected_box}ä¸­æ²’æœ‰å¯ç”¨çå“ï¼", ephemeral=True)
                    conn.close()
                    return
                
                prize_id, prize_name = result
                
                update_user_score(interaction.user.id, interaction.user.name, -score_cost, f"ç©åˆ†æŠ½ç ({selected_box})")
                cursor.execute("UPDATE prize_pool SET remaining = remaining - 1 WHERE id = ?", (prize_id,))
                
                cursor.execute('''
                    INSERT INTO score_draws (creator_id, score_cost, box_level, winner_prize, winner_id)
                    VALUES (?, ?, ?, ?, ?)
                ''', (interaction.user.id, score_cost, selected_box, prize_name, interaction.user.id))
                
                conn.commit()
                conn.close()
                
                new_current_score, _ = get_user_score(interaction.user.id)
                
                result_embed = discord.Embed(
                    title="ğŸ‰ æŠ½ççµæœ",
                    description=f"ä½ æŠ½ä¸­äº† **{prize_name}**ï¼",
                    color=0x00FF00
                )
                
                result_embed.add_field(name="æ‰£é™¤ç©åˆ†", value=f"{score_cost} åˆ†", inline=True)
                result_embed.add_field(name="å¯¶ç®±é¡å‹", value=selected_box, inline=True)
                result_embed.add_field(name="ä¸­çæ©Ÿç‡", value=f"{box_weights[selected_box]}%", inline=True)
                result_embed.add_field(name="å‰©é¤˜ç©åˆ†", value=f"{new_current_score} åˆ†", inline=True)
                result_embed.add_field(name="çå“åç¨±", value=prize_name, inline=False)
                
                await interaction.response.send_message(embed=result_embed, ephemeral=False)
                
                for child in self.children:
                    child.disabled = True
                
                await interaction.message.edit(view=self)
        
        view = ScoreDrawView(interaction.user.id)
        await interaction.followup.send(embed=embed, view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="score_transfer", description="è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶ / ç©åˆ†éæˆ¶")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="è½‰ç§»ç©åˆ†",
    reason="åŸå› ï¼ˆå¯é¸ï¼‰"
)
async def score_transfer_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: Optional[str] = None
):
    """è½‰ç§»ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if amount <= 0:
            await interaction.followup.send("âŒ ç©åˆ†å¿…é ˆå¤§æ–¼ 0")
            return
        
        if user.id == interaction.user.id:
            await interaction.followup.send("âŒ ä¸èƒ½è½‰ç§»ç©åˆ†çµ¦è‡ªå·±")
            return
        
        sender_score, _ = get_user_score(interaction.user.id)
        
        if sender_score < amount:
            await interaction.followup.send(f"âŒ ä½ çš„ç©åˆ†ä¸è¶³ï¼éœ€è¦ {amount} åˆ†ï¼Œä½ ç›®å‰æœ‰ {sender_score} åˆ†")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        update_user_score(interaction.user.id, interaction.user.name, -amount, f"è½‰ç§»çµ¦ {user.name}")
        update_user_score(user.id, user.name, amount, f"ä¾†è‡ª {interaction.user.name} çš„è½‰ç§»")
        
        cursor.execute('''
            INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason)
            VALUES (?, ?, ?, ?)
        ''', (interaction.user.id, user.id, amount, reason or "ç„¡"))
        
        conn.commit()
        conn.close()
        
        new_sender_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ’¸ ç©åˆ†è½‰ç§»æˆåŠŸ",
            description=f"**è½‰å‡ºï¼š** {interaction.user.mention}\n"
                       f"**è½‰å…¥ï¼š** {user.mention}\n"
                       f"**é‡‘é¡ï¼š** {amount} åˆ†\n"
                       f"**åŸå› ï¼š** {reason or 'ç„¡'}\n"
                       f"**ä½ çš„å‰©é¤˜ç©åˆ†ï¼š** {new_sender_score} åˆ†",
            color=0x2ECC71
        )
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è½‰ç§»å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="prizelist", description="æŸ¥çœ‹å½©æ± åˆ—è¡¨ / å½©æ± ")
async def prizelist_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹å½©æ± """
    await interaction.response.defer()
    
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='prize_pool'")
        if not cursor.fetchone():
            embed = discord.Embed(
                title="âŒ å½©æ± è¡¨æ ¼ä¸å­˜åœ¨",
                description="è«‹é‡æ–°å•Ÿå‹•æ©Ÿå™¨äººä»¥åˆå§‹åŒ–è³‡æ–™åº«",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed)
            conn.close()
            return
        
        cursor.execute("""
            SELECT box_level, 
                   COUNT(*) as total_items,
                   SUM(remaining) as total_remaining
            FROM prize_pool 
            WHERE remaining > 0 
            GROUP BY box_level 
            ORDER BY 
                CASE box_level 
                    WHEN 'é‡‘ç®±' THEN 1 
                    WHEN 'ç´«ç®±' THEN 2 
                    WHEN 'è—ç®±' THEN 3 
                    WHEN 'ç¶ ç®±' THEN 4 
                    ELSE 5 
                END
        """)
        
        results = cursor.fetchall()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ å½©æ± åˆ—è¡¨",
                description="ç›®å‰å½©æ± æ˜¯ç©ºçš„",
                color=0xFFD700
            )
            await interaction.followup.send(embed=embed)
            conn.close()
            return
        
        embed = discord.Embed(
            title="ğŸ å½©æ± åˆ—è¡¨",
            description="å¯ç”¨çš„çå“ï¼ˆæŒ‰å¯¶ç®±ç­‰ç´šåˆ†é¡ï¼‰ï¼š",
            color=0xFFD700
        )
        
        for box_level, total_items, total_remaining in results:
            cursor.execute("""
                SELECT prize_name, remaining 
                FROM prize_pool 
                WHERE box_level = ? AND remaining > 0 
                ORDER BY prize_name
            """, (box_level,))
            
            items = cursor.fetchall()
            
            items_text = ""
            displayed_count = 0
            hidden_count = 0
            
            for prize_name, remaining in items:
                displayed_count += 1
                if displayed_count <= 8:
                    items_text += f"â€¢ {prize_name} (å‰©é¤˜: {remaining})\n"
                else:
                    hidden_count += 1
            
            if hidden_count > 0:
                items_text += f"... é‚„æœ‰ {hidden_count} å€‹çå“\n"
            
            actual_total = sum(item[1] for item in items)
            
            embed.add_field(
                name=f"{box_level} (ç¸½å‰©é¤˜: {actual_total} / çå“ç¨®é¡: {total_items})",
                value=items_text if items_text else "ç„¡çå“",
                inline=False
            )
        
        conn.close()
        
        embed.add_field(
            name="ğŸ“Š ç©åˆ†æŠ½çæ©Ÿç‡",
            value="**50ç©åˆ†ï¼š** ç¶ ç®±70% è—ç®±25% ç´«ç®±4.5% é‡‘ç®±0.5%\n"
                  "**100ç©åˆ†ï¼š** ç¶ ç®±50% è—ç®±40% ç´«ç®±9% é‡‘ç®±1%\n"
                  "**500ç©åˆ†ï¼š** ç¶ ç®±10% è—ç®±65% ç´«ç®±20% é‡‘ç®±5%",
            inline=False
        )
        
        embed.set_footer(text="ä½¿ç”¨ /add_prize æ·»åŠ çå“åˆ°å½©æ± ")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å½©æ± å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="random_team", description="éš¨æ©Ÿåˆ†çµ„ / éš¨æ©Ÿåˆ†çµ„")
@app_commands.describe(
    team_size="æ¯çµ„äººæ•¸",
    team_count="çµ„æ•¸"
)
async def random_team_slash(
    interaction: discord.Interaction,
    team_size: Optional[int] = None,
    team_count: Optional[int] = None
):
    """éš¨æ©Ÿåˆ†çµ„"""
    await interaction.response.defer()
    
    try:
        if not interaction.guild:
            await interaction.followup.send("âŒ æ­¤æŒ‡ä»¤åªèƒ½åœ¨ä¼ºæœå™¨ä¸­ä½¿ç”¨")
            return
        
        embed = discord.Embed(
            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
            color=0x3498DB
        )
        
        if team_size:
            embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
        if team_count:
            embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
        
        embed.add_field(name="åƒåŠ äººæ•¸", value="0 äºº", inline=True)
        embed.set_footer(text="ç­‰å¾…åƒåŠ è€…...")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ®")
        await message.add_reaction("â–¶ï¸")
        
        participants = []
        
        def check(reaction, user):
            return (
                user != bot.user and
                str(reaction.emoji) in ["ğŸ®", "â–¶ï¸"] and
                reaction.message.id == message.id
            )
        
        try:
            while True:
                reaction, user = await bot.wait_for('reaction_add', timeout=300.0, check=check)
                
                if str(reaction.emoji) == "ğŸ®":
                    if user.id not in participants:
                        participants.append(user.id)
                        
                        new_embed = discord.Embed(
                            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
                            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
                            color=0x3498DB
                        )
                        
                        if team_size:
                            new_embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
                        if team_count:
                            new_embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
                        
                        new_embed.add_field(name="åƒåŠ äººæ•¸", value=f"{len(participants)} äºº", inline=True)
                        
                        if participants:
                            participants_text = ""
                            for i, pid in enumerate(participants[:10], 1):
                                participants_text += f"{i}. <@{pid}>\n"
                            if len(participants) > 10:
                                participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                            
                            new_embed.add_field(name="åƒåŠ è€…", value=participants_text, inline=False)
                        
                        new_embed.set_footer(text=f"ç­‰å¾…ä¸»æŒäººé–‹å§‹... ({len(participants)}äººåƒåŠ )")
                        
                        await message.edit(embed=new_embed)
                        
                elif str(reaction.emoji) == "â–¶ï¸" and user.id == interaction.user.id:
                    if len(participants) < 2:
                        await message.channel.send("âŒ è‡³å°‘éœ€è¦2äººæ‰èƒ½é–‹å§‹åˆ†çµ„", delete_after=5)
                        continue
                    
                    random.shuffle(participants)
                    
                    if team_size:
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    elif team_count:
                        team_size = len(participants) // team_count
                        if len(participants) % team_count != 0:
                            team_size += 1
                    else:
                        if len(participants) <= 4:
                            team_size = 2
                        elif len(participants) <= 8:
                            team_size = 4
                        else:
                            team_size = 5
                        
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    
                    teams = []
                    for i in range(team_count):
                        start_idx = i * team_size
                        end_idx = min((i + 1) * team_size, len(participants))
                        if start_idx < len(participants):
                            teams.append(participants[start_idx:end_idx])
                    
                    result_embed = discord.Embed(
                        title="ğŸ‘¥ åˆ†çµ„çµæœ",
                        description=f"ç¸½äººæ•¸ï¼š{len(participants)} äºº\n"
                                   f"åˆ†çµ„æ–¹å¼ï¼š{team_count} çµ„ï¼Œæ¯çµ„ç´„ {team_size} äºº",
                        color=0x00FF00
                    )
                    
                    for i, team in enumerate(teams, 1):
                        members_list = "\n".join([f"{j+1}. <@{member_id}>" for j, member_id in enumerate(team)])
                        result_embed.add_field(
                            name=f"ç¬¬ {i} çµ„ ({len(team)}äºº)",
                            value=members_list,
                            inline=False
                        )
                    
                    await message.channel.send(embed=result_embed)
                    await message.clear_reactions()
                    break
        
        except asyncio.TimeoutError:
            timeout_embed = discord.Embed(
                title="ğŸ‘¥ åˆ†çµ„è¶…æ™‚",
                description="åˆ†çµ„æ™‚é–“å·²é",
                color=0xFF0000
            )
            await message.edit(embed=timeout_embed)
            await message.clear_reactions()
            
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åˆ†çµ„å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# ========== ç®¡ç†å“¡æŒ‡ä»¤ ==========

@bot.tree.command(name="add_prize", description="æ·»åŠ çå“åˆ°å½©æ±  / èª¿æ•´å½©æ± ")
@app_commands.describe(
    name="çå“åç¨±",
    box_level="å¯¶ç®±ç­‰ç´š (ç¶ ç®±/è—ç®±/ç´«ç®±/é‡‘ç®±)",
    quantity="æ•¸é‡ (æ­£æ•¸æ·»åŠ , è² æ•¸æ¸›å°‘)"
)
async def add_prize_slash(
    interaction: discord.Interaction,
    name: str,
    box_level: str,
    quantity: int
):
    """æ·»åŠ /æ¸›å°‘çå“"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        valid_levels = ["ç¶ ç®±", "è—ç®±", "ç´«ç®±", "é‡‘ç®±"]
        if box_level not in valid_levels:
            await interaction.followup.send(f"âŒ ç„¡æ•ˆçš„å¯¶ç®±ç­‰ç´šï¼è«‹é¸æ“‡ï¼š{', '.join(valid_levels)}")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='prize_pool'")
        if not cursor.fetchone():
            error_embed = discord.Embed(
                title="âŒ å½©æ± è¡¨æ ¼ä¸å­˜åœ¨",
                description="è«‹é‡æ–°å•Ÿå‹•æ©Ÿå™¨äººä»¥åˆå§‹åŒ–è³‡æ–™åº«",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
            conn.close()
            return
        
        if quantity > 0:
            cursor.execute('''
                INSERT INTO prize_pool (prize_name, box_level, quantity, remaining, added_by)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(prize_name, box_level) 
                DO UPDATE SET 
                    quantity = quantity + excluded.quantity,
                    remaining = remaining + excluded.quantity
            ''', (name, box_level, quantity, quantity, interaction.user.id))
            
            action = "æ·»åŠ "
        elif quantity < 0:
            cursor.execute('''
                UPDATE prize_pool 
                SET quantity = quantity + ?,
                    remaining = CASE 
                                    WHEN remaining + ? > 0 THEN remaining + ?
                                    ELSE 0
                                END
                WHERE prize_name = ? AND box_level = ?
            ''', (quantity, quantity, quantity, name, box_level))
            
            if cursor.rowcount == 0:
                await interaction.followup.send(f"âŒ æ‰¾ä¸åˆ°çå“ '{name}' åœ¨ {box_level} ä¸­")
                conn.close()
                return
            
            action = "æ¸›å°‘"
        else:
            await interaction.followup.send("âŒ æ•¸é‡ä¸èƒ½ç‚º 0")
            conn.close()
            return
        
        cursor.execute("SELECT quantity, remaining FROM prize_pool WHERE prize_name = ? AND box_level = ?", 
                      (name, box_level))
        result = cursor.fetchone()
        
        if result:
            total_qty, remaining_qty = result
            
            embed = discord.Embed(
                title=f"âœ… çå“{action}æˆåŠŸ",
                color=0x2ECC71 if quantity > 0 else 0xE74C3C
            )
            
            embed.add_field(name="çå“åç¨±", value=name, inline=True)
            embed.add_field(name="å¯¶ç®±ç­‰ç´š", value=box_level, inline=True)
            embed.add_field(name=f"{action}æ•¸é‡", value=f"{abs(quantity)} å€‹", inline=True)
            embed.add_field(name="ç¸½æ•¸é‡", value=f"{total_qty} å€‹", inline=True)
            embed.add_field(name="å‰©é¤˜æ•¸é‡", value=f"{remaining_qty} å€‹", inline=True)
            embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
            
            await interaction.followup.send(embed=embed)
        else:
            await interaction.followup.send(f"âŒ æ“ä½œå¤±æ•—")
        
        conn.commit()
        conn.close()
        
    except sqlite3.OperationalError as e:
        if "no such column" in str(e) or "no such table" in str(e):
            error_embed = discord.Embed(
                title="âŒ è³‡æ–™åº«çµæ§‹éŒ¯èª¤",
                description="è«‹åˆªé™¤ bot_data.db æª”æ¡ˆå¾Œé‡æ–°å•Ÿå‹•æ©Ÿå™¨äºº",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
        else:
            error_embed = discord.Embed(
                title="âŒ æ“ä½œå¤±æ•—",
                description=f"è³‡æ–™åº«éŒ¯èª¤ï¼š{str(e)}",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æ“ä½œå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="add_score", description="èª¿æ•´ç”¨æˆ¶ç©åˆ† / åŠ æ¸›ç©åˆ†")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="ç©åˆ†è®ŠåŒ–ï¼ˆæ­£æ•¸ç‚ºå¢åŠ ï¼Œè² æ•¸ç‚ºæ¸›å°‘ï¼‰",
    reason="åŸå› "
)
async def add_score_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: str
):
    """èª¿æ•´ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        if amount == 0:
            await interaction.followup.send("âŒ ç©åˆ†è®ŠåŒ–ä¸èƒ½ç‚º 0")
            return
        
        old_score, old_total = get_user_score(user.id)
        update_user_score(user.id, user.name, amount, f"ç®¡ç†å“¡èª¿æ•´: {reason}")
        new_score, new_total = get_user_score(user.id)
        
        action = "å¢åŠ " if amount > 0 else "æ¸›å°‘"
        embed = discord.Embed(
            title=f"âœ… ç©åˆ†{action}æˆåŠŸ",
            color=0x2ECC71 if amount > 0 else 0xE74C3C
        )
        
        embed.add_field(name="ç”¨æˆ¶", value=user.mention, inline=True)
        embed.add_field(name=f"{action}ç©åˆ†", value=f"{abs(amount)} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå‰ç©åˆ†", value=f"{old_score} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå¾Œç©åˆ†", value=f"{new_score} åˆ†", inline=True)
        embed.add_field(name="ç¸½ç²å¾—ç©åˆ†", value=f"{new_total} åˆ†", inline=True)
        embed.add_field(name="åŸå› ", value=reason, inline=True)
        embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ èª¿æ•´å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="create_event", description="å‰µå»ºè©•æ ¸æ´»å‹• / å‰µå»ºè©•æ ¸æ´»å‹•")
@app_commands.describe(
    event_name="æ´»å‹•åç¨±",
    signup_time="ç°½åˆ°æ™‚é–“ï¼ˆåˆ†é˜ï¼‰",
    prize="æ´»å‹•çå“"
)
async def create_event_slash(
    interaction: discord.Interaction,
    event_name: str,
    signup_time: int = 5,
    prize: Optional[str] = None
):
    """å‰µå»ºè©•æ ¸æ´»å‹• - ç°¡åŒ–è©•æ ¸ç‰ˆæœ¬"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        # å»ºç«‹ç°½åˆ°è¨Šæ¯
        signup_embed = discord.Embed(
            title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
            color=discord.Color.blue()
        )
        
        if prize:
            signup_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
        
        signup_embed.add_field(
            name="ğŸ“ ç°½åˆ°éšæ®µ",
            value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°\nè¶…éæ™‚é–“ç°½åˆ°å°‡ä¸è¨ˆç®—å‡ºå¸­ç‡",
            inline=False
        )
        
        signup_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value="0 äºº", inline=True)
        signup_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
        
        # ç™¼é€ç°½åˆ°è¨Šæ¯
        signup_message = await interaction.followup.send(embed=signup_embed, wait=True)
        await signup_message.add_reaction("âœ…")
        
        # å»ºç«‹è·æ¥­é¸æ“‡è¨Šæ¯
        class_embed = discord.Embed(
            title=f"ğŸ® è·æ¥­é¸æ“‡ï¼š{event_name}",
            description="è«‹é¸æ“‡ä½ çš„è·æ¥­ï¼š\n\nğŸ›¡ï¸ å¦å…‹\nâš”ï¸ è¾“å‡º\nğŸ’š æ²»ç–—\nğŸ’› è¾…åŠ©\n\n**æ³¨æ„ï¼šè«‹å…ˆå®Œæˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼**",
            color=discord.Color.green()
        )
        class_embed.set_footer(text="ç°½åˆ°æˆåŠŸå¾Œè«‹é¸æ“‡è·æ¥­")
        
        class_msg = await interaction.channel.send(embed=class_embed)
        for emoji in ["ğŸ›¡ï¸", "âš”ï¸", "ğŸ’š", "ğŸ’›"]:
            await class_msg.add_reaction(emoji)
        
        # è¨ˆç®—ç°½åˆ°çµæŸæ™‚é–“
        signup_end_time = datetime.now() + timedelta(minutes=signup_time)
        
        # ä¿å­˜åˆ°è³‡æ–™åº«
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO evaluation_events (event_name, creator_id, signup_message_id, profession_message_id, channel_id, signup_end_time)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (event_name, interaction.user.id, signup_message.id, class_msg.id, interaction.channel.id, signup_end_time))
        conn.commit()
        conn.close()
        
        print(f"âœ… æ´»å‹•å‰µå»ºæˆåŠŸ: {event_name}, ç°½åˆ°è¨Šæ¯ID: {signup_message.id}, è·æ¥­è¨Šæ¯ID: {class_msg.id}")
        
        async def signup_countdown():
            remaining_minutes = signup_time
            
            while remaining_minutes > 0:
                await asyncio.sleep(60)
                remaining_minutes -= 1
                
                try:
                    conn = sqlite3.connect(DB_NAME)
                    cursor = conn.cursor()
                    cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                    result = cursor.fetchone()
                    
                    participants_count = 0
                    if result and result[0]:
                        participants = json.loads(result[0])
                        participants_count = len(participants)
                    
                    updated_embed = discord.Embed(
                        title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                        color=discord.Color.blue()
                    )
                    
                    if prize:
                        updated_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                    
                    updated_embed.add_field(
                        name="ğŸ“ ç°½åˆ°éšæ®µ",
                        value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°\nè¶…éæ™‚é–“ç°½åˆ°å°‡ä¸è¨ˆç®—å‡ºå¸­ç‡",
                        inline=False
                    )
                    
                    updated_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
                    updated_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{participants_count} äºº", inline=True)
                    updated_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{remaining_minutes} åˆ†é˜", inline=True)
                    updated_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
                    
                    await signup_message.edit(embed=updated_embed)
                    conn.close()
                    
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
            
            # ç°½åˆ°æ™‚é–“çµæŸ
            try:
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                result = cursor.fetchone()
                
                participants = []
                if result and result[0]:
                    participants = json.loads(result[0])
                
                # ç‚ºæ‰€æœ‰ç°½åˆ°æˆåŠŸçš„ç”¨æˆ¶çµ¦äºˆé è¨­ã€Œæ™®é€šã€è©•ç´š
                for user_id in participants:
                    # ç°½åˆ°æˆåŠŸçå‹µ40ç©åˆ†
                    update_user_score(user_id, f"ç”¨æˆ¶{user_id}", SIGNUP_SCORE, f"æ´»å‹•ç°½åˆ°: {event_name}")
                    # æ›´æ–°æ´»å‹•çµ±è¨ˆ
                    update_user_activity(user_id, event_name, attended=True)
                    # çµ¦äºˆé è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ0ç©åˆ†ï¼‰
                    update_user_rating(user_id, "æ™®é€š")
                
                # è¨˜éŒ„å·²é è¨­è©•ç´šçš„ç”¨æˆ¶
                cursor.execute("UPDATE evaluation_events SET default_rated = ?, is_active = 1 WHERE signup_message_id = ?", 
                             (json.dumps(participants), signup_message.id))
                conn.commit()
                conn.close()
                
                # æ›´æ–°ç°½åˆ°çµæŸè¨Šæ¯
                end_embed = discord.Embed(
                    title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                    description="**ç°½åˆ°å·²çµæŸï¼æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ0ç©åˆ†ï¼‰**",
                    color=discord.Color.red()
                )
                
                if prize:
                    end_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                
                end_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value="å·²çµæŸ", inline=True)
                end_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{len(participants)} äºº", inline=True)
                
                if participants:
                    participants_text = "\n".join([f"<@{user_id}>" for user_id in participants[:10]])
                    if len(participants) > 10:
                        participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                    
                    end_embed.add_field(name="ğŸ“‹ åƒèˆ‡è€…åˆ—è¡¨", value=participants_text, inline=False)
                
                end_embed.add_field(name="ğŸ“ è©•æ ¸èªªæ˜", value="ä¸»æŒäººç¾åœ¨å¯ä»¥æŒ‰EMOJIèª¿æ•´è©•ç´šï¼š\nâ­ å„ªç§€ (+40åˆ†)\nğŸ‘ è‰¯å¥½ (+10åˆ†)\nğŸ‘Œ æ™®é€š (0åˆ†ï¼Œé è¨­)\nâŒ ä¸åˆæ ¼ (-5åˆ†)", inline=False)
                end_embed.set_footer(text="åŠæœˆæœŸæ´»å‹•çµ±è¨ˆå·²æ›´æ–° | ç°½åˆ°ç©åˆ†å·²ç™¼æ”¾ | é è¨­è©•ç´šï¼šæ™®é€š")
                
                await signup_message.edit(embed=end_embed)
                await signup_message.clear_reactions()
                
                print(f"âœ… ç°½åˆ°çµæŸ: {event_name}, åƒèˆ‡è€…: {len(participants)}äºº, å·²çµ¦äºˆé è¨­æ™®é€šè©•ç´š")
                
                # å‰µå»ºè©•æ ¸éšæ®µè¨Šæ¯
                rating_embed = discord.Embed(
                    title=f"â­ è©•æ ¸éšæ®µï¼š{event_name}",
                    description="**ä¸»æŒäººå¯ä»¥æŒ‰ä¸‹æ–¹EMOJIèª¿æ•´è©•ç´š**\n\n"
                              f"æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ{RATING_SCORES['æ™®é€š']}ç©åˆ†ï¼‰\n"
                              f"è«‹ä¸»æŒäººé‡å°è¡¨ç¾å„ªç§€æˆ–éœ€è¦æ”¹é€²çš„æˆå“¡èª¿æ•´è©•ç´šï¼š\n\n"
                              f"â­ å„ªç§€ï¼š+{RATING_SCORES['å„ªç§€']}ç©åˆ†\n"
                              f"ğŸ‘ è‰¯å¥½ï¼š+{RATING_SCORES['è‰¯å¥½']}ç©åˆ†\n"
                              f"ğŸ‘Œ æ™®é€šï¼š{RATING_SCORES['æ™®é€š']}ç©åˆ†ï¼ˆé è¨­ï¼‰\n"
                              f"âŒ ä¸åˆæ ¼ï¼š{RATING_SCORES['ä¸åˆæ ¼']}ç©åˆ†\n\n"
                              f"**ä½¿ç”¨æ–¹æ³•ï¼š**\n1. é»æ“Šä¸‹æ–¹å°æ‡‰çš„EMOJI\n2. åœ¨å½ˆå‡ºçš„è¦–çª—ä¸­é¸æ“‡ç”¨æˆ¶\n3. ç³»çµ±æœƒè‡ªå‹•æ›´æ–°è©•ç´š",
                    color=discord.Color.gold()
                )
                
                if participants:
                    rating_embed.add_field(
                        name="ğŸ‘¥ åƒèˆ‡è€…åˆ—è¡¨",
                        value="\n".join([f"<@{user_id}>" for user_id in participants[:15]]) + 
                             (f"\n... é‚„æœ‰ {len(participants)-15} äºº" if len(participants) > 15 else ""),
                        inline=False
                    )
                
                rating_msg = await interaction.channel.send(embed=rating_embed)
                
                # æ·»åŠ è©•æ ¸EMOJIï¼ˆåŒ…æ‹¬çµæŸEMOJIï¼‰
                for emoji in ["â­", "ğŸ‘", "ğŸ‘Œ", "âŒ", RATING_END_EMOJI]:
                    await rating_msg.add_reaction(emoji)
                
                # æ›´æ–°è³‡æ–™åº«ä¸­çš„è©•æ ¸è¨Šæ¯ID
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("UPDATE evaluation_events SET rating_message_id = ? WHERE signup_message_id = ?", 
                             (rating_msg.id, signup_message.id))
                conn.commit()
                conn.close()
                
                print(f"âœ… è©•æ ¸éšæ®µå·²å‰µå»º: {event_name}, è©•æ ¸è¨Šæ¯ID: {rating_msg.id}")
                
            except Exception as e:
                print(f"ç°½åˆ°çµæŸè™•ç†éŒ¯èª¤: {e}")
        
        asyncio.create_task(signup_countdown())
        
        success_embed = discord.Embed(
            title="âœ… æ´»å‹•å‰µå»ºæˆåŠŸ",
            description=f"**æ´»å‹•åç¨±ï¼š** {event_name}\n**ç°½åˆ°æ™‚é–“ï¼š** {signup_time} åˆ†é˜\n**åƒèˆ‡æ–¹å¼ï¼š** æŒ‰ âœ… åæ‡‰ç°½åˆ°",
            color=discord.Color.green()
        )
        
        success_embed.add_field(name="ç°½åˆ°è¨Šæ¯", value=f"[é»æ“ŠæŸ¥çœ‹](https://discord.com/channels/{interaction.guild.id}/{interaction.channel.id}/{signup_message.id})", inline=True)
        success_embed.add_field(name="è·æ¥­é¸æ“‡", value=f"[é»æ“ŠæŸ¥çœ‹](https://discord.com/channels/{interaction.guild.id}/{interaction.channel.id}/{class_msg.id})", inline=True)
        
        await interaction.followup.send(embed=success_embed, ephemeral=True)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæ´»å‹•å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="all_profiles", description="æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™ / æ‰€æœ‰ç”¨æˆ¶æ•¸æ“š")
@app_commands.describe(
    sort_by="æ’åºæ–¹å¼",
    limit="é¡¯ç¤ºæ•¸é‡"
)
@app_commands.choices(sort_by=[
    app_commands.Choice(name="ç¾æœ‰ç©åˆ†(é«˜åˆ°ä½)", value="current_score"),
    app_commands.Choice(name="ç¸½ç²å¾—ç©åˆ†(é«˜åˆ°ä½)", value="total_score"),
    app_commands.Choice(name="åŠ å…¥æ—¥æœŸ(æ—©åˆ°æ™š)", value="join_date"),
    app_commands.Choice(name="æœ€å¾Œæ´»èº(è¿‘åˆ°é )", value="last_active"),
    app_commands.Choice(name="å‡ºå¸­ç‡(é«˜åˆ°ä½)", value="attendance_rate"),
    app_commands.Choice(name="ç¸½æ´»å‹•æ¬¡æ•¸(å¤šåˆ°å°‘)", value="total_events"),
    app_commands.Choice(name="å¯¦éš›å‡ºå¸­æ¬¡æ•¸(å¤šåˆ°å°‘)", value="attended_events"),
])
async def all_profiles_slash(
    interaction: discord.Interaction,
    sort_by: Optional[str] = "current_score",
    limit: Optional[int] = 20
):
    """æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        # æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        if limit > 50:
            limit = 50
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # ç²å–æ‰€æœ‰ç”¨æˆ¶è³‡æ–™
        cursor.execute("""
            SELECT user_id, username, current_score, total_score, join_date, 
                   last_active, activity_stats, rating_stats, profession_counts
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        # è™•ç†ç”¨æˆ¶æ•¸æ“šï¼Œè¨ˆç®—å‡ºå¸­ç‡
        processed_users = []
        current_period = get_current_half_month()
        
        for row in results:
            user_id, username, current_score, total_score, join_date, last_active, activity_str, rating_str, profession_str = row
            
            # è¨ˆç®—å‡ºå¸­ç‡
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            # æ–¹æ³•1ï¼šè¨ˆç®—ç•¶å‰åŠæœˆæœŸçš„å‡ºå¸­ç‡
            current_period_data = activity_stats.get(current_period, {})
            total_events = current_period_data.get("total", 0)
            attended_events = current_period_data.get("attended", 0)
            current_attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
            
            # æ–¹æ³•2ï¼šè¨ˆç®—ç¸½å‡ºå¸­ç‡
            total_all_events = 0
            total_all_attended = 0
            for period, data in activity_stats.items():
                total_all_events += data.get("total", 0)
                total_all_attended += data.get("attended", 0)
            overall_attendance_rate = (total_all_attended / total_all_events * 100) if total_all_events > 0 else 0.0
            
            # è©•æ ¸çµ±è¨ˆ
            rating_stats = json.loads(rating_str) if rating_str else {}
            total_ratings = sum(rating_stats.values()) if rating_stats else 0
            excellent_ratings = rating_stats.get("å„ªç§€", 0)
            good_ratings = rating_stats.get("è‰¯å¥½", 0)
            poor_ratings = rating_stats.get("ä¸åˆæ ¼", 0)
            
            # è·æ¥­çµ±è¨ˆ
            profession_counts = json.loads(profession_str) if profession_str else {}
            total_professions = sum(profession_counts.values()) if profession_counts else 0
            
            processed_users.append({
                "user_id": user_id,
                "username": username,
                "current_score": current_score,
                "total_score": total_score,
                "join_date": join_date,
                "last_active": last_active,
                "current_attendance_rate": current_attendance_rate,
                "overall_attendance_rate": overall_attendance_rate,
                "total_events": total_all_events,
                "attended_events": total_all_attended,
                "total_ratings": total_ratings,
                "excellent_ratings": excellent_ratings,
                "good_ratings": good_ratings,
                "poor_ratings": poor_ratings,
                "total_professions": total_professions,
                "activity_stats": activity_stats
            })
        
        # æ’åº
        sort_functions = {
            "current_score": lambda x: x["current_score"],
            "total_score": lambda x: x["total_score"],
            "join_date": lambda x: x["join_date"],
            "last_active": lambda x: x["last_active"],
            "attendance_rate": lambda x: x["overall_attendance_rate"],  # æ–°å¢ï¼šæŒ‰ç¸½å‡ºå¸­ç‡æ’åº
            "total_events": lambda x: x["total_events"],  # æ–°å¢ï¼šæŒ‰ç¸½æ´»å‹•æ¬¡æ•¸æ’åº
            "attended_events": lambda x: x["attended_events"],  # æ–°å¢ï¼šæŒ‰å¯¦éš›å‡ºå¸­æ¬¡æ•¸æ’åº
        }
        
        reverse_order = {
            "current_score": True,
            "total_score": True,
            "join_date": False,
            "last_active": True,
            "attendance_rate": True,  # å‡ºå¸­ç‡é«˜åˆ°ä½
            "total_events": True,     # æ´»å‹•æ¬¡æ•¸å¤šåˆ°å°‘
            "attended_events": True,  # å‡ºå¸­æ¬¡æ•¸å¤šåˆ°å°‘
        }
        
        sort_func = sort_functions.get(sort_by, lambda x: x["current_score"])
        reverse = reverse_order.get(sort_by, True)
        
        sorted_users = sorted(processed_users, key=sort_func, reverse=reverse)
        
        # é™åˆ¶é¡¯ç¤ºæ•¸é‡
        display_users = sorted_users[:limit]
        
        # è¨ˆç®—çµ±è¨ˆæ•¸æ“š
        total_users = len(display_users)
        total_current_score = sum(u["current_score"] for u in display_users)
        total_total_score = sum(u["total_score"] for u in display_users)
        avg_current_score = total_current_score / total_users if total_users > 0 else 0
        avg_total_score = total_total_score / total_users if total_users > 0 else 0
        
        # è¨ˆç®—å¹³å‡å‡ºå¸­ç‡
        avg_attendance_rate = sum(u["overall_attendance_rate"] for u in display_users) / total_users if total_users > 0 else 0
        
        # å‰µå»ºåˆ†é è¦–åœ–
        profiles_per_page = 8  # æ¸›å°‘æ¯é æ•¸é‡ï¼Œå› ç‚ºè³‡è¨Šè®Šå¤šäº†
        pages = []
        
        for i in range(0, len(display_users), profiles_per_page):
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™ç¸½è¦½",
                description=f"é¡¯ç¤º {min(i + profiles_per_page, len(display_users))}/{len(display_users)} ä½ç”¨æˆ¶",
                color=0x43B581
            )
            
            # æ·»åŠ çµ±è¨ˆä¿¡æ¯ï¼ˆæ ¹æ“šæ’åºæ–¹å¼é¡¯ç¤ºä¸åŒçµ±è¨ˆï¼‰
            if sort_by == "attendance_rate":
                embed.add_field(
                    name="ğŸ“ˆ å‡ºå¸­ç‡çµ±è¨ˆ",
                    value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                          f"**å¹³å‡å‡ºå¸­ç‡ï¼š** {avg_attendance_rate:.1f}%\n"
                          f"**æœ€é«˜å‡ºå¸­ç‡ï¼š** {max(u['overall_attendance_rate'] for u in display_users):.1f}%\n"
                          f"**æœ€ä½å‡ºå¸­ç‡ï¼š** {min(u['overall_attendance_rate'] for u in display_users):.1f}%",
                    inline=False
                )
            else:
                embed.add_field(
                    name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                    value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                          f"**ç¸½ç¾æœ‰ç©åˆ†ï¼š** {total_current_score} åˆ†\n"
                          f"**ç¸½æ­·å²ç©åˆ†ï¼š** {total_total_score} åˆ†\n"
                          f"**å¹³å‡ç¾æœ‰ç©åˆ†ï¼š** {avg_current_score:.1f} åˆ†\n"
                          f"**å¹³å‡å‡ºå¸­ç‡ï¼š** {avg_attendance_rate:.1f}%",
                    inline=False
                )
            
            # æ·»åŠ æ’åºä¿¡æ¯
            sort_names = {
                "current_score": "ç¾æœ‰ç©åˆ†ï¼ˆç”±é«˜åˆ°ä½ï¼‰",
                "total_score": "ç¸½ç²å¾—ç©åˆ†ï¼ˆç”±é«˜åˆ°ä½ï¼‰",
                "join_date": "åŠ å…¥æ—¥æœŸï¼ˆç”±æ—©åˆ°æ™šï¼‰",
                "last_active": "æœ€å¾Œæ´»èºï¼ˆç”±è¿‘åˆ°é ï¼‰",
                "attendance_rate": "ç¸½å‡ºå¸­ç‡ï¼ˆç”±é«˜åˆ°ä½ï¼‰",
                "total_events": "ç¸½æ´»å‹•æ¬¡æ•¸ï¼ˆç”±å¤šåˆ°å°‘ï¼‰",
                "attended_events": "å¯¦éš›å‡ºå¸­æ¬¡æ•¸ï¼ˆç”±å¤šåˆ°å°‘ï¼‰",
            }
            
            embed.add_field(
                name="ğŸ“Š æ’åºæ–¹å¼",
                value=sort_names.get(sort_by, "ç¾æœ‰ç©åˆ†"),
                inline=False
            )
            
            # æ·»åŠ ç”¨æˆ¶åˆ—è¡¨
            user_list = ""
            for user in display_users[i:i + profiles_per_page]:
                user_id = user["user_id"]
                username = user["username"]
                
                # ç²å– Discord ç”¨æˆ¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                discord_user = interaction.guild.get_member(user_id)
                display_name = discord_user.display_name if discord_user else username
                
                user_list += f"**{display_name}**\n"
                
                if sort_by == "attendance_rate":
                    user_list += f"  ğŸ“Š å‡ºå¸­ç‡ï¼š{user['overall_attendance_rate']:.1f}%\n"
                    user_list += f"  ğŸ® æ´»å‹•ï¼š{user['attended_events']}/{user['total_events']}æ¬¡\n"
                    user_list += f"  â­ å„ªç§€è©•ç´šï¼š{user['excellent_ratings']}æ¬¡\n"
                elif sort_by == "total_events":
                    user_list += f"  ğŸ“‹ ç¸½æ´»å‹•ï¼š{user['total_events']}æ¬¡\n"
                    user_list += f"  âœ… å‡ºå¸­ï¼š{user['attended_events']}æ¬¡\n"
                    user_list += f"  ğŸ“Š å‡ºå¸­ç‡ï¼š{user['overall_attendance_rate']:.1f}%\n"
                elif sort_by == "attended_events":
                    user_list += f"  âœ… å‡ºå¸­æ¬¡æ•¸ï¼š{user['attended_events']}æ¬¡\n"
                    user_list += f"  ğŸ“‹ ç¸½æ´»å‹•ï¼š{user['total_events']}æ¬¡\n"
                    user_list += f"  ğŸ“Š å‡ºå¸­ç‡ï¼š{user['overall_attendance_rate']:.1f}%\n"
                else:
                    user_list += f"  ğŸ”¹ ç¾æœ‰ç©åˆ†ï¼š{user['current_score']}åˆ†\n"
                    user_list += f"  ğŸ“Š ç¸½ç©åˆ†ï¼š{user['total_score']}åˆ†\n"
                    user_list += f"  ğŸ“Š å‡ºå¸­ç‡ï¼š{user['overall_attendance_rate']:.1f}%\n"
                
                # æ·»åŠ åˆ†éš”ç·š
                user_list += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ‘¥ ç”¨æˆ¶åˆ—è¡¨",
                value=user_list if user_list else "ç„¡ç”¨æˆ¶è³‡æ–™",
                inline=False
            )
            
            # æ·»åŠ ç•¶å‰åŠæœˆæœŸè³‡è¨Š
            embed.add_field(
                name="ğŸ“… ç•¶å‰åŠæœˆæœŸ",
                value=f"**{current_period}**\n"
                      f"ï¼ˆæ¯æœˆ1-15æ—¥ç‚ºä¸ŠåŠæœˆï¼Œ16-æœˆåº•ç‚ºä¸‹åŠæœˆï¼‰",
                inline=False
            )
            
            embed.set_footer(text=f"é é¢ {i//profiles_per_page + 1}/{(len(display_users)-1)//profiles_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            # å‰µå»ºåˆ†é è¦–åœ–
            current_page = 0
            
            class ProfilesPaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = ProfilesPaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–ç”¨æˆ¶è³‡æ–™å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(name="attendance_stats", description="æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ / å‡ºå¸­ç‡")
@app_commands.describe(
    period="çµ±è¨ˆæœŸé–“",
    min_events="æœ€ä½æ´»å‹•æ¬¡æ•¸ï¼ˆéæ¿¾æ´»èºç”¨æˆ¶ï¼‰"
)
@app_commands.choices(period=[
    app_commands.Choice(name="ç•¶å‰åŠæœˆæœŸ", value="current"),
    app_commands.Choice(name="æ‰€æœ‰æœŸé–“", value="all"),
    app_commands.Choice(name="æœ€è¿‘3å€‹æœˆ", value="3months"),
])
async def attendance_stats_slash(
    interaction: discord.Interaction,
    period: Optional[str] = "current",
    min_events: Optional[int] = 3
):
    """æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT user_id, username, activity_stats
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        current_period = get_current_half_month()
        now = datetime.now()
        three_months_ago = now - timedelta(days=90)
        
        attendance_data = []
        
        for user_id, username, activity_str in results:
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            if period == "current":
                # åªè¨ˆç®—ç•¶å‰åŠæœˆæœŸ
                period_data = activity_stats.get(current_period, {})
                total_events = period_data.get("total", 0)
                attended_events = period_data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": current_period
                    })
            
            elif period == "3months":
                # è¨ˆç®—æœ€è¿‘3å€‹æœˆ
                total_events = 0
                attended_events = 0
                
                for period_name, data in activity_stats.items():
                    # è§£ææœŸé–“æ—¥æœŸ
                    try:
                        period_year_month = period_name.split("-ä¸ŠåŠ")[0] if "-ä¸ŠåŠ" in period_name else period_name.split("-ä¸‹åŠ")[0]
                        period_year, period_month = map(int, period_year_month.split("-"))
                        
                        # æª¢æŸ¥æ˜¯å¦åœ¨æœ€è¿‘3å€‹æœˆå…§
                        period_date = datetime(period_year, period_month, 15)  # ä½¿ç”¨æœˆä¸­ä½œç‚ºä»£è¡¨
                        if period_date >= three_months_ago:
                            total_events += data.get("total", 0)
                            attended_events += data.get("attended", 0)
                    except:
                        continue
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": "æœ€è¿‘3å€‹æœˆ"
                    })
            
            else:  # "all"
                # è¨ˆç®—æ‰€æœ‰æœŸé–“
                total_events = 0
                attended_events = 0
                
                for data in activity_stats.values():
                    total_events += data.get("total", 0)
                    attended_events += data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": "æ‰€æœ‰æœŸé–“"
                    })
        
        # æŒ‰å‡ºå¸­ç‡æ’åºï¼ˆé«˜åˆ°ä½ï¼‰
        attendance_data.sort(key=lambda x: x["attendance_rate"], reverse=True)
        
        # çµ±è¨ˆ
        total_users = len(attendance_data)
        if total_users == 0:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description=f"æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ç”¨æˆ¶ï¼ˆæœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ï¼‰",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        avg_attendance_rate = sum(d["attendance_rate"] for d in attendance_data) / total_users
        perfect_attendance = sum(1 for d in attendance_data if d["attendance_rate"] == 100)
        good_attendance = sum(1 for d in attendance_data if d["attendance_rate"] >= 80)
        poor_attendance = sum(1 for d in attendance_data if d["attendance_rate"] < 50)
        
        # å‰µå»ºåˆ†é 
        users_per_page = 15
        pages = []
        
        for i in range(0, len(attendance_data), users_per_page):
            embed = discord.Embed(
                title=f"ğŸ“Š å‡ºå¸­ç‡æ’è¡Œæ¦œ - {attendance_data[0]['period']}",
                description=f"é¡¯ç¤º {min(i + users_per_page, len(attendance_data))}/{len(attendance_data)} ä½ç”¨æˆ¶\n"
                          f"ï¼ˆéæ¿¾æ¢ä»¶ï¼šè‡³å°‘åƒåŠ é {min_events} æ¬¡æ´»å‹•ï¼‰",
                color=0x3498DB
            )
            
            # çµ±è¨ˆè³‡è¨Š
            embed.add_field(
                name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                      f"**å¹³å‡å‡ºå¸­ç‡ï¼š** {avg_attendance_rate:.1f}%\n"
                      f"**å…¨å‹¤ç”¨æˆ¶ï¼š** {perfect_attendance} äºº (100%)\n"
                      f"**è‰¯å¥½å‡ºå¸­ï¼š** {good_attendance} äºº (â‰¥80%)\n"
                      f"**å‡ºå¸­ç‡ä½ï¼š** {poor_attendance} äºº (<50%)",
                inline=False
            )
            
            # æ’è¡Œæ¦œ
            leaderboard = ""
            for j, data in enumerate(attendance_data[i:i + users_per_page], i + 1):
                medal = "ğŸ¥‡ " if j == 1 else "ğŸ¥ˆ " if j == 2 else "ğŸ¥‰ " if j == 3 else f"{j}. "
                
                # ç²å– Discord ç”¨æˆ¶
                discord_user = interaction.guild.get_member(data["user_id"])
                display_name = discord_user.display_name if discord_user else data["username"]
                
                leaderboard += f"{medal}**{display_name}**\n"
                leaderboard += f"   å‡ºå¸­ç‡ï¼š{data['attendance_rate']:.1f}% "
                leaderboard += f"({data['attended_events']}/{data['total_events']}æ¬¡)\n"
                
                if j % 5 == 0:
                    leaderboard += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ† å‡ºå¸­ç‡æ’è¡Œæ¦œ",
                value=leaderboard,
                inline=False
            )
            
            embed.set_footer(text=f"æœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ | é é¢ {i//users_per_page + 1}/{(len(attendance_data)-1)//users_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            class AttendancePaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = AttendancePaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å‡ºå¸­ç‡å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æ·»åŠ æ¸¬è©¦æŒ‡ä»¤
@bot.tree.command(name="test", description="æ¸¬è©¦æŒ‡ä»¤æ˜¯å¦æ­£å¸¸")
async def test_slash(interaction: discord.Interaction):
    """æ¸¬è©¦æŒ‡ä»¤"""
    await interaction.response.send_message("âœ… æŒ‡ä»¤æ¸¬è©¦æ­£å¸¸ï¼")

@bot.tree.command(name="ping", description="æ¸¬è©¦æ©Ÿå™¨äººå»¶é²")
async def ping_slash(interaction: discord.Interaction):
    """æ¸¬è©¦å»¶é²"""
    await interaction.response.send_message(f"ğŸ“ Pong! å»¶é²: {round(bot.latency * 1000)}ms")

# ========== ä¸»ç¨‹å¼ ==========

def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    print(f"{'='*50}")
    print(f"ğŸš€ å•Ÿå‹• {BOT_NAME} - Railway é›²ç«¯ç‰ˆæœ¬")
    print(f"ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´")
    print(f"ğŸ”§ æ“æœ‰è€…ID: {OWNER_IDS}")
    print(f"ğŸ“ è³‡æ–™åº«ä½ç½®: {DB_NAME}")
    print(f"{'='*50}")
    
    # å¾ç’°å¢ƒè®Šæ•¸è®€å– Token
    token = os.getenv("DISCORD_TOKEN")
    
    if not token or token == "ä½ çš„_bot_token_åœ¨é€™è£¡":
        print("âŒ æ‰¾ä¸åˆ°æœ‰æ•ˆçš„ Tokenï¼")
        print("ğŸ’¡ è«‹åœ¨ Railway è¨­å®šç’°å¢ƒè®Šæ•¸ï¼š")
        print("   1. é€²å…¥ Railway å°ˆæ¡ˆ")
        print("   2. é»æ“Š Settings")
        print("   3. é»æ“Š Variables")
        print("   4. æ–°å¢ DISCORD_TOKEN = ä½ çš„_bot_token")
        sys.exit(1)
    
    print("âœ… Token è®€å–æˆåŠŸ")
    print("ğŸ”„ æ­£åœ¨é€£æ¥ Discord...")
    
    try:
        bot.run(token)
    except discord.LoginFailure:
        print("âŒ ç™»å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º")
        print("ğŸ’¡ è«‹åˆ° Discord Developer Portal é‡ç½® Token")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")

if __name__ == "__main__":
    main()


ç„¶å¾Œçµæœæ˜¯
Starting Container
==================================================
ğŸš€ å•Ÿå‹• å°é›²æ©Ÿæ¢°äºº - Railway é›²ç«¯ç‰ˆæœ¬
ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´
ğŸ”§ æ“æœ‰è€…ID: [337237662157242368]
ğŸ“ è³‡æ–™åº«ä½ç½®: bot_data.db
==================================================
âœ… Token è®€å–æˆåŠŸ
ğŸ”„ æ­£åœ¨é€£æ¥ Discord...
[2025-12-19 04:35:24] [INFO    ] discord.client: logging in using static token
ğŸ”„ æ­£åœ¨è¨­ç½®æŒ‡ä»¤æ¨¹...
âœ… æŒ‡ä»¤æ¨¹è¨­ç½®å®Œæˆ
[2025-12-19 04:35:25] [INFO    ] discord.gateway: Shard ID None has connected to Gateway (Session ID: f65e099350ebf555f06cac72a6412b33).
============================================================
ğŸ¤– å°é›²æ©Ÿæ¢°äºº å·²ä¸Šç·š
ğŸ“Š ä¼ºæœå™¨æ•¸é‡: 2
============================================================
âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ
âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ
ğŸ”„ æ­£åœ¨å¼·åˆ¶åŒæ­¥æŒ‡ä»¤...
âœ… å·²åŒæ­¥æŒ‡ä»¤åˆ°ä¼ºæœå™¨: Dragon Gor
âœ… å·²åŒæ­¥æŒ‡ä»¤åˆ°ä¼ºæœå™¨: sapling-MIU00
âœ… å·²åŒæ­¥ 0 å€‹æŒ‡ä»¤
ğŸ“‹ å¯ç”¨æŒ‡ä»¤:
ğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼
çœ‹èµ·ä¾†æ‚¨çš„æ©Ÿå™¨äººå·²ç¶“æˆåŠŸå•Ÿå‹•ä¸¦é€£æ¥åˆ° Discordï¼Œä½†æŒ‡ä»¤åŒæ­¥æœ‰å•é¡Œï¼ˆé¡¯ç¤ºã€Œå·²åŒæ­¥ 0 å€‹æŒ‡ä»¤ã€ï¼‰ã€‚é€™é€šå¸¸æ˜¯å› ç‚ºéœ€è¦ç­‰å¾…ä¸€å°æ®µæ™‚é–“è®“ Discord çš„æŒ‡ä»¤ç³»çµ±å®Œå…¨è¼‰å…¥ã€‚

ä¸éå¾æ—¥èªŒä¸­å¯ä»¥çœ‹åˆ°ï¼š

âœ… æ©Ÿå™¨äººå·²æˆåŠŸä¸Šç·š

âœ… å·²é€£æ¥åˆ° 2 å€‹ä¼ºæœå™¨

âŒ æŒ‡ä»¤åŒæ­¥é¡¯ç¤º 0 å€‹æŒ‡ä»¤

è®“æˆ‘æä¾›æ‚¨ä¸€å€‹å®Œæ•´çš„è§£æ±ºæ–¹æ¡ˆï¼ŒåŒ…æ‹¬ä¿®å¾©æŒ‡ä»¤åŒæ­¥å•é¡Œï¼š

æ–¹æ¡ˆä¸€ï¼šç«‹å³ä¿®å¾©ï¼ˆæ¨è–¦ï¼‰
åœ¨æ‚¨çš„ç¨‹å¼ç¢¼æœ€å¾Œéƒ¨åˆ†ï¼Œä¿®æ”¹ main() å‡½æ•¸ï¼ŒåŠ å…¥æŒ‡ä»¤åŒæ­¥å»¶é²ï¼š

python
# ========== ä¸»ç¨‹å¼ ==========

async def setup_command():
    """è¨­å®šæŒ‡ä»¤çš„å”ç¨‹"""
    await bot.wait_until_ready()
    
    # ç­‰å¾…ä¸€æ®µæ™‚é–“ç¢ºä¿æ©Ÿå™¨äººå®Œå…¨ä¸Šç·š
    await asyncio.sleep(5)
    
    print("ğŸ”„ æ­£åœ¨å¼·åˆ¶åŒæ­¥æŒ‡ä»¤...")
    
    try:
        # æ¸…é™¤æ‰€æœ‰ç¾æœ‰æŒ‡ä»¤
        bot.tree.clear_commands(guild=None)
        
        # åŒæ­¥å…¨å±€æŒ‡ä»¤
        synced = await bot.tree.sync()
        
        print(f"âœ… å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        
        # é¡¯ç¤ºå¯ç”¨æŒ‡ä»¤
        print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
        for cmd in synced:
            print(f"  â€¢ /{cmd.name} - {cmd.description}")
            
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")

def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    print(f"{'='*50}")
    print(f"ğŸš€ å•Ÿå‹• {BOT_NAME} - Railway é›²ç«¯ç‰ˆæœ¬")
    print(f"ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´")
    print(f"ğŸ”§ æ“æœ‰è€…ID: {OWNER_IDS}")
    print(f"ğŸ“ è³‡æ–™åº«ä½ç½®: {DB_NAME}")
    print(f"{'='*50}")
    
    # å¾ç’°å¢ƒè®Šæ•¸è®€å– Token
    token = os.getenv("DISCORD_TOKEN")
    
    if not token or token == "ä½ çš„_bot_token_åœ¨é€™è£¡":
        print("âŒ æ‰¾ä¸åˆ°æœ‰æ•ˆçš„ Tokenï¼")
        print("ğŸ’¡ è«‹åœ¨ Railway è¨­å®šç’°å¢ƒè®Šæ•¸ï¼š")
        print("   1. é€²å…¥ Railway å°ˆæ¡ˆ")
        print("   2. é»æ“Š Settings")
        print("   3. é»æ“Š Variables")
        print("   4. æ–°å¢ DISCORD_TOKEN = ä½ çš„_bot_token")
        sys.exit(1)
    
    print("âœ… Token è®€å–æˆåŠŸ")
    print("ğŸ”„ æ­£åœ¨é€£æ¥ Discord...")
    
    try:
        # å‰µå»ºä¸€å€‹æ–°çš„äº‹ä»¶å¾ªç’°ä¾†é‹è¡ŒåŒæ­¥ä»»å‹™
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # å•Ÿå‹•æŒ‡ä»¤åŒæ­¥ä»»å‹™
        loop.create_task(setup_command())
        
        # é‹è¡Œæ©Ÿå™¨äºº
        bot.run(token)
        
    except discord.LoginFailure:
        print("âŒ ç™»å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º")
        print("ğŸ’¡ è«‹åˆ° Discord Developer Portal é‡ç½® Token")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")

if __name__ == "__main__":
    main()
æ–¹æ¡ˆäºŒï¼šå®Œå…¨é‡å¯«çš„å¿«é€Ÿä¿®å¾©ç‰ˆæœ¬
å¦‚æœæ‚¨æƒ³è¦ä¸€å€‹æ›´ç°¡å–®ã€æ›´ç©©å®šçš„ç‰ˆæœ¬ï¼Œé€™è£¡æ˜¯ä¸€å€‹ç²¾ç°¡ç‰ˆï¼š

python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å°é›²ALBIONæ©Ÿæ¢°äºº - ç°¡åŒ–è©•æ ¸ç‰ˆæœ¬ (Railway å„ªåŒ–ç‰ˆ)
"""

import os
import discord
from discord.ext import commands
from discord import app_commands
import sys
import asyncio
import json
import random
from datetime import datetime, timedelta
from typing import Optional
import sqlite3
import time

# ========== è¨­å®š ==========
BOT_NAME = "å°é›²æ©Ÿæ¢°äºº"
OWNER_IDS = [337237662157242368]  # ä½ çš„ Discord ID

# Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True

bot = commands.Bot(
    command_prefix='!',
    intents=intents,
    help_command=None,
    case_insensitive=True
)

# ========== äº‹ä»¶è™•ç† ==========

@bot.event
async def on_ready():
    """æ©Ÿå™¨äººä¸Šç·š"""
    print(f"\n{'='*60}")
    print(f"ğŸ¤– {BOT_NAME} å·²ä¸Šç·š")
    print(f"ğŸ“Š ä¼ºæœå™¨æ•¸é‡: {len(bot.guilds)}")
    print(f"{'='*60}")
    
    # ç­‰å¾…ä¸€æ®µæ™‚é–“ç¢ºä¿æ©Ÿå™¨äººå®Œå…¨æº–å‚™å¥½
    await asyncio.sleep(2)
    
    try:
        print("ğŸ”„ æ­£åœ¨åŒæ­¥æ–œç·šæŒ‡ä»¤...")
        
        # åŒæ­¥å…¨å±€æŒ‡ä»¤
        synced = await bot.tree.sync()
        
        print(f"âœ… å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        
        # é¡¯ç¤ºå¯ç”¨æŒ‡ä»¤
        if synced:
            print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
            for cmd in synced:
                print(f"  â€¢ /{cmd.name} - {cmd.description}")
        else:
            print("âš ï¸ æ²’æœ‰åŒæ­¥åˆ°ä»»ä½•æŒ‡ä»¤ï¼Œå¯èƒ½éœ€è¦ç­‰å¾…ä¸€æ®µæ™‚é–“")
            
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")
    
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="/help æŸ¥çœ‹æŒ‡ä»¤"
        )
    )
    
    print(f"\nğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼")

# ========== åŸºæœ¬æŒ‡ä»¤ ==========

@bot.tree.command(name="ping", description="æ¸¬è©¦æ©Ÿå™¨äººå»¶é²")
async def ping(interaction: discord.Interaction):
    """æ¸¬è©¦å»¶é²"""
    latency = round(bot.latency * 1000)
    
    embed = discord.Embed(
        title="ğŸ“ Pong!",
        description=f"æ©Ÿå™¨äººå»¶é²: **{latency}ms**",
        color=discord.Color.green()
    )
    
    if latency < 100:
        embed.add_field(name="ç‹€æ…‹", value="âœ… é€£æ¥è‰¯å¥½", inline=False)
    elif latency < 300:
        embed.add_field(name="ç‹€æ…‹", value="âš ï¸ é€£æ¥æ­£å¸¸", inline=False)
    else:
        embed.add_field(name="ç‹€æ…‹", value="ğŸ”´ å»¶é²è¼ƒé«˜", inline=False)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯")
async def help_command(interaction: discord.Interaction):
    """é¡¯ç¤ºå¹«åŠ©"""
    embed = discord.Embed(
        title="ğŸ¤– å°é›²æ©Ÿæ¢°äºº - å¹«åŠ©ä¸­å¿ƒ",
        description="ä»¥ä¸‹æ˜¯å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ï¼š",
        color=discord.Color.blue()
    )
    
    embed.add_field(
        name="ğŸ”§ åŸºæœ¬æŒ‡ä»¤",
        value=(
            "`/ping` - æ¸¬è©¦æ©Ÿå™¨äººå»¶é²\n"
            "`/help` - é¡¯ç¤ºæ­¤å¹«åŠ©è¨Šæ¯\n"
            "`/sync` - åŒæ­¥æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ‘¤ ç”¨æˆ¶æŒ‡ä»¤",
        value=(
            "`/profile` - æŸ¥çœ‹æˆ‘çš„æ•¸æ“š\n"
            "`/giveaway` - å‰µå»ºæŠ½ç\n"
            "`/random_team` - éš¨æ©Ÿåˆ†çµ„"
        ),
        inline=False
    )
    
    embed.set_footer(text="ä½¿ç”¨ / é–‹é ­è¼¸å…¥æŒ‡ä»¤")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="sync", description="åŒæ­¥æ–œæ§“æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰")
async def sync(interaction: discord.Interaction):
    """åŒæ­¥æŒ‡ä»¤"""
    if interaction.user.id not in OWNER_IDS:
        await interaction.response.send_message("âŒ åªæœ‰æ©Ÿå™¨äººæ“æœ‰è€…å¯ä»¥ä½¿ç”¨æ­¤æŒ‡ä»¤", ephemeral=True)
        return
    
    await interaction.response.defer(ephemeral=True)
    
    try:
        print("ğŸ”„ æ‰‹å‹•åŒæ­¥æŒ‡ä»¤ä¸­...")
        
        # åŒæ­¥å…¨å±€æŒ‡ä»¤
        synced = await bot.tree.sync()
        
        embed = discord.Embed(
            title="ğŸ”„ æŒ‡ä»¤åŒæ­¥å®Œæˆ",
            description=f"å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤",
            color=discord.Color.green()
        )
        
        if synced:
            command_list = "\n".join([f"â€¢ `/{cmd.name}`" for cmd in synced[:10]])
            if len(synced) > 10:
                command_list += f"\n... é‚„æœ‰ {len(synced) - 10} å€‹æŒ‡ä»¤"
            embed.add_field(name="å·²åŒæ­¥æŒ‡ä»¤", value=command_list, inline=False)
        
        await interaction.followup.send(embed=embed, ephemeral=True)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åŒæ­¥å¤±æ•—",
            description=f"éŒ¯èª¤è¨Šæ¯: {str(e)}",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=error_embed, ephemeral=True)

@bot.tree.command(name="profile", description="æŸ¥çœ‹æˆ‘çš„æ•¸æ“š")
async def profile(interaction: discord.Interaction):
    """æŸ¥çœ‹ç”¨æˆ¶è³‡æ–™"""
    embed = discord.Embed(
        title=f"ğŸ“Š {interaction.user.display_name} çš„è³‡æ–™",
        description="é€™æ˜¯æ‚¨çš„å€‹äººè³‡æ–™é é¢",
        color=discord.Color.blue()
    )
    
    embed.add_field(name="ç”¨æˆ¶åç¨±", value=interaction.user.name, inline=True)
    embed.add_field(name="é¡¯ç¤ºåç¨±", value=interaction.user.display_name, inline=True)
    embed.add_field(name="Discord ID", value=f"`{interaction.user.id}`", inline=True)
    embed.add_field(name="åŠ å…¥ä¼ºæœå™¨", value=interaction.user.joined_at.strftime('%Y-%m-%d'), inline=True)
    embed.add_field(name="å¸³è™Ÿå‰µå»º", value=interaction.user.created_at.strftime('%Y-%m-%d'), inline=True)
    
    if interaction.user.avatar:
        embed.set_thumbnail(url=interaction.user.avatar.url)
    
    embed.set_footer(text=f"è«‹æ±‚æ™‚é–“: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    await interaction.response.send_message(embed=embed)

# ========== æŠ½çæŒ‡ä»¤ ==========

@bot.tree.command(name="giveaway", description="å‰µå»ºæŠ½çæ´»å‹•")
@app_commands.describe(
    prize="çå“å…§å®¹",
    duration="æŠ½çæŒçºŒæ™‚é–“ï¼ˆä¾‹å¦‚ï¼š1h, 30m, 1dï¼‰",
    winners="ç²çäººæ•¸"
)
async def giveaway(
    interaction: discord.Interaction,
    prize: str,
    duration: str = "1h",
    winners: int = 1
):
    """å‰µå»ºæŠ½ç"""
    await interaction.response.defer()
    
    # è§£ææ™‚é–“
    seconds = 3600  # é è¨­1å°æ™‚
    duration_lower = duration.lower().strip()
    
    if duration_lower.endswith('s'):
        seconds = int(duration_lower[:-1])
    elif duration_lower.endswith('m'):
        seconds = int(duration_lower[:-1]) * 60
    elif duration_lower.endswith('h'):
        seconds = int(duration_lower[:-1]) * 3600
    elif duration_lower.endswith('d'):
        seconds = int(duration_lower[:-1]) * 86400
    elif duration_lower.isdigit():
        seconds = int(duration_lower)
    
    if seconds < 10:
        await interaction.followup.send("âŒ æŠ½çæ™‚é–“å¿…é ˆè‡³å°‘10ç§’ï¼")
        return
    
    if seconds > 86400 * 7:
        await interaction.followup.send("âŒ æŠ½çæ™‚é–“ä¸èƒ½è¶…é7å¤©ï¼")
        return
    
    # æ ¼å¼åŒ–æ™‚é–“é¡¯ç¤º
    if seconds < 60:
        time_display = f"{seconds}ç§’"
    elif seconds < 3600:
        time_display = f"{seconds//60}åˆ†{seconds%60}ç§’"
    elif seconds < 86400:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        time_display = f"{hours}å°æ™‚{minutes}åˆ†"
    else:
        days = seconds // 86400
        hours = (seconds % 86400) // 3600
        time_display = f"{days}å¤©{hours}å°æ™‚"
    
    embed = discord.Embed(
        title="ğŸ‰ æŠ½çæ´»å‹• ğŸ‰",
        description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
        color=discord.Color.gold()
    )
    
    embed.add_field(name="ğŸ çå“", value=prize, inline=True)
    embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
    embed.add_field(name="â° æŒçºŒæ™‚é–“", value=time_display, inline=True)
    embed.add_field(name="ğŸ« åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
    embed.add_field(name="ğŸ‘¤ ä¸»è¾¦äºº", value=interaction.user.mention, inline=True)
    embed.add_field(name="ğŸ“… é–‹å§‹æ™‚é–“", value=datetime.now().strftime("%Y-%m-%d %H:%M"), inline=True)
    
    message = await interaction.followup.send(embed=embed)
    
    await message.add_reaction("ğŸ«")
    await message.add_reaction("â¹ï¸")
    
    print(f"âœ… æŠ½çå·²å‰µå»º: {prize}")

# ========== éš¨æ©Ÿåˆ†çµ„æŒ‡ä»¤ ==========

@bot.tree.command(name="random_team", description="éš¨æ©Ÿåˆ†çµ„")
@app_commands.describe(
    members="è¦åˆ†çµ„çš„æˆå“¡ï¼ˆç”¨ç©ºæ ¼æˆ–æ›è¡Œåˆ†éš”ï¼‰",
    team_size="æ¯çµ„äººæ•¸"
)
async def random_team(
    interaction: discord.Interaction,
    members: str,
    team_size: int = 4
):
    """éš¨æ©Ÿåˆ†çµ„"""
    await interaction.response.defer()
    
    # è§£ææˆå“¡åˆ—è¡¨
    member_list = [m.strip() for m in members.split() if m.strip()]
    
    if len(member_list) < 2:
        await interaction.followup.send("âŒ è‡³å°‘éœ€è¦2åæˆå“¡æ‰èƒ½åˆ†çµ„")
        return
    
    if team_size < 1:
        await interaction.followup.send("âŒ æ¯çµ„äººæ•¸å¿…é ˆè‡³å°‘1äºº")
        return
    
    if team_size > len(member_list):
        team_size = len(member_list)
    
    # éš¨æ©Ÿæ‰“äº‚
    random.shuffle(member_list)
    
    # åˆ†çµ„
    teams = []
    for i in range(0, len(member_list), team_size):
        team = member_list[i:i + team_size]
        teams.append(team)
    
    # å»ºç«‹çµæœ
    embed = discord.Embed(
        title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„çµæœ",
        description=f"ç¸½äººæ•¸: {len(member_list)} äºº | æ¯çµ„ç´„ {team_size} äºº",
        color=discord.Color.green()
    )
    
    for i, team in enumerate(teams, 1):
        team_members = "\n".join([f"â€¢ {member}" for member in team])
        embed.add_field(
            name=f"ç¬¬ {i} çµ„ ({len(team)}äºº)",
            value=team_members,
            inline=False
        )
    
    embed.set_footer(text=f"ç”± {interaction.user.display_name} å»ºç«‹")
    
    await interaction.followup.send(embed=embed)

# ========== ä¸»ç¨‹å¼ ==========

def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    print(f"{'='*50}")
    print(f"ğŸš€ å•Ÿå‹• {BOT_NAME} - å¿«é€Ÿä¿®å¾©ç‰ˆæœ¬")
    print(f"ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´")
    print(f"ğŸ”§ æ“æœ‰è€…ID: {OWNER_IDS}")
    print(f"{'='*50}")
    
    # å¾ç’°å¢ƒè®Šæ•¸è®€å– Token
    token = os.getenv("DISCORD_TOKEN")
    
    if not token or token == "ä½ çš„_bot_token_åœ¨é€™è£¡":
        print("âŒ æ‰¾ä¸åˆ°æœ‰æ•ˆçš„ Tokenï¼")
        print("ğŸ’¡ è«‹åœ¨ Railway è¨­å®šç’°å¢ƒè®Šæ•¸ï¼š")
        print("   1. é€²å…¥ Railway å°ˆæ¡ˆ")
        print("   2. é»æ“Š Settings")
        print("   3. é»æ“Š Variables")
        print("   4. æ–°å¢ DISCORD_TOKEN = ä½ çš„_bot_token")
        sys.exit(1)
    
    print("âœ… Token è®€å–æˆåŠŸ")
    print("ğŸ”„ æ­£åœ¨é€£æ¥ Discord...")
    
    try:
        bot.run(token)
    except discord.LoginFailure:
        print("âŒ ç™»å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º")
        print("ğŸ’¡ è«‹åˆ° Discord Developer Portal é‡ç½® Token")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")

if __name__ == "__main__":
    main()
æ–¹æ¡ˆä¸‰ï¼šç°¡å–®çš„æŒ‡ä»¤åŒæ­¥ä¿®å¾©
å¦‚æœæ‚¨åªæƒ³å¿«é€Ÿä¿®å¾©ï¼Œåªéœ€åœ¨ on_ready() äº‹ä»¶ä¸­æ·»åŠ å»¶é²ï¼š

python
@bot.event
async def on_ready():
    """æ©Ÿå™¨äººä¸Šç·š"""
    print(f"\n{'='*60}")
    print(f"ğŸ¤– {BOT_NAME} å·²ä¸Šç·š")
    print(f"ğŸ“Š ä¼ºæœå™¨æ•¸é‡: {len(bot.guilds)}")
    print(f"{'='*60}")
    
    # åˆå§‹åŒ–è³‡æ–™åº«
    init_db()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")
    
    # ç­‰å¾…3ç§’è®“æ©Ÿå™¨äººå®Œå…¨æº–å‚™å¥½
    await asyncio.sleep(3)
    
    try:
        print("\nğŸ”„ æ­£åœ¨å¼·åˆ¶åŒæ­¥æŒ‡ä»¤...")
        
        # åŒæ­¥å…¨å±€æŒ‡ä»¤
        synced = await bot.tree.sync()
        
        print(f"âœ… å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        
        # é¡¯ç¤ºå¯ç”¨æŒ‡ä»¤
        print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
        for cmd in synced:
            print(f"  â€¢ /{cmd.name} - {cmd.description}")
            
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")
        # å¦‚æœåŒæ­¥å¤±æ•—ï¼Œå†è©¦ä¸€æ¬¡
        try:
            await asyncio.sleep(2)
            synced = await bot.tree.sync()
            print(f"âœ… é‡è©¦å¾Œå·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        except Exception as e2:
            print(f"âŒ é‡è©¦ä¹Ÿå¤±æ•—: {e2}")
    
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="/help æŸ¥çœ‹æŒ‡ä»¤"
        )
    )
    
    print(f"\nğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼")
ä½¿ç”¨æ­¥é©Ÿï¼š
é¸æ“‡ä¸€å€‹æ–¹æ¡ˆï¼š

æ–¹æ¡ˆä¸€ï¼šå®Œæ•´çš„ä¿®å¾©æ–¹æ¡ˆ

æ–¹æ¡ˆäºŒï¼šç°¡å–®çš„å¿«é€Ÿä¿®å¾©ç‰ˆæœ¬ï¼ˆæ¨è–¦å…ˆè©¦é€™å€‹ï¼‰

æ–¹æ¡ˆä¸‰ï¼šæœ€å°æ”¹å‹•æ–¹æ¡ˆ

æ›´æ–° Railway ä¸Šçš„ç¨‹å¼ç¢¼ï¼š

bash
# å°‡é¸æ“‡çš„æ–¹æ¡ˆç¨‹å¼ç¢¼è¤‡è£½åˆ° main.py
# ç„¶å¾Œæ¨é€åˆ° Railway
git add .
git commit -m "ä¿®å¾©æŒ‡ä»¤åŒæ­¥å•é¡Œ"
git push
ç­‰å¾…éƒ¨ç½²å®Œæˆï¼š

Railway æœƒè‡ªå‹•é‡æ–°éƒ¨ç½²

æŸ¥çœ‹æ—¥èªŒç¢ºèªæ˜¯å¦æˆåŠŸ

æ¸¬è©¦æŒ‡ä»¤ï¼š

åœ¨ Discord è¼¸å…¥ /ping æ¸¬è©¦

è¼¸å…¥ /sync æ‰‹å‹•åŒæ­¥æŒ‡ä»¤ï¼ˆå¦‚æœæ˜¯æŒ‡ä»¤æ“æœ‰è€…ï¼‰

è¼¸å…¥ /help æŸ¥çœ‹å¯ç”¨æŒ‡ä»¤

å¦‚æœé‚„æ˜¯ä¸è¡Œï¼š
ç­‰å¾…ä¸€æ®µæ™‚é–“ï¼šDiscord æŒ‡ä»¤ç³»çµ±æœ‰æ™‚éœ€è¦å¹¾åˆ†é˜åˆ°å¹¾å°æ™‚æ‰èƒ½å®Œå…¨åŒæ­¥

é‡æ–°é‚€è«‹æ©Ÿå™¨äººï¼šä½¿ç”¨æ–°çš„é‚€è«‹é€£çµï¼Œç¢ºä¿å‹¾é¸ applications.commands æ¬Šé™

æª¢æŸ¥æ¬Šé™ï¼šç¢ºä¿æ©Ÿå™¨äººåœ¨ä¼ºæœå™¨æœ‰è¶³å¤ æ¬Šé™

æ‚¨çš„æ©Ÿå™¨äººç¾åœ¨å·²ç¶“æˆåŠŸé€£æ¥åˆ° Discordï¼ŒæŒ‡ä»¤åŒæ­¥çš„å•é¡Œé€šå¸¸åªéœ€è¦ç¨ç­‰æˆ–ä½¿ç”¨ /sync æŒ‡ä»¤å³å¯è§£æ±ºï¼

æˆ‘éœ€è¦çš„æ˜¯13å€‹æŒ‡ä»¤éƒ½èƒ½ç”¨, éº»ç…©ä½ çµ¦æˆ‘ä¸€å€‹å®Œæ•´çš„COPY
æˆ‘å°‡ç‚ºæ‚¨æä¾›ä¸€å€‹å®Œæ•´å¯é‹ä½œçš„ç‰ˆæœ¬ï¼ŒåŒ…å«13å€‹æŒ‡ä»¤ä¸”ä¿®å¾©äº†åŒæ­¥å•é¡Œã€‚ä»¥ä¸‹æ˜¯å®Œæ•´ç¨‹å¼ç¢¼ï¼š

python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å°é›²ALBIONæ©Ÿæ¢°äºº - å®Œæ•´åŠŸèƒ½ç‰ˆæœ¬
13å€‹æŒ‡ä»¤å…¨éƒ¨å¯ç”¨
"""

import os
import discord
from discord.ext import commands
from discord import app_commands
import sys
import asyncio
import json
import random
from datetime import datetime, timedelta
from typing import Optional, List
import sqlite3
import time

# ========== è¨­å®š ==========
BOT_NAME = "å°é›²æ©Ÿæ¢°äºº"
OWNER_IDS = [337237662157242368]  # ä½ çš„ Discord ID

# è·æ¥­å°æ‡‰çš„EMOJI
PROFESSION_EMOJIS = {
    "ğŸ›¡ï¸": "å¦å…‹",
    "âš”ï¸": "è¾“å‡º", 
    "ğŸ’š": "æ²»ç–—",
    "ğŸ’›": "è¾…åŠ©"
}

# è©•æ ¸è©•åˆ†é¸é …
RATING_EMOJIS = {
    "â­": "å„ªç§€",
    "ğŸ‘": "è‰¯å¥½", 
    "ğŸ‘Œ": "æ™®é€š",  # é è¨­è©•ç´š
    "âŒ": "ä¸åˆæ ¼"
}

# è©•æ ¸çµæŸEMOJI
RATING_END_EMOJI = "ğŸ"

# ========== ç©åˆ†è¨­å®š ==========
SIGNUP_SCORE = 40  # ç°½åˆ°ç©åˆ†
PROFESSION_BONUS = {
    "å¦å…‹": 0,
    "è¾“å‡º": 0,
    "æ²»ç–—": 20,  # è£œå¸«+20ç©åˆ†
    "è¾…åŠ©": 0
}
RATING_SCORES = {
    "å„ªç§€": 40,    # å„ªç§€+40ç©åˆ†
    "è‰¯å¥½": 10,    # è‰¯å¥½+10ç©åˆ†
    "æ™®é€š": 0,     # æ™®é€š+0ç©åˆ†
    "ä¸åˆæ ¼": -5   # ä¸åˆæ ¼-5ç©åˆ†
}

# Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True
intents.presences = True

bot = commands.Bot(
    command_prefix='!',
    intents=intents,
    help_command=None,
    case_insensitive=True
)

# ========== è³‡æ–™åº«è¨­å®š ==========
DB_NAME = "bot_data.db"

def init_db():
    """åˆå§‹åŒ–è³‡æ–™åº«"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # ç”¨æˆ¶è³‡æ–™è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        total_score INTEGER DEFAULT 0,
        current_score INTEGER DEFAULT 0,
        join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        profession_counts TEXT DEFAULT '{}',
        activity_stats TEXT DEFAULT '{}',
        rating_stats TEXT DEFAULT '{}'
    )
    ''')
    
    # å½©æ± è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS prize_pool (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        prize_name TEXT NOT NULL,
        box_level TEXT NOT NULL,
        quantity INTEGER DEFAULT 1,
        remaining INTEGER DEFAULT 1,
        added_by INTEGER,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(prize_name, box_level)
    )
    ''')
    
    # æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS giveaways (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        prize TEXT,
        winner_count INTEGER DEFAULT 1,
        participants TEXT DEFAULT '[]',
        winners TEXT DEFAULT '[]',
        end_time TIMESTAMP,
        message_id INTEGER,
        channel_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_draws (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        score_cost INTEGER,
        box_level TEXT,
        participants TEXT DEFAULT '[]',
        winner_prize TEXT,
        winner_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†è½‰ç§»ç´€éŒ„
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_transfers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_user_id INTEGER,
        to_user_id INTEGER,
        amount INTEGER,
        reason TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # è©•æ ¸æ´»å‹•
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS evaluation_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        event_name TEXT,
        creator_id INTEGER,
        signup_message_id INTEGER,
        profession_message_id INTEGER,
        rating_message_id INTEGER,
        channel_id INTEGER,
        participants TEXT DEFAULT '[]',
        default_rated TEXT DEFAULT '[]',
        professions TEXT DEFAULT '{}',
        ratings TEXT DEFAULT '{}',
        is_active BOOLEAN DEFAULT 1,
        start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        signup_end_time TIMESTAMP
    )
    ''')
    
    # æ·»åŠ ç¤ºä¾‹çå“
    sample_prizes = [
        ("æ™®é€šæ­¦å™¨", "ç¶ ç®±", 20),
        ("æ™®é€šè£å‚™", "ç¶ ç®±", 15),
        ("åˆç´šè—¥æ°´", "ç¶ ç®±", 30),
        ("ä¸­ç´šæ­¦å™¨", "è—ç®±", 10),
        ("ä¸­ç´šè£å‚™", "è—ç®±", 8),
        ("ä¸­ç´šè—¥æ°´", "è—ç®±", 15),
        ("é«˜ç´šæ­¦å™¨", "ç´«ç®±", 5),
        ("é«˜ç´šè£å‚™", "ç´«ç®±", 4),
        ("é«˜ç´šè—¥æ°´", "ç´«ç®±", 6),
        ("å‚³å¥‡æ­¦å™¨", "é‡‘ç®±", 2),
        ("å‚³å¥‡è£å‚™", "é‡‘ç®±", 1),
        ("å‚³èªªè—¥æ°´", "é‡‘ç®±", 3),
    ]
    
    for prize_name, box_level, quantity in sample_prizes:
        cursor.execute('''
            INSERT OR IGNORE INTO prize_pool (prize_name, box_level, quantity, remaining)
            VALUES (?, ?, ?, ?)
        ''', (prize_name, box_level, quantity, quantity))
    
    conn.commit()
    conn.close()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")

# ========== é€šç”¨å‡½æ•¸ ==========

def get_user_score(user_id):
    """å–å¾—ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        return result[0], result[1]
    return 0, 0

def update_user_score(user_id, username, amount, reason=""):
    """æ›´æ–°ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if not cursor.fetchone():
        cursor.execute(
            "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
            (user_id, username, max(amount, 0), max(amount, 0))
        )
    else:
        cursor.execute("UPDATE users SET current_score = current_score + ? WHERE user_id = ?", (amount, user_id))
        if amount > 0:
            cursor.execute("UPDATE users SET total_score = total_score + ? WHERE user_id = ?", (amount, user_id))
        cursor.execute("UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE user_id = ?", (user_id,))
    
    if amount < 0 or reason:
        cursor.execute(
            "INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason) VALUES (?, ?, ?, ?)",
            (user_id if amount < 0 else None, 
             user_id if amount > 0 else None, 
             abs(amount), 
             reason if reason else ("ç³»çµ±æ‰£é™¤" if amount < 0 else "ç³»çµ±å¢åŠ "))
        )
    
    conn.commit()
    conn.close()

def get_user_profile(user_id):
    """ç²å–ç”¨æˆ¶å®Œæ•´è³‡æ–™"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score, join_date, profession_counts, activity_stats, rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        current_score, total_score, join_date, profession_str, activity_str, rating_str = result
        
        try:
            join_date_str = datetime.strptime(join_date.split('.')[0], '%Y-%m-%d %H:%M:%S').strftime('%Y-%m-%d')
        except:
            join_date_str = join_date
        
        profession_counts = json.loads(profession_str) if profession_str else {}
        activity_stats = json.loads(activity_str) if activity_str else {}
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        return {
            'user_id': user_id,
            'current_score': current_score,
            'total_score': total_score,
            'join_date': join_date_str,
            'profession_counts': profession_counts,
            'activity_stats': activity_stats,
            'rating_stats': rating_stats
        }
    
    return None

def update_user_profession(user_id, profession):
    """æ›´æ–°ç”¨æˆ¶è·æ¥­çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT profession_counts FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        profession_str = result[0]
        profession_counts = json.loads(profession_str) if profession_str else {}
        
        if profession in profession_counts:
            profession_counts[profession] += 1
        else:
            profession_counts[profession] = 1
        
        bonus_score = PROFESSION_BONUS.get(profession, 0)
        if bonus_score > 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("UPDATE users SET current_score = current_score + ?, total_score = total_score + ? WHERE user_id = ?", 
                         (bonus_score, bonus_score, user_id))
        
        cursor.execute("UPDATE users SET profession_counts = ? WHERE user_id = ?", 
                      (json.dumps(profession_counts), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_activity(user_id, event_name, attended=True):
    """æ›´æ–°ç”¨æˆ¶æ´»å‹•çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT activity_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        activity_str = result[0]
        activity_stats = json.loads(activity_str) if activity_str else {}
        
        # ç²å–ç•¶å‰åŠæœˆæœŸ
        now = datetime.now()
        year_month = now.strftime("%Y-%m")
        day = now.day
        current_period = f"{year_month}-ä¸ŠåŠ" if day <= 15 else f"{year_month}-ä¸‹åŠ"
        
        if current_period not in activity_stats:
            activity_stats[current_period] = {"total": 0, "attended": 0}
        
        activity_stats[current_period]["total"] += 1
        if attended:
            activity_stats[current_period]["attended"] += 1
        
        cursor.execute("UPDATE users SET activity_stats = ? WHERE user_id = ?", 
                      (json.dumps(activity_stats), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_rating(user_id, rating_type):
    """æ›´æ–°ç”¨æˆ¶è©•æ ¸çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        rating_str = result[0]
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        if rating_type in rating_stats:
            rating_stats[rating_type] += 1
        else:
            rating_stats[rating_type] = 1
        
        score = RATING_SCORES.get(rating_type, 0)
        
        if score != 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("""
                UPDATE users 
                SET current_score = current_score + ?, 
                    total_score = CASE 
                                    WHEN total_score + ? > 0 THEN total_score + ?
                                    ELSE 0
                                  END
                WHERE user_id = ?
            """, (score, score, score, user_id))
        
        cursor.execute("UPDATE users SET rating_stats = ? WHERE user_id = ?", 
                      (json.dumps(rating_stats), user_id))
        
        conn.commit()
    
    conn.close()

def get_current_half_month():
    """ç²å–ç•¶å‰åŠæœˆæœŸ"""
    now = datetime.now()
    year_month = now.strftime("%Y-%m")
    day = now.day
    
    if day <= 15:
        return f"{year_month}-ä¸ŠåŠ"
    else:
        return f"{year_month}-ä¸‹åŠ"

async def end_giveaway(message_id: int, manual: bool = False):
    """çµæŸæŠ½ç"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, creator_id, prize, winner_count, participants, winners, channel_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (message_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        giveaway_id, creator_id, prize, winner_count, participants_json, winners_json, channel_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        channel = bot.get_channel(channel_id)
        
        if not channel:
            conn.close()
            return
        
        try:
            message = await channel.fetch_message(message_id)
        except:
            conn.close()
            return
        
        if participants:
            if len(participants) <= winner_count:
                winners_list = participants
            else:
                winners_list = random.sample(participants, winner_count)
            
            cursor.execute("UPDATE giveaways SET winners = ?, is_active = 0 WHERE id = ?", 
                         (json.dumps(winners_list), giveaway_id))
            conn.commit()
            
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ ğŸ‰",
                description="é–‹çå®Œæˆï¼",
                color=0x00FF00
            )
            
            new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
            new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(len(winners_list)), inline=True)
            new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
            
            winners_text = ""
            for i, winner_id in enumerate(winners_list[:5], 1):
                winners_text += f"{i}. <@{winner_id}>\n"
            
            if len(winners_list) > 5:
                winners_text += f"... é‚„æœ‰ {len(winners_list) - 5} äºº"
            
            if winners_text:
                new_embed.add_field(name="ğŸ† ç²çè€…", value=winners_text, inline=False)
            
            await message.edit(embed=new_embed)
            await message.clear_reactions()
            
            for winner_id in winners_list:
                await channel.send(f"ğŸ‰ æ­å–œ <@{winner_id}> ç²å¾—äº† **{prize}**ï¼")
        else:
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ",
                description="ç„¡äººåƒèˆ‡æŠ½ç" + ("ï¼ˆæ‰‹å‹•çµæŸï¼‰" if manual else ""),
                color=0xFF0000
            )
            await message.edit(embed=new_embed)
            await message.clear_reactions()
        
        conn.close()
        
    except Exception as e:
        print(f"çµæŸæŠ½çéŒ¯èª¤: {e}")

async def end_evaluation(event_id, channel, event_name):
    """çµæŸè©•æ ¸æ´»å‹•"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT participants, professions, ratings, rating_message_id 
            FROM evaluation_events 
            WHERE id = ?
        """, (event_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        participants_json, professions_json, ratings_json, rating_message_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        professions = json.loads(professions_json) if professions_json else {}
        ratings = json.loads(ratings_json) if ratings_json else {}
        
        cursor.execute("UPDATE evaluation_events SET is_active = 0 WHERE id = ?", (event_id,))
        conn.commit()
        conn.close()
        
        try:
            rating_message = await channel.fetch_message(rating_message_id)
            await rating_message.clear_reactions()
            
            end_embed = discord.Embed(
                title=f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸï¼š{event_name}",
                description="æ­¤æ´»å‹•çš„è©•æ ¸éšæ®µå·²ç¶“çµæŸï¼Œæ„Ÿè¬æ‰€æœ‰åƒèˆ‡è€…ï¼",
                color=discord.Color.green()
            )
            
            end_embed.add_field(name="ğŸ“Š çµ±è¨ˆä¿¡æ¯", value=f"**ç¸½åƒèˆ‡äººæ•¸ï¼š** {len(participants)} äºº", inline=False)
            
            rating_summary = {}
            for user_id, rating_list in ratings.items():
                if rating_list:
                    latest_rating = rating_list[-1]["rating"]
                    rating_summary[latest_rating] = rating_summary.get(latest_rating, 0) + 1
            
            rating_text = ""
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_summary.get(rating_type, 0)
                if count > 0:
                    rating_text += f"**{rating_type}ï¼š** {count}äºº\n"
            
            if rating_text:
                end_embed.add_field(name="â­ è©•ç´šåˆ†ä½ˆ", value=rating_text, inline=False)
            
            await rating_message.edit(embed=end_embed)
            
        except Exception as e:
            print(f"æ›´æ–°è©•æ ¸è¨Šæ¯éŒ¯èª¤: {e}")
        
        summary_embed = discord.Embed(
            title=f"ğŸ æ´»å‹•ç¸½çµï¼š{event_name}",
            description="è©•æ ¸æ´»å‹•å·²æ­£å¼çµæŸï¼",
            color=discord.Color.gold()
        )
        
        summary_embed.add_field(name="ğŸ‘¥ åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ® è·æ¥­é¸æ“‡", value=f"{len(professions)} äºº", inline=True)
        summary_embed.add_field(name="â­ è©•æ ¸å®Œæˆ", value=f"{len(ratings)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ“Š è©•ç´šåˆ†ä½ˆ", value=f"{len(rating_summary)} ç¨®è©•ç´š", inline=True)
        
        await channel.send(embed=summary_embed)
        
        print(f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸ: {event_name}")
        
    except Exception as e:
        print(f"çµæŸè©•æ ¸æ´»å‹•éŒ¯èª¤: {e}")

# ========== äº‹ä»¶è™•ç† ==========

@bot.event
async def setup_hook():
    """æ©Ÿå™¨äººè¨­ç½®é‰¤å­"""
    print("ğŸ”„ æ­£åœ¨è¨­ç½®æŒ‡ä»¤æ¨¹...")
    try:
        synced = await bot.tree.sync()
        print(f"âœ… æŒ‡ä»¤æ¨¹è¨­ç½®å®Œæˆï¼Œå·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
    except Exception as e:
        print(f"âŒ è¨­ç½®æŒ‡ä»¤æ¨¹å¤±æ•—: {e}")

@bot.event
async def on_ready():
    """æ©Ÿå™¨äººä¸Šç·š"""
    print(f"\n{'='*60}")
    print(f"ğŸ¤– {BOT_NAME} å·²ä¸Šç·š")
    print(f"ğŸ“Š ä¼ºæœå™¨æ•¸é‡: {len(bot.guilds)}")
    print(f"{'='*60}")
    
    init_db()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")
    
    # ç­‰å¾…ä¸€ä¸‹å†åŒæ­¥æŒ‡ä»¤
    await asyncio.sleep(2)
    
    try:
        print("ğŸ”„ æ­£åœ¨åŒæ­¥æŒ‡ä»¤...")
        
        # å…ˆæ¸…é™¤æ‰€æœ‰ç¾æœ‰æŒ‡ä»¤
        bot.tree.clear_commands(guild=None)
        
        # é‡æ–°åŒæ­¥å…¨å±€æŒ‡ä»¤
        synced = await bot.tree.sync()
        
        print(f"âœ… å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        
        # é¡¯ç¤ºå¯ç”¨æŒ‡ä»¤
        if synced:
            print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
            for cmd in synced:
                print(f"  â€¢ /{cmd.name} - {cmd.description}")
        
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")
        # å¦‚æœå¤±æ•—ï¼Œå˜—è©¦å»¶é²å¾Œå†è©¦ä¸€æ¬¡
        try:
            await asyncio.sleep(3)
            synced = await bot.tree.sync()
            print(f"âœ… é‡è©¦å¾Œå·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        except Exception as e2:
            print(f"âŒ é‡è©¦ä¹Ÿå¤±æ•—: {e2}")
    
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="/help æŸ¥çœ‹æŒ‡ä»¤"
        )
    )
    
    print(f"\nğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼")

@bot.event
async def on_raw_reaction_add(payload):
    """è™•ç†åæ‡‰äº‹ä»¶"""
    if payload.user_id == bot.user.id:
        return
    
    try:
        emoji = str(payload.emoji)
        user_id = payload.user_id
        
        channel = bot.get_channel(payload.channel_id)
        if not channel:
            return
        
        try:
            message = await channel.fetch_message(payload.message_id)
        except:
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸çµæŸåæ‡‰
        cursor.execute("""
            SELECT id, channel_id, event_name 
            FROM evaluation_events 
            WHERE rating_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        rating_event = cursor.fetchone()
        
        if rating_event and emoji == RATING_END_EMOJI:
            event_id, event_channel_id, event_name = rating_event
            
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥çµæŸè©•æ ¸æ´»å‹•ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            confirm_embed = discord.Embed(
                title="ğŸ ç¢ºèªçµæŸè©•æ ¸æ´»å‹•",
                description=f"ä½ ç¢ºå®šè¦çµæŸ **{event_name}** çš„è©•æ ¸éšæ®µå—ï¼Ÿ",
                color=discord.Color.orange()
            )
            
            class ConfirmEndView(discord.ui.View):
                def __init__(self, event_id, channel, event_name):
                    super().__init__(timeout=60)
                    self.event_id = event_id
                    self.channel = channel
                    self.event_name = event_name
                
                @discord.ui.button(label="ç¢ºå®šçµæŸ", style=discord.ButtonStyle.danger, emoji="âœ…")
                async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.defer()
                    await end_evaluation(self.event_id, self.channel, self.event_name)
                    
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
                    
                    await interaction.followup.send(f"âœ… å·²æˆåŠŸçµæŸ **{self.event_name}** çš„è©•æ ¸éšæ®µï¼")
                
                @discord.ui.button(label="å–æ¶ˆ", style=discord.ButtonStyle.secondary, emoji="âŒ")
                async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.send_message("å·²å–æ¶ˆçµæŸè©•æ ¸æ´»å‹•", ephemeral=True)
                    
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
            
            view = ConfirmEndView(event_id, channel, event_name)
            await channel.send(f"<@{user_id}>", embed=confirm_embed, view=view)
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸åæ‡‰
        if rating_event and emoji in RATING_EMOJIS:
            event_id, event_channel_id, event_name = rating_event
            rating_type = RATING_EMOJIS[emoji]
            
            print(f"æª¢æ¸¬åˆ°è©•æ ¸åæ‡‰: event_id={event_id}, rating_type={rating_type}, user_id={user_id}")
            
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥é€²è¡Œè©•æ ¸ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            participants = []
            if result and result[0]:
                participants = json.loads(result[0])
            
            if not participants:
                await channel.send("âŒ æ²’æœ‰åƒèˆ‡è€…å¯ä»¥è©•æ ¸", delete_after=5)
                conn.close()
                return
            
            print(f"æ´»å‹• {event_name} æœ‰ {len(participants)} ä½åƒèˆ‡è€…å¯ä»¥è©•æ ¸")
            
            class ParticipantSelectView(discord.ui.View):
                def __init__(self, participants, event_id, rating_type, channel, bot_instance):
                    super().__init__(timeout=60)
                    self.participants = participants
                    self.event_id = event_id
                    self.rating_type = rating_type
                    self.channel = channel
                    self.bot = bot_instance
                    
                    options = []
                    for pid in participants[:25]:
                        member = self.bot.get_user(int(pid))
                        display_name = member.display_name if member else f"ç”¨æˆ¶ID: {pid}"
                        options.append(discord.SelectOption(
                            label=display_name[:100],
                            value=str(pid),
                            description=f"é»æ“Šé¸æ“‡æ­¤ç”¨æˆ¶é€²è¡Œ {rating_type} è©•æ ¸"
                        ))
                    
                    select = discord.ui.Select(
                        placeholder=f"é¸æ“‡è¦è©•æ ¸ç‚º {rating_type} çš„åƒèˆ‡è€…",
                        options=options,
                        min_values=1,
                        max_values=1
                    )
                    
                    async def select_callback(interaction: discord.Interaction):
                        if not interaction.user.guild_permissions.administrator:
                            await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                            return
                        
                        selected_user_id = int(select.values[0])
                        selected_member = self.bot.get_user(selected_user_id)
                        display_name = selected_member.display_name if selected_member else f"ç”¨æˆ¶ID: {selected_user_id}"
                        
                        print(f"é¸æ“‡äº†ç”¨æˆ¶ {display_name} ({selected_user_id}) é€²è¡Œ {rating_type} è©•æ ¸")
                        
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        
                        cursor.execute("SELECT ratings FROM evaluation_events WHERE id = ?", (self.event_id,))
                        result = cursor.fetchone()
                        
                        ratings = {}
                        if result and result[0]:
                            ratings = json.loads(result[0])
                        
                        old_rating = None
                        if str(selected_user_id) in ratings and ratings[str(selected_user_id)]:
                            old_rating = ratings[str(selected_user_id)][-1]["rating"] if ratings[str(selected_user_id)] else None
                        
                        if str(selected_user_id) not in ratings:
                            ratings[str(selected_user_id)] = []
                        
                        ratings[str(selected_user_id)].append({
                            "rater": interaction.user.id,
                            "rating": self.rating_type,
                            "time": datetime.now().isoformat()
                        })
                        
                        cursor.execute("UPDATE evaluation_events SET ratings = ? WHERE id = ?", 
                                     (json.dumps(ratings), self.event_id))
                        conn.commit()
                        conn.close()
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            update_user_score(selected_user_id, display_name, -old_score, f"è©•ç´šè®Šæ›´: {old_rating} â†’ {self.rating_type}")
                            print(f"ç§»é™¤èˆŠè©•ç´šç©åˆ†: {old_rating} (-{old_score}åˆ†)")
                        
                        new_score = RATING_SCORES.get(self.rating_type, 0)
                        update_user_rating(selected_user_id, self.rating_type)
                        
                        if new_score != 0:
                            update_user_score(selected_user_id, display_name, new_score, f"æ´»å‹•è©•æ ¸: {self.rating_type}")
                            print(f"æ·»åŠ æ–°è©•ç´šç©åˆ†: {self.rating_type} (+{new_score}åˆ†)")
                        
                        score_change = RATING_SCORES.get(self.rating_type, 0)
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            result_text = f"å·²å°‡ <@{selected_user_id}> ({display_name}) çš„è©•ç´šå¾ **{old_rating}** ({old_score}åˆ†) è®Šæ›´ç‚º **{self.rating_type}** ({'+' if score_change > 0 else ''}{score_change}åˆ†)"
                        else:
                            result_text = f"å·²ç‚º <@{selected_user_id}> ({display_name}) è©•æ ¸ï¼š**{self.rating_type}** ({'+' if score_change > 0 else ''}{score_change}åˆ†)"
                        
                        result_embed = discord.Embed(
                            title="âœ… è©•æ ¸å®Œæˆ",
                            description=result_text,
                            color=discord.Color.green() if score_change >= 0 else discord.Color.red()
                        )
                        
                        result_embed.add_field(name="è©•æ ¸è€…", value=interaction.user.mention, inline=True)
                        result_embed.add_field(name="æ–°è©•ç´š", value=self.rating_type, inline=True)
                        result_embed.add_field(name="ç©åˆ†è®Šå‹•", value=f"{score_change} åˆ†", inline=True)
                        
                        await interaction.response.send_message(embed=result_embed)
                        
                        for child in self.children:
                            child.disabled = True
                        await interaction.message.edit(view=self)
                    
                    select.callback = select_callback
                    self.add_item(select)
            
            view = ParticipantSelectView(participants, event_id, rating_type, channel, bot)
            select_message = await channel.send(f"<@{user_id}> è«‹é¸æ“‡è¦è©•æ ¸ç‚º **{rating_type}** çš„åƒèˆ‡è€…ï¼š", view=view)
            print(f"å·²ç™¼é€é¸æ“‡è¦–çª—: message_id={select_message.id}")
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºæŠ½çè¨Šæ¯
        cursor.execute("""
            SELECT id, participants, creator_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (payload.message_id,))
        giveaway = cursor.fetchone()
        
        if giveaway:
            giveaway_id, participants_json, creator_id = giveaway
            
            if emoji == "ğŸ«":
                participants = json.loads(participants_json) if participants_json else []
                
                if user_id not in participants:
                    participants.append(user_id)
                    cursor.execute("UPDATE giveaways SET participants = ? WHERE id = ?", 
                                 (json.dumps(participants), giveaway_id))
                    conn.commit()
                    
                    try:
                        if message.embeds:
                            embed = message.embeds[0]
                            new_embed = discord.Embed(
                                title=embed.title,
                                description=embed.description,
                                color=embed.color
                            )
                            
                            for field in embed.fields:
                                if field.name == "ğŸ« åƒèˆ‡äººæ•¸":
                                    new_embed.add_field(
                                        name="ğŸ« åƒèˆ‡äººæ•¸", 
                                        value=f"{len(participants)} äºº", 
                                        inline=field.inline
                                    )
                                else:
                                    new_embed.add_field(
                                        name=field.name, 
                                        value=field.value, 
                                        inline=field.inline
                                    )
                            
                            if embed.footer:
                                new_embed.set_footer(text=embed.footer.text)
                            
                            await message.edit(embed=new_embed)
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            elif emoji == "â¹ï¸" and user_id == creator_id:
                await end_giveaway(payload.message_id, manual=True)
                await channel.send(f"â¹ï¸ ä¸»è¾¦äººæ‰‹å‹•çµæŸäº†æŠ½çï¼")
        
        # è™•ç†è©•æ ¸æ´»å‹•ç°½åˆ°
        cursor.execute("""
            SELECT id, participants, signup_end_time 
            FROM evaluation_events 
            WHERE signup_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        signup_event = cursor.fetchone()
        
        if signup_event and emoji == "âœ…":
            event_id, participants_json, signup_end_time_str = signup_event
            
            try:
                if signup_end_time_str:
                    try:
                        signup_end_time = datetime.strptime(signup_end_time_str.split('.')[0], '%Y-%m-%d %H:%M:%S')
                    except:
                        try:
                            signup_end_time = datetime.strptime(signup_end_time_str, '%Y-%m-%d %H:%M:%S.%f')
                        except:
                            signup_end_time = None
                else:
                    signup_end_time = None
                
                if signup_end_time and datetime.now() > signup_end_time:
                    try:
                        await message.remove_reaction("âœ…", payload.member)
                        await channel.send(f"âŒ <@{user_id}> ç°½åˆ°æ™‚é–“å·²éï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as time_error:
                print(f"æ™‚é–“è§£æéŒ¯èª¤: {time_error}")
            
            participants = json.loads(participants_json) if participants_json else []
            
            if user_id not in participants:
                participants.append(user_id)
                cursor.execute("UPDATE evaluation_events SET participants = ? WHERE id = ?", 
                             (json.dumps(participants), event_id))
                conn.commit()
                
                print(f"âœ… ç”¨æˆ¶ {user_id} æˆåŠŸç°½åˆ°æ´»å‹• {event_id}")
                
                try:
                    if message.embeds:
                        embed = message.embeds[0]
                        new_embed = discord.Embed(
                            title=embed.title,
                            description=embed.description,
                            color=embed.color
                        )
                        
                        for field in embed.fields:
                            if field.name == "ğŸ‘¥ å·²ç°½åˆ°":
                                new_embed.add_field(
                                    name="ğŸ‘¥ å·²ç°½åˆ°", 
                                    value=f"{len(participants)} äºº", 
                                    inline=field.inline
                                )
                            elif field.name == "â±ï¸ å‰©é¤˜æ™‚é–“":
                                new_embed.add_field(
                                    name=field.name,
                                    value=field.value,
                                    inline=field.inline
                                )
                            else:
                                new_embed.add_field(
                                    name=field.name, 
                                    value=field.value, 
                                    inline=field.inline
                                )
                        
                        if embed.footer:
                            new_embed.set_footer(text=embed.footer.text)
                        
                        await message.edit(embed=new_embed)
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
        
        # è™•ç†è·æ¥­é¸æ“‡
        cursor.execute("""
            SELECT id, professions 
            FROM evaluation_events 
            WHERE profession_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        profession_event = cursor.fetchone()
        
        if profession_event and emoji in PROFESSION_EMOJIS:
            event_id, professions_json = profession_event
            profession_name = PROFESSION_EMOJIS[emoji]
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            if result and result[0]:
                participants = json.loads(result[0])
                
                if user_id in participants:
                    professions = json.loads(professions_json) if professions_json else {}
                    
                    if str(user_id) not in professions:
                        professions[str(user_id)] = profession_name
                        cursor.execute("UPDATE evaluation_events SET professions = ? WHERE id = ?", 
                                     (json.dumps(professions), event_id))
                        conn.commit()
                        
                        update_user_profession(user_id, profession_name)
                        
                        try:
                            bonus = PROFESSION_BONUS.get(profession_name, 0)
                            bonus_text = f"ï¼ˆç²å¾—è·æ¥­åŠ æˆï¼š+{bonus}ç©åˆ†ï¼‰" if bonus > 0 else ""
                            await channel.send(f"âœ… <@{user_id}> å·²é¸æ“‡è·æ¥­ï¼š**{profession_name}**{bonus_text}", delete_after=5)
                        except:
                            pass
                    else:
                        try:
                            await message.remove_reaction(emoji, payload.member)
                            await channel.send(f"âš ï¸ <@{user_id}> ä½ å·²ç¶“é¸æ“‡éè·æ¥­äº†ï¼", delete_after=5)
                        except:
                            pass
                else:
                    try:
                        await message.remove_reaction(emoji, payload.member)
                        await channel.send(f"âŒ <@{user_id}> è«‹å…ˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼", delete_after=5)
                    except:
                        pass
        
        conn.close()
        
    except Exception as e:
        print(f"è™•ç†åæ‡‰éŒ¯èª¤: {e}")
        import traceback
        traceback.print_exc()

# ========== æ–œæ§“æŒ‡ä»¤ ==========

# æŒ‡ä»¤ 1: help
@bot.tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯")
async def help_slash(interaction: discord.Interaction):
    """é¡¯ç¤ºå¹«åŠ©"""
    embed = discord.Embed(
        title="ğŸ¤– å°é›²æ©Ÿæ¢°äºº - å¹«åŠ©ä¸­å¿ƒ",
        description="ä»¥ä¸‹æ˜¯å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ï¼š",
        color=0x7289DA
    )
    
    embed.add_field(
        name="ğŸ‘¤ ç”¨æˆ¶æŒ‡ä»¤",
        value=(
            "`/help` - é¡¯ç¤ºæ­¤å¹«åŠ©è¨Šæ¯\n"
            "`/profile` - æŸ¥çœ‹æˆ‘çš„æ•¸æ“š\n"
            "`/giveaway` - å‰µå»ºæŠ½ç\n"
            "`/score_draw` - ä½¿ç”¨ç©åˆ†æŠ½ç\n"
            "`/score_transfer` - è½‰ç§»ç©åˆ†\n"
            "`/prizelist` - æŸ¥çœ‹å½©æ± åˆ—è¡¨\n"
            "`/random_team` - éš¨æ©Ÿåˆ†çµ„"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ› ï¸ ç®¡ç†å“¡æŒ‡ä»¤",
        value=(
            "`/add_prize` - èª¿æ•´å½©æ± \n"
            "`/add_score` - åŠ æ¸›ç©åˆ†\n"
            "`/create_event` - å‰µå»ºè©•æ ¸æ´»å‹•\n"
            "`/all_profiles` - æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™\n"
            "`/attendance_stats` - æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ\n"
            "`/sync` - åŒæ­¥æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰\n"
            "`/ping` - æ¸¬è©¦æ©Ÿå™¨äººå»¶é²"
        ),
        inline=False
    )
    
    embed.set_footer(text="å…±13å€‹æŒ‡ä»¤ | ä½¿ç”¨ / é–‹é ­è¼¸å…¥æŒ‡ä»¤")
    await interaction.response.send_message(embed=embed)

# æŒ‡ä»¤ 2: sync
@bot.tree.command(name="sync", description="åŒæ­¥æ–œæ§“æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰")
async def sync_slash(interaction: discord.Interaction):
    """åŒæ­¥æŒ‡ä»¤"""
    await interaction.response.defer(ephemeral=True)
    
    if interaction.user.id not in OWNER_IDS:
        embed = discord.Embed(
            title="âŒ æ¬Šé™ä¸è¶³",
            description="åªæœ‰æ©Ÿå™¨äººæ“æœ‰è€…å¯ä»¥ä½¿ç”¨æ­¤æŒ‡ä»¤",
            color=0xFF0000
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        return
    
    try:
        print("ğŸ”„ æ‰‹å‹•åŒæ­¥æŒ‡ä»¤ä¸­...")
        bot.tree.clear_commands(guild=None)
        synced = await bot.tree.sync()
        
        embed = discord.Embed(
            title="ğŸ”„ æŒ‡ä»¤åŒæ­¥å®Œæˆ",
            description=f"å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤åˆ°æ‰€æœ‰ä¼ºæœå™¨",
            color=0x43B581
        )
        
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åŒæ­¥å¤±æ•—",
            description=f"éŒ¯èª¤è¨Šæ¯: {str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed, ephemeral=True)

# æŒ‡ä»¤ 3: profile
@bot.tree.command(name="profile", description="æŸ¥çœ‹æˆ‘çš„æ•¸æ“š")
async def profile_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        user_id = interaction.user.id
        username = interaction.user.name
        
        profile = get_user_profile(user_id)
        
        if not profile:
            conn = sqlite3.connect(DB_NAME)
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
                (user_id, username, 0, 0)
            )
            conn.commit()
            conn.close()
            
            profile = {
                'user_id': user_id,
                'current_score': 0,
                'total_score': 0,
                'join_date': datetime.now().strftime('%Y-%m-%d'),
                'profession_counts': {},
                'activity_stats': {},
                'rating_stats': {}
            }
        
        current_score = profile['current_score']
        total_score = profile['total_score']
        join_date_str = profile['join_date']
        profession_counts = profile['profession_counts']
        activity_stats = profile['activity_stats']
        rating_stats = profile['rating_stats']
        
        current_period = get_current_half_month()
        period_data = activity_stats.get(current_period, {})
        total_events = period_data.get('total', 0)
        attended_events = period_data.get('attended', 0)
        attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
        
        embed = discord.Embed(
            title=f"ğŸ“Š {username} çš„è©•æ ¸æ•¸æ“š",
            color=0x43B581
        )
        
        attendance_info = (
            f"**ç•¶å‰åŠæœˆæœŸï¼š** {current_period}\n"
            f"**ç¸½æ´»å‹•æ•¸ï¼š** {total_events} æ¬¡\n"
            f"**å¯¦éš›å‡ºå¸­ï¼š** {attended_events} æ¬¡\n"
            f"**å‡ºå¸­ç‡ï¼š** {attendance_rate:.1f}%\n"
        )
        
        embed.add_field(
            name="ğŸ“… åŠæœˆæœŸå‡ºå¸­ç‡",
            value=attendance_info,
            inline=False
        )
        
        score_info = f"**ç•¶å‰ç©åˆ†ï¼š** {current_score} åˆ†\n"
        score_info += f"**ç¸½ç²å¾—ç©åˆ†ï¼š** {total_score} åˆ†\n\n"
        score_info += f"**ç©åˆ†è¦å‰‡ï¼š**\n"
        score_info += f"â€¢ ç°½åˆ°ï¼š+{SIGNUP_SCORE}åˆ†\n"
        for profession, bonus in PROFESSION_BONUS.items():
            if bonus > 0:
                score_info += f"â€¢ {profession}ï¼š+{bonus}åˆ†\n"
        score_info += f"â€¢ å„ªç§€ï¼š+{RATING_SCORES['å„ªç§€']}åˆ†\n"
        score_info += f"â€¢ è‰¯å¥½ï¼š+{RATING_SCORES['è‰¯å¥½']}åˆ†\n"
        score_info += f"â€¢ æ™®é€šï¼š{RATING_SCORES['æ™®é€š']}åˆ†ï¼ˆé è¨­ï¼‰\n"
        score_info += f"â€¢ ä¸åˆæ ¼ï¼š{RATING_SCORES['ä¸åˆæ ¼']}åˆ†"
        
        embed.add_field(
            name="ğŸ’° ç©åˆ†çµ±è¨ˆ",
            value=score_info,
            inline=False
        )
        
        if profession_counts:
            profession_info = ""
            total_plays = sum(profession_counts.values())
            for profession, count in profession_counts.items():
                percentage = (count / total_plays * 100) if total_plays > 0 else 0
                profession_info += f"**{profession}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
        else:
            profession_info = "å°šæœªè¨˜éŒ„è·æ¥­æ•¸æ“š"
        
        embed.add_field(
            name="ğŸ® è·æ¥­çµ±è¨ˆ",
            value=profession_info,
            inline=False
        )
        
        if rating_stats:
            rating_info = ""
            total_ratings = sum(rating_stats.values())
            total_rating_score = 0
            
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_stats.get(rating_type, 0)
                if count > 0:
                    percentage = (count / total_ratings * 100) if total_ratings > 0 else 0
                    score = RATING_SCORES.get(rating_type, 0)
                    rating_info += f"**{rating_type}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
                    total_rating_score += count * score
            
            if total_ratings > 0:
                rating_info += f"\n**è©•æ ¸ç¸½ç²å¾—ç©åˆ†ï¼š** {total_rating_score} åˆ†"
        else:
            rating_info = "å°šæœªæœ‰è©•æ ¸è¨˜éŒ„"
        
        embed.add_field(
            name="â­ è©•æ ¸çµ±è¨ˆ",
            value=rating_info,
            inline=False
        )
        
        embed.add_field(name="ç”¨æˆ¶ID", value=f"`{user_id}`", inline=True)
        embed.add_field(name="åŠ å…¥æ—¥æœŸ", value=join_date_str, inline=True)
        
        if interaction.user.avatar:
            embed.set_thumbnail(url=interaction.user.avatar.url)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ ç™¼ç”ŸéŒ¯èª¤",
            description=f"ç„¡æ³•è®€å–ç”¨æˆ¶è³‡æ–™ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 4: giveaway
@bot.tree.command(name="giveaway", description="å‰µå»ºæŠ½çæ´»å‹•")
@app_commands.describe(
    prize="çå“å…§å®¹",
    duration="æŠ½çæŒçºŒæ™‚é–“ï¼ˆä¾‹å¦‚ï¼š60s, 1m, 1h, 1dï¼‰",
    winners="ç²çäººæ•¸"
)
async def giveaway_slash(
    interaction: discord.Interaction,
    prize: str,
    duration: str = "1h",
    winners: int = 1
):
    """å‰µå»ºæŠ½ç"""
    await interaction.response.defer()
    
    try:
        duration_lower = duration.lower().strip()
        seconds = 3600
        
        if duration_lower.endswith('s'):
            seconds = int(duration_lower[:-1])
        elif duration_lower.endswith('m'):
            seconds = int(duration_lower[:-1]) * 60
        elif duration_lower.endswith('h'):
            seconds = int(duration_lower[:-1]) * 3600
        elif duration_lower.endswith('d'):
            seconds = int(duration_lower[:-1]) * 86400
        elif duration_lower.isdigit():
            seconds = int(duration_lower)
        
        if seconds < 10:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“å¿…é ˆè‡³å°‘10ç§’ï¼")
            return
        
        if seconds > 86400 * 7:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“ä¸èƒ½è¶…é7å¤©ï¼")
            return
        
        end_time = datetime.now() + timedelta(seconds=seconds)
        
        if seconds < 60:
            time_display = f"{seconds}ç§’"
        elif seconds < 3600:
            time_display = f"{seconds//60}åˆ†{seconds%60}ç§’"
        elif seconds < 86400:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            time_display = f"{hours}å°æ™‚{minutes}åˆ†"
        else:
            days = seconds // 86400
            hours = (seconds % 86400) // 3600
            time_display = f"{days}å¤©{hours}å°æ™‚"
        
        embed = discord.Embed(
            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
            color=0xFFD700
        )
        
        embed.add_field(name="ğŸ çå“", value=prize, inline=True)
        embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
        embed.add_field(name="â° çµæŸæ™‚é–“", value=time_display, inline=True)
        embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value="0 äºº", inline=True)
        embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
        embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
        
        creator_name = interaction.user.display_name
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
        giveaway_id = f"giveaway_{int(time.time())}_{random.randint(1000, 9999)}"
        
        embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{current_time}")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ«")
        await message.add_reaction("â¹ï¸")
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO giveaways (creator_id, prize, winner_count, end_time, message_id, channel_id)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (interaction.user.id, prize, winners, end_time, message.id, interaction.channel.id))
        conn.commit()
        conn.close()
        
        print(f"âœ… æŠ½çå·²å‰µå»º: çå“={prize}, æ™‚é–“={seconds}ç§’, è¨Šæ¯ID={message.id}")
        
        async def countdown_timer():
            remaining = seconds
            last_update = time.time()
            
            while remaining > 0:
                await asyncio.sleep(1)
                remaining -= 1
                
                if time.time() - last_update >= 30:
                    if remaining < 60:
                        time_display = f"{remaining}ç§’"
                    elif remaining < 3600:
                        time_display = f"{remaining//60}åˆ†{remaining%60}ç§’"
                    elif remaining < 86400:
                        hours = remaining // 3600
                        minutes = (remaining % 3600) // 60
                        time_display = f"{hours}å°æ™‚{minutes}åˆ†"
                    else:
                        days = remaining // 86400
                        hours = (remaining % 86400) // 3600
                        time_display = f"{days}å¤©{hours}å°æ™‚"
                    
                    try:
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        cursor.execute("SELECT participants FROM giveaways WHERE message_id = ?", (message.id,))
                        result = cursor.fetchone()
                        participants_count = 0
                        if result and result[0]:
                            participants = json.loads(result[0])
                            participants_count = len(participants)
                        conn.close()
                        
                        new_embed = discord.Embed(
                            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
                            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
                            color=0xFFD700
                        )
                        
                        new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
                        new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
                        new_embed.add_field(name="â° çµæŸæ™‚é–“", value=f"{time_display}å…§", inline=True)
                        new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{participants_count} äºº", inline=True)
                        new_embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
                        new_embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
                        
                        new_embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{datetime.now().strftime('%Y-%m-%d %H:%M')}")
                        
                        await message.edit(embed=new_embed)
                        last_update = time.time()
                        
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            await end_giveaway(message.id)
        
        asyncio.create_task(countdown_timer())
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 5: score_draw
@bot.tree.command(name="score_draw", description="ä½¿ç”¨ç©åˆ†æŠ½ç")
async def score_draw_slash(interaction: discord.Interaction):
    """ç©åˆ†æŠ½ç"""
    await interaction.response.defer()
    
    try:
        current_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ² ç©åˆ†æŠ½çç³»çµ±",
            description="è«‹é¸æ“‡è¦æ‰£é™¤çš„ç©åˆ†é€²è¡ŒæŠ½çï¼š",
            color=0x9B59B6
        )
        
        embed.add_field(
            name="ğŸŸ¢ 50ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 70%\nâ€¢ è—ç®± 25%\nâ€¢ ç´«ç®± 4.5%\nâ€¢ é‡‘ç®± 0.5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ”µ 100ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 50%\nâ€¢ è—ç®± 40%\nâ€¢ ç´«ç®± 9%\nâ€¢ é‡‘ç®± 1%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸŸ£ 500ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 10%\nâ€¢ è—ç®± 65%\nâ€¢ ç´«ç®± 20%\nâ€¢ é‡‘ç®± 5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ’° ä½ çš„ç©åˆ†",
            value=f"{current_score} åˆ†",
            inline=False
        )
        
        embed.set_footer(text="é»æ“Šä¸‹æ–¹å°æ‡‰çš„emojié¸æ“‡æŠ½çé¡å‹")
        
        class ScoreDrawView(discord.ui.View):
            def __init__(self, user_id):
                super().__init__(timeout=60)
                self.user_id = user_id
            
            @discord.ui.button(label="50åˆ†", style=discord.ButtonStyle.success, emoji="ğŸŸ¢", row=0)
            async def fifty_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 50)
            
            @discord.ui.button(label="100åˆ†", style=discord.ButtonStyle.primary, emoji="ğŸ”µ", row=0)
            async def hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 100)
            
            @discord.ui.button(label="500åˆ†", style=discord.ButtonStyle.secondary, emoji="ğŸŸ£", row=1)
            async def five_hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 500)
            
            async def process_draw(self, interaction: discord.Interaction, score_cost: int):
                if interaction.user.id != self.user_id:
                    await interaction.response.send_message("âŒ é€™ä¸æ˜¯ä½ çš„æŠ½çï¼", ephemeral=True)
                    return
                
                current_score, _ = get_user_score(interaction.user.id)
                if current_score < score_cost:
                    await interaction.response.send_message(
                        f"âŒ ç©åˆ†ä¸è¶³ï¼éœ€è¦ {score_cost} åˆ†ï¼Œä½ ç›®å‰æœ‰ {current_score} åˆ†",
                        ephemeral=True
                    )
                    return
                
                weights = {
                    50: {"ç¶ ç®±": 70, "è—ç®±": 25, "ç´«ç®±": 4.5, "é‡‘ç®±": 0.5},
                    100: {"ç¶ ç®±": 50, "è—ç®±": 40, "ç´«ç®±": 9, "é‡‘ç®±": 1},
                    500: {"ç¶ ç®±": 10, "è—ç®±": 65, "ç´«ç®±": 20, "é‡‘ç®±": 5}
                }
                
                box_weights = weights[score_cost]
                box_types = list(box_weights.keys())
                box_weights_list = list(box_weights.values())
                selected_box = random.choices(box_types, weights=box_weights_list, k=1)[0]
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute(
                    "SELECT id, prize_name FROM prize_pool WHERE box_level = ? AND remaining > 0 ORDER BY RANDOM() LIMIT 1",
                    (selected_box,)
                )
                result = cursor.fetchone()
                
                if not result:
                    await interaction.response.send_message(f"âŒ {selected_box}ä¸­æ²’æœ‰å¯ç”¨çå“ï¼", ephemeral=True)
                    conn.close()
                    return
                
                prize_id, prize_name = result
                
                update_user_score(interaction.user.id, interaction.user.name, -score_cost, f"ç©åˆ†æŠ½ç ({selected_box})")
                cursor.execute("UPDATE prize_pool SET remaining = remaining - 1 WHERE id = ?", (prize_id,))
                
                cursor.execute('''
                    INSERT INTO score_draws (creator_id, score_cost, box_level, winner_prize, winner_id)
                    VALUES (?, ?, ?, ?, ?)
                ''', (interaction.user.id, score_cost, selected_box, prize_name, interaction.user.id))
                
                conn.commit()
                conn.close()
                
                new_current_score, _ = get_user_score(interaction.user.id)
                
                result_embed = discord.Embed(
                    title="ğŸ‰ æŠ½ççµæœ",
                    description=f"ä½ æŠ½ä¸­äº† **{prize_name}**ï¼",
                    color=0x00FF00
                )
                
                result_embed.add_field(name="æ‰£é™¤ç©åˆ†", value=f"{score_cost} åˆ†", inline=True)
                result_embed.add_field(name="å¯¶ç®±é¡å‹", value=selected_box, inline=True)
                result_embed.add_field(name="ä¸­çæ©Ÿç‡", value=f"{box_weights[selected_box]}%", inline=True)
                result_embed.add_field(name="å‰©é¤˜ç©åˆ†", value=f"{new_current_score} åˆ†", inline=True)
                result_embed.add_field(name="çå“åç¨±", value=prize_name, inline=False)
                
                await interaction.response.send_message(embed=result_embed, ephemeral=False)
                
                for child in self.children:
                    child.disabled = True
                
                await interaction.message.edit(view=self)
        
        view = ScoreDrawView(interaction.user.id)
        await interaction.followup.send(embed=embed, view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 6: score_transfer
@bot.tree.command(name="score_transfer", description="è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="è½‰ç§»ç©åˆ†",
    reason="åŸå› ï¼ˆå¯é¸ï¼‰"
)
async def score_transfer_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: Optional[str] = None
):
    """è½‰ç§»ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if amount <= 0:
            await interaction.followup.send("âŒ ç©åˆ†å¿…é ˆå¤§æ–¼ 0")
            return
        
        if user.id == interaction.user.id:
            await interaction.followup.send("âŒ ä¸èƒ½è½‰ç§»ç©åˆ†çµ¦è‡ªå·±")
            return
        
        sender_score, _ = get_user_score(interaction.user.id)
        
        if sender_score < amount:
            await interaction.followup.send(f"âŒ ä½ çš„ç©åˆ†ä¸è¶³ï¼éœ€è¦ {amount} åˆ†ï¼Œä½ ç›®å‰æœ‰ {sender_score} åˆ†")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        update_user_score(interaction.user.id, interaction.user.name, -amount, f"è½‰ç§»çµ¦ {user.name}")
        update_user_score(user.id, user.name, amount, f"ä¾†è‡ª {interaction.user.name} çš„è½‰ç§»")
        
        cursor.execute('''
            INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason)
            VALUES (?, ?, ?, ?)
        ''', (interaction.user.id, user.id, amount, reason or "ç„¡"))
        
        conn.commit()
        conn.close()
        
        new_sender_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ’¸ ç©åˆ†è½‰ç§»æˆåŠŸ",
            description=f"**è½‰å‡ºï¼š** {interaction.user.mention}\n"
                       f"**è½‰å…¥ï¼š** {user.mention}\n"
                       f"**é‡‘é¡ï¼š** {amount} åˆ†\n"
                       f"**åŸå› ï¼š** {reason or 'ç„¡'}\n"
                       f"**ä½ çš„å‰©é¤˜ç©åˆ†ï¼š** {new_sender_score} åˆ†",
            color=0x2ECC71
        )
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è½‰ç§»å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 7: prizelist
@bot.tree.command(name="prizelist", description="æŸ¥çœ‹å½©æ± åˆ—è¡¨")
async def prizelist_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹å½©æ± """
    await interaction.response.defer()
    
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT box_level, 
                   COUNT(*) as total_items,
                   SUM(remaining) as total_remaining
            FROM prize_pool 
            WHERE remaining > 0 
            GROUP BY box_level 
            ORDER BY 
                CASE box_level 
                    WHEN 'é‡‘ç®±' THEN 1 
                    WHEN 'ç´«ç®±' THEN 2 
                    WHEN 'è—ç®±' THEN 3 
                    WHEN 'ç¶ ç®±' THEN 4 
                    ELSE 5 
                END
        """)
        
        results = cursor.fetchall()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ å½©æ± åˆ—è¡¨",
                description="ç›®å‰å½©æ± æ˜¯ç©ºçš„",
                color=0xFFD700
            )
            await interaction.followup.send(embed=embed)
            conn.close()
            return
        
        embed = discord.Embed(
            title="ğŸ å½©æ± åˆ—è¡¨",
            description="å¯ç”¨çš„çå“ï¼ˆæŒ‰å¯¶ç®±ç­‰ç´šåˆ†é¡ï¼‰ï¼š",
            color=0xFFD700
        )
        
        for box_level, total_items, total_remaining in results:
            cursor.execute("""
                SELECT prize_name, remaining 
                FROM prize_pool 
                WHERE box_level = ? AND remaining > 0 
                ORDER BY prize_name
            """, (box_level,))
            
            items = cursor.fetchall()
            
            items_text = ""
            displayed_count = 0
            hidden_count = 0
            
            for prize_name, remaining in items:
                displayed_count += 1
                if displayed_count <= 8:
                    items_text += f"â€¢ {prize_name} (å‰©é¤˜: {remaining})\n"
                else:
                    hidden_count += 1
            
            if hidden_count > 0:
                items_text += f"... é‚„æœ‰ {hidden_count} å€‹çå“\n"
            
            actual_total = sum(item[1] for item in items)
            
            embed.add_field(
                name=f"{box_level} (ç¸½å‰©é¤˜: {actual_total} / çå“ç¨®é¡: {total_items})",
                value=items_text if items_text else "ç„¡çå“",
                inline=False
            )
        
        conn.close()
        
        embed.add_field(
            name="ğŸ“Š ç©åˆ†æŠ½çæ©Ÿç‡",
            value="**50ç©åˆ†ï¼š** ç¶ ç®±70% è—ç®±25% ç´«ç®±4.5% é‡‘ç®±0.5%\n"
                  "**100ç©åˆ†ï¼š** ç¶ ç®±50% è—ç®±40% ç´«ç®±9% é‡‘ç®±1%\n"
                  "**500ç©åˆ†ï¼š** ç¶ ç®±10% è—ç®±65% ç´«ç®±20% é‡‘ç®±5%",
            inline=False
        )
        
        embed.set_footer(text="ä½¿ç”¨ /add_prize æ·»åŠ çå“åˆ°å½©æ± ")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å½©æ± å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 8: random_team
@bot.tree.command(name="random_team", description="éš¨æ©Ÿåˆ†çµ„")
@app_commands.describe(
    team_size="æ¯çµ„äººæ•¸",
    team_count="çµ„æ•¸"
)
async def random_team_slash(
    interaction: discord.Interaction,
    team_size: Optional[int] = None,
    team_count: Optional[int] = None
):
    """éš¨æ©Ÿåˆ†çµ„"""
    await interaction.response.defer()
    
    try:
        if not interaction.guild:
            await interaction.followup.send("âŒ æ­¤æŒ‡ä»¤åªèƒ½åœ¨ä¼ºæœå™¨ä¸­ä½¿ç”¨")
            return
        
        embed = discord.Embed(
            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
            color=0x3498DB
        )
        
        if team_size:
            embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
        if team_count:
            embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
        
        embed.add_field(name="åƒåŠ äººæ•¸", value="0 äºº", inline=True)
        embed.set_footer(text="ç­‰å¾…åƒåŠ è€…...")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ®")
        await message.add_reaction("â–¶ï¸")
        
        participants = []
        
        def check(reaction, user):
            return (
                user != bot.user and
                str(reaction.emoji) in ["ğŸ®", "â–¶ï¸"] and
                reaction.message.id == message.id
            )
        
        try:
            while True:
                reaction, user = await bot.wait_for('reaction_add', timeout=300.0, check=check)
                
                if str(reaction.emoji) == "ğŸ®":
                    if user.id not in participants:
                        participants.append(user.id)
                        
                        new_embed = discord.Embed(
                            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
                            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
                            color=0x3498DB
                        )
                        
                        if team_size:
                            new_embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
                        if team_count:
                            new_embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
                        
                        new_embed.add_field(name="åƒåŠ äººæ•¸", value=f"{len(participants)} äºº", inline=True)
                        
                        if participants:
                            participants_text = ""
                            for i, pid in enumerate(participants[:10], 1):
                                participants_text += f"{i}. <@{pid}>\n"
                            if len(participants) > 10:
                                participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                            
                            new_embed.add_field(name="åƒåŠ è€…", value=participants_text, inline=False)
                        
                        new_embed.set_footer(text=f"ç­‰å¾…ä¸»æŒäººé–‹å§‹... ({len(participants)}äººåƒåŠ )")
                        
                        await message.edit(embed=new_embed)
                        
                elif str(reaction.emoji) == "â–¶ï¸" and user.id == interaction.user.id:
                    if len(participants) < 2:
                        await message.channel.send("âŒ è‡³å°‘éœ€è¦2äººæ‰èƒ½é–‹å§‹åˆ†çµ„", delete_after=5)
                        continue
                    
                    random.shuffle(participants)
                    
                    if team_size:
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    elif team_count:
                        team_size = len(participants) // team_count
                        if len(participants) % team_count != 0:
                            team_size += 1
                    else:
                        if len(participants) <= 4:
                            team_size = 2
                        elif len(participants) <= 8:
                            team_size = 4
                        else:
                            team_size = 5
                        
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    
                    teams = []
                    for i in range(team_count):
                        start_idx = i * team_size
                        end_idx = min((i + 1) * team_size, len(participants))
                        if start_idx < len(participants):
                            teams.append(participants[start_idx:end_idx])
                    
                    result_embed = discord.Embed(
                        title="ğŸ‘¥ åˆ†çµ„çµæœ",
                        description=f"ç¸½äººæ•¸ï¼š{len(participants)} äºº\n"
                                   f"åˆ†çµ„æ–¹å¼ï¼š{team_count} çµ„ï¼Œæ¯çµ„ç´„ {team_size} äºº",
                        color=0x00FF00
                    )
                    
                    for i, team in enumerate(teams, 1):
                        members_list = "\n".join([f"{j+1}. <@{member_id}>" for j, member_id in enumerate(team)])
                        result_embed.add_field(
                            name=f"ç¬¬ {i} çµ„ ({len(team)}äºº)",
                            value=members_list,
                            inline=False
                        )
                    
                    await message.channel.send(embed=result_embed)
                    await message.clear_reactions()
                    break
        
        except asyncio.TimeoutError:
            timeout_embed = discord.Embed(
                title="ğŸ‘¥ åˆ†çµ„è¶…æ™‚",
                description="åˆ†çµ„æ™‚é–“å·²é",
                color=0xFF0000
            )
            await message.edit(embed=timeout_embed)
            await message.clear_reactions()
            
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åˆ†çµ„å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 9: add_prize (ç®¡ç†å“¡)
@bot.tree.command(name="add_prize", description="æ·»åŠ çå“åˆ°å½©æ± ")
@app_commands.describe(
    name="çå“åç¨±",
    box_level="å¯¶ç®±ç­‰ç´š (ç¶ ç®±/è—ç®±/ç´«ç®±/é‡‘ç®±)",
    quantity="æ•¸é‡ (æ­£æ•¸æ·»åŠ , è² æ•¸æ¸›å°‘)"
)
async def add_prize_slash(
    interaction: discord.Interaction,
    name: str,
    box_level: str,
    quantity: int
):
    """æ·»åŠ /æ¸›å°‘çå“"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        valid_levels = ["ç¶ ç®±", "è—ç®±", "ç´«ç®±", "é‡‘ç®±"]
        if box_level not in valid_levels:
            await interaction.followup.send(f"âŒ ç„¡æ•ˆçš„å¯¶ç®±ç­‰ç´šï¼è«‹é¸æ“‡ï¼š{', '.join(valid_levels)}")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        if quantity > 0:
            cursor.execute('''
                INSERT INTO prize_pool (prize_name, box_level, quantity, remaining, added_by)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(prize_name, box_level) 
                DO UPDATE SET 
                    quantity = quantity + excluded.quantity,
                    remaining = remaining + excluded.quantity
            ''', (name, box_level, quantity, quantity, interaction.user.id))
            
            action = "æ·»åŠ "
        elif quantity < 0:
            cursor.execute('''
                UPDATE prize_pool 
                SET quantity = quantity + ?,
                    remaining = CASE 
                                    WHEN remaining + ? > 0 THEN remaining + ?
                                    ELSE 0
                                END
                WHERE prize_name = ? AND box_level = ?
            ''', (quantity, quantity, quantity, name, box_level))
            
            if cursor.rowcount == 0:
                await interaction.followup.send(f"âŒ æ‰¾ä¸åˆ°çå“ '{name}' åœ¨ {box_level} ä¸­")
                conn.close()
                return
            
            action = "æ¸›å°‘"
        else:
            await interaction.followup.send("âŒ æ•¸é‡ä¸èƒ½ç‚º 0")
            conn.close()
            return
        
        cursor.execute("SELECT quantity, remaining FROM prize_pool WHERE prize_name = ? AND box_level = ?", 
                      (name, box_level))
        result = cursor.fetchone()
        
        if result:
            total_qty, remaining_qty = result
            
            embed = discord.Embed(
                title=f"âœ… çå“{action}æˆåŠŸ",
                color=0x2ECC71 if quantity > 0 else 0xE74C3C
            )
            
            embed.add_field(name="çå“åç¨±", value=name, inline=True)
            embed.add_field(name="å¯¶ç®±ç­‰ç´š", value=box_level, inline=True)
            embed.add_field(name=f"{action}æ•¸é‡", value=f"{abs(quantity)} å€‹", inline=True)
            embed.add_field(name="ç¸½æ•¸é‡", value=f"{total_qty} å€‹", inline=True)
            embed.add_field(name="å‰©é¤˜æ•¸é‡", value=f"{remaining_qty} å€‹", inline=True)
            embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
            
            await interaction.followup.send(embed=embed)
        else:
            await interaction.followup.send(f"âŒ æ“ä½œå¤±æ•—")
        
        conn.commit()
        conn.close()
        
    except sqlite3.OperationalError as e:
        if "no such column" in str(e) or "no such table" in str(e):
            error_embed = discord.Embed(
                title="âŒ è³‡æ–™åº«çµæ§‹éŒ¯èª¤",
                description="è«‹åˆªé™¤ bot_data.db æª”æ¡ˆå¾Œé‡æ–°å•Ÿå‹•æ©Ÿå™¨äºº",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
        else:
            error_embed = discord.Embed(
                title="âŒ æ“ä½œå¤±æ•—",
                description=f"è³‡æ–™åº«éŒ¯èª¤ï¼š{str(e)}",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æ“ä½œå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 10: add_score (ç®¡ç†å“¡)
@bot.tree.command(name="add_score", description="èª¿æ•´ç”¨æˆ¶ç©åˆ†")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="ç©åˆ†è®ŠåŒ–ï¼ˆæ­£æ•¸ç‚ºå¢åŠ ï¼Œè² æ•¸ç‚ºæ¸›å°‘ï¼‰",
    reason="åŸå› "
)
async def add_score_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: str
):
    """èª¿æ•´ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        if amount == 0:
            await interaction.followup.send("âŒ ç©åˆ†è®ŠåŒ–ä¸èƒ½ç‚º 0")
            return
        
        old_score, old_total = get_user_score(user.id)
        update_user_score(user.id, user.name, amount, f"ç®¡ç†å“¡èª¿æ•´: {reason}")
        new_score, new_total = get_user_score(user.id)
        
        action = "å¢åŠ " if amount > 0 else "æ¸›å°‘"
        embed = discord.Embed(
            title=f"âœ… ç©åˆ†{action}æˆåŠŸ",
            color=0x2ECC71 if amount > 0 else 0xE74C3C
        )
        
        embed.add_field(name="ç”¨æˆ¶", value=user.mention, inline=True)
        embed.add_field(name=f"{action}ç©åˆ†", value=f"{abs(amount)} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå‰ç©åˆ†", value=f"{old_score} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå¾Œç©åˆ†", value=f"{new_score} åˆ†", inline=True)
        embed.add_field(name="ç¸½ç²å¾—ç©åˆ†", value=f"{new_total} åˆ†", inline=True)
        embed.add_field(name="åŸå› ", value=reason, inline=True)
        embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ èª¿æ•´å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 11: create_event (ç®¡ç†å“¡)
@bot.tree.command(name="create_event", description="å‰µå»ºè©•æ ¸æ´»å‹•")
@app_commands.describe(
    event_name="æ´»å‹•åç¨±",
    signup_time="ç°½åˆ°æ™‚é–“ï¼ˆåˆ†é˜ï¼‰",
    prize="æ´»å‹•çå“"
)
async def create_event_slash(
    interaction: discord.Interaction,
    event_name: str,
    signup_time: int = 5,
    prize: Optional[str] = None
):
    """å‰µå»ºè©•æ ¸æ´»å‹•"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        signup_embed = discord.Embed(
            title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
            color=discord.Color.blue()
        )
        
        if prize:
            signup_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
        
        signup_embed.add_field(
            name="ğŸ“ ç°½åˆ°éšæ®µ",
            value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°",
            inline=False
        )
        
        signup_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value="0 äºº", inline=True)
        signup_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
        
        signup_message = await interaction.followup.send(embed=signup_embed, wait=True)
        await signup_message.add_reaction("âœ…")
        
        class_embed = discord.Embed(
            title=f"ğŸ® è·æ¥­é¸æ“‡ï¼š{event_name}",
            description="è«‹é¸æ“‡ä½ çš„è·æ¥­ï¼š\n\nğŸ›¡ï¸ å¦å…‹\nâš”ï¸ è¾“å‡º\nğŸ’š æ²»ç–—\nğŸ’› è¾…åŠ©\n\n**æ³¨æ„ï¼šè«‹å…ˆå®Œæˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼**",
            color=discord.Color.green()
        )
        class_embed.set_footer(text="ç°½åˆ°æˆåŠŸå¾Œè«‹é¸æ“‡è·æ¥­")
        
        class_msg = await interaction.channel.send(embed=class_embed)
        for emoji in ["ğŸ›¡ï¸", "âš”ï¸", "ğŸ’š", "ğŸ’›"]:
            await class_msg.add_reaction(emoji)
        
        signup_end_time = datetime.now() + timedelta(minutes=signup_time)
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO evaluation_events (event_name, creator_id, signup_message_id, profession_message_id, channel_id, signup_end_time)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (event_name, interaction.user.id, signup_message.id, class_msg.id, interaction.channel.id, signup_end_time))
        conn.commit()
        conn.close()
        
        print(f"âœ… æ´»å‹•å‰µå»ºæˆåŠŸ: {event_name}")
        
        async def signup_countdown():
            remaining_minutes = signup_time
            
            while remaining_minutes > 0:
                await asyncio.sleep(60)
                remaining_minutes -= 1
                
                try:
                    conn = sqlite3.connect(DB_NAME)
                    cursor = conn.cursor()
                    cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                    result = cursor.fetchone()
                    
                    participants_count = 0
                    if result and result[0]:
                        participants = json.loads(result[0])
                        participants_count = len(participants)
                    conn.close()
                    
                    updated_embed = discord.Embed(
                        title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                        color=discord.Color.blue()
                    )
                    
                    if prize:
                        updated_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                    
                    updated_embed.add_field(
                        name="ğŸ“ ç°½åˆ°éšæ®µ",
                        value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°",
                        inline=False
                    )
                    
                    updated_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
                    updated_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{participants_count} äºº", inline=True)
                    updated_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{remaining_minutes} åˆ†é˜", inline=True)
                    updated_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
                    
                    await signup_message.edit(embed=updated_embed)
                    
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
            
            try:
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                result = cursor.fetchone()
                
                participants = []
                if result and result[0]:
                    participants = json.loads(result[0])
                
                for user_id in participants:
                    update_user_score(user_id, f"ç”¨æˆ¶{user_id}", SIGNUP_SCORE, f"æ´»å‹•ç°½åˆ°: {event_name}")
                    update_user_activity(user_id, event_name, attended=True)
                    update_user_rating(user_id, "æ™®é€š")
                
                cursor.execute("UPDATE evaluation_events SET default_rated = ?, is_active = 1 WHERE signup_message_id = ?", 
                             (json.dumps(participants), signup_message.id))
                conn.commit()
                conn.close()
                
                end_embed = discord.Embed(
                    title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                    description="**ç°½åˆ°å·²çµæŸï¼æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ0ç©åˆ†ï¼‰**",
                    color=discord.Color.red()
                )
                
                if prize:
                    end_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                
                end_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value="å·²çµæŸ", inline=True)
                end_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{len(participants)} äºº", inline=True)
                
                if participants:
                    participants_text = "\n".join([f"<@{user_id}>" for user_id in participants[:10]])
                    if len(participants) > 10:
                        participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                    
                    end_embed.add_field(name="ğŸ“‹ åƒèˆ‡è€…åˆ—è¡¨", value=participants_text, inline=False)
                
                end_embed.add_field(name="ğŸ“ è©•æ ¸èªªæ˜", value="ä¸»æŒäººç¾åœ¨å¯ä»¥æŒ‰EMOJIèª¿æ•´è©•ç´šï¼š\nâ­ å„ªç§€ (+40åˆ†)\nğŸ‘ è‰¯å¥½ (+10åˆ†)\nğŸ‘Œ æ™®é€š (0åˆ†ï¼Œé è¨­)\nâŒ ä¸åˆæ ¼ (-5åˆ†)", inline=False)
                end_embed.set_footer(text="åŠæœˆæœŸæ´»å‹•çµ±è¨ˆå·²æ›´æ–° | ç°½åˆ°ç©åˆ†å·²ç™¼æ”¾ | é è¨­è©•ç´šï¼šæ™®é€š")
                
                await signup_message.edit(embed=end_embed)
                await signup_message.clear_reactions()
                
                rating_embed = discord.Embed(
                    title=f"â­ è©•æ ¸éšæ®µï¼š{event_name}",
                    description="**ä¸»æŒäººå¯ä»¥æŒ‰ä¸‹æ–¹EMOJIèª¿æ•´è©•ç´š**\n\n"
                              f"æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ{RATING_SCORES['æ™®é€š']}ç©åˆ†ï¼‰\n",
                    color=discord.Color.gold()
                )
                
                if participants:
                    rating_embed.add_field(
                        name="ğŸ‘¥ åƒèˆ‡è€…åˆ—è¡¨",
                        value="\n".join([f"<@{user_id}>" for user_id in participants[:15]]) + 
                             (f"\n... é‚„æœ‰ {len(participants)-15} äºº" if len(participants) > 15 else ""),
                        inline=False
                    )
                
                rating_msg = await interaction.channel.send(embed=rating_embed)
                
                for emoji in ["â­", "ğŸ‘", "ğŸ‘Œ", "âŒ", RATING_END_EMOJI]:
                    await rating_msg.add_reaction(emoji)
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("UPDATE evaluation_events SET rating_message_id = ? WHERE signup_message_id = ?", 
                             (rating_msg.id, signup_message.id))
                conn.commit()
                conn.close()
                
                print(f"âœ… è©•æ ¸éšæ®µå·²å‰µå»º: {event_name}, è©•æ ¸è¨Šæ¯ID: {rating_msg.id}")
                
            except Exception as e:
                print(f"ç°½åˆ°çµæŸè™•ç†éŒ¯èª¤: {e}")
        
        asyncio.create_task(signup_countdown())
        
        success_embed = discord.Embed(
            title="âœ… æ´»å‹•å‰µå»ºæˆåŠŸ",
            description=f"**æ´»å‹•åç¨±ï¼š** {event_name}\n**ç°½åˆ°æ™‚é–“ï¼š** {signup_time} åˆ†é˜\n**åƒèˆ‡æ–¹å¼ï¼š** æŒ‰ âœ… åæ‡‰ç°½åˆ°",
            color=discord.Color.green()
        )
        
        await interaction.followup.send(embed=success_embed, ephemeral=True)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæ´»å‹•å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 12: all_profiles (ç®¡ç†å“¡)
@bot.tree.command(name="all_profiles", description="æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™")
@app_commands.describe(
    sort_by="æ’åºæ–¹å¼",
    limit="é¡¯ç¤ºæ•¸é‡"
)
@app_commands.choices(sort_by=[
    app_commands.Choice(name="ç¾æœ‰ç©åˆ†(é«˜åˆ°ä½)", value="current_score"),
    app_commands.Choice(name="ç¸½ç²å¾—ç©åˆ†(é«˜åˆ°ä½)", value="total_score"),
    app_commands.Choice(name="åŠ å…¥æ—¥æœŸ(æ—©åˆ°æ™š)", value="join_date"),
    app_commands.Choice(name="æœ€å¾Œæ´»èº(è¿‘åˆ°é )", value="last_active"),
])
async def all_profiles_slash(
    interaction: discord.Interaction,
    sort_by: Optional[str] = "current_score",
    limit: Optional[int] = 20
):
    """æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        if limit > 50:
            limit = 50
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT user_id, username, current_score, total_score, join_date, 
                   last_active, activity_stats
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        processed_users = []
        current_period = get_current_half_month()
        
        for row in results:
            user_id, username, current_score, total_score, join_date, last_active, activity_str = row
            
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            current_period_data = activity_stats.get(current_period, {})
            total_events = current_period_data.get("total", 0)
            attended_events = current_period_data.get("attended", 0)
            current_attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
            
            processed_users.append({
                "user_id": user_id,
                "username": username,
                "current_score": current_score,
                "total_score": total_score,
                "join_date": join_date,
                "last_active": last_active,
                "current_attendance_rate": current_attendance_rate,
                "total_events": total_events,
                "attended_events": attended_events,
            })
        
        sort_functions = {
            "current_score": lambda x: x["current_score"],
            "total_score": lambda x: x["total_score"],
            "join_date": lambda x: x["join_date"],
            "last_active": lambda x: x["last_active"],
        }
        
        reverse_order = {
            "current_score": True,
            "total_score": True,
            "join_date": False,
            "last_active": True,
        }
        
        sort_func = sort_functions.get(sort_by, lambda x: x["current_score"])
        reverse = reverse_order.get(sort_by, True)
        
        sorted_users = sorted(processed_users, key=sort_func, reverse=reverse)
        display_users = sorted_users[:limit]
        
        total_users = len(display_users)
        total_current_score = sum(u["current_score"] for u in display_users)
        total_total_score = sum(u["total_score"] for u in display_users)
        avg_current_score = total_current_score / total_users if total_users > 0 else 0
        
        profiles_per_page = 10
        pages = []
        
        for i in range(0, len(display_users), profiles_per_page):
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™ç¸½è¦½",
                description=f"é¡¯ç¤º {min(i + profiles_per_page, len(display_users))}/{len(display_users)} ä½ç”¨æˆ¶",
                color=0x43B581
            )
            
            embed.add_field(
                name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                      f"**ç¸½ç¾æœ‰ç©åˆ†ï¼š** {total_current_score} åˆ†\n"
                      f"**ç¸½æ­·å²ç©åˆ†ï¼š** {total_total_score} åˆ†\n"
                      f"**å¹³å‡ç¾æœ‰ç©åˆ†ï¼š** {avg_current_score:.1f} åˆ†",
                inline=False
            )
            
            user_list = ""
            for user in display_users[i:i + profiles_per_page]:
                user_id = user["user_id"]
                username = user["username"]
                
                discord_user = interaction.guild.get_member(user_id)
                display_name = discord_user.display_name if discord_user else username
                
                user_list += f"**{display_name}**\n"
                user_list += f"  ğŸ”¹ ç¾æœ‰ç©åˆ†ï¼š{user['current_score']}åˆ†\n"
                user_list += f"  ğŸ“Š ç¸½ç©åˆ†ï¼š{user['total_score']}åˆ†\n"
                user_list += f"  ğŸ“Š å‡ºå¸­ç‡ï¼š{user['current_attendance_rate']:.1f}%\n"
                user_list += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ‘¥ ç”¨æˆ¶åˆ—è¡¨",
                value=user_list if user_list else "ç„¡ç”¨æˆ¶è³‡æ–™",
                inline=False
            )
            
            embed.set_footer(text=f"é é¢ {i//profiles_per_page + 1}/{(len(display_users)-1)//profiles_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            current_page = 0
            
            class ProfilesPaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = ProfilesPaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–ç”¨æˆ¶è³‡æ–™å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 13: attendance_stats (ç®¡ç†å“¡)
@bot.tree.command(name="attendance_stats", description="æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ")
@app_commands.describe(
    period="çµ±è¨ˆæœŸé–“",
    min_events="æœ€ä½æ´»å‹•æ¬¡æ•¸"
)
@app_commands.choices(period=[
    app_commands.Choice(name="ç•¶å‰åŠæœˆæœŸ", value="current"),
    app_commands.Choice(name="æ‰€æœ‰æœŸé–“", value="all"),
])
async def attendance_stats_slash(
    interaction: discord.Interaction,
    period: Optional[str] = "current",
    min_events: Optional[int] = 3
):
    """æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT user_id, username, activity_stats
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        current_period = get_current_half_month()
        attendance_data = []
        
        for user_id, username, activity_str in results:
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            if period == "current":
                period_data = activity_stats.get(current_period, {})
                total_events = period_data.get("total", 0)
                attended_events = period_data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": current_period
                    })
            
            else:  # "all"
                total_events = 0
                attended_events = 0
                
                for data in activity_stats.values():
                    total_events += data.get("total", 0)
                    attended_events += data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": "æ‰€æœ‰æœŸé–“"
                    })
        
        attendance_data.sort(key=lambda x: x["attendance_rate"], reverse=True)
        
        total_users = len(attendance_data)
        if total_users == 0:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description=f"æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ç”¨æˆ¶ï¼ˆæœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ï¼‰",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        avg_attendance_rate = sum(d["attendance_rate"] for d in attendance_data) / total_users
        perfect_attendance = sum(1 for d in attendance_data if d["attendance_rate"] == 100)
        
        users_per_page = 15
        pages = []
        
        for i in range(0, len(attendance_data), users_per_page):
            embed = discord.Embed(
                title=f"ğŸ“Š å‡ºå¸­ç‡æ’è¡Œæ¦œ - {attendance_data[0]['period']}",
                description=f"é¡¯ç¤º {min(i + users_per_page, len(attendance_data))}/{len(attendance_data)} ä½ç”¨æˆ¶",
                color=0x3498DB
            )
            
            embed.add_field(
                name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                      f"**å¹³å‡å‡ºå¸­ç‡ï¼š** {avg_attendance_rate:.1f}%\n"
                      f"**å…¨å‹¤ç”¨æˆ¶ï¼š** {perfect_attendance} äºº (100%)",
                inline=False
            )
            
            leaderboard = ""
            for j, data in enumerate(attendance_data[i:i + users_per_page], i + 1):
                medal = "ğŸ¥‡ " if j == 1 else "ğŸ¥ˆ " if j == 2 else "ğŸ¥‰ " if j == 3 else f"{j}. "
                
                discord_user = interaction.guild.get_member(data["user_id"])
                display_name = discord_user.display_name if discord_user else data["username"]
                
                leaderboard += f"{medal}**{display_name}**\n"
                leaderboard += f"   å‡ºå¸­ç‡ï¼š{data['attendance_rate']:.1f}% "
                leaderboard += f"({data['attended_events']}/{data['total_events']}æ¬¡)\n"
                
                if j % 5 == 0:
                    leaderboard += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ† å‡ºå¸­ç‡æ’è¡Œæ¦œ",
                value=leaderboard,
                inline=False
            )
            
            embed.set_footer(text=f"æœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ | é é¢ {i//users_per_page + 1}/{(len(attendance_data)-1)//users_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            class AttendancePaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = AttendancePaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å‡ºå¸­ç‡å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# é¡å¤–æŒ‡ä»¤: ping
@bot.tree.command(name="ping", description="æ¸¬è©¦æ©Ÿå™¨äººå»¶é²")
async def ping_slash(interaction: discord.Interaction):
    """æ¸¬è©¦å»¶é²"""
    latency = round(bot.latency * 1000)
    
    embed = discord.Embed(
        title="ğŸ“ Pong!",
        description=f"æ©Ÿå™¨äººå»¶é²: **{latency}ms**",
        color=discord.Color.green() if latency < 100 else discord.Color.orange() if latency < 300 else discord.Color.red()
    )
    
    await interaction.response.send_message(embed=embed)

# ========== ä¸»ç¨‹å¼ ==========

def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    print(f"{'='*50}")
    print(f"ğŸš€ å•Ÿå‹• {BOT_NAME} - å®Œæ•´åŠŸèƒ½ç‰ˆæœ¬")
    print(f"ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´")
    print(f"ğŸ”§ æ“æœ‰è€…ID: {OWNER_IDS}")
    print(f"ğŸ“ è³‡æ–™åº«ä½ç½®: {DB_NAME}")
    print(f"ğŸ“‹ ç¸½æŒ‡ä»¤æ•¸: 13å€‹")
    print(f"{'='*50}")
    
    # å¾ç’°å¢ƒè®Šæ•¸è®€å– Token
    token = os.getenv("DISCORD_TOKEN")
    
    if not token or token == "ä½ çš„_bot_token_åœ¨é€™è£¡":
        print("âŒ æ‰¾ä¸åˆ°æœ‰æ•ˆçš„ Tokenï¼")
        print("ğŸ’¡ è«‹åœ¨ Railway è¨­å®šç’°å¢ƒè®Šæ•¸ï¼š")
        print("   1. é€²å…¥ Railway å°ˆæ¡ˆ")
        print("   2. é»æ“Š Settings")
        print("   3. é»æ“Š Variables")
        print("   4. æ–°å¢ DISCORD_TOKEN = ä½ çš„_bot_token")
        sys.exit(1)
    
    print("âœ… Token è®€å–æˆåŠŸ")
    print("ğŸ”„ æ­£åœ¨é€£æ¥ Discord...")
    
    try:
        bot.run(token)
    except discord.LoginFailure:
        print("âŒ ç™»å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º")
        print("ğŸ’¡ è«‹åˆ° Discord Developer Portal é‡ç½® Token")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")

if __name__ == "__main__":
    main()
é€™å€‹å®Œæ•´ç‰ˆæœ¬åŒ…å«ï¼š
13å€‹å®Œæ•´æŒ‡ä»¤ï¼š
/help - é¡¯ç¤ºå¹«åŠ©è¨Šæ¯

/sync - åŒæ­¥æ–œæ§“æŒ‡ä»¤ï¼ˆæ“æœ‰è€…å°ˆç”¨ï¼‰

/profile - æŸ¥çœ‹æˆ‘çš„æ•¸æ“š

/giveaway - å‰µå»ºæŠ½çæ´»å‹•

/score_draw - ä½¿ç”¨ç©åˆ†æŠ½ç

/score_transfer - è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶

/prizelist - æŸ¥çœ‹å½©æ± åˆ—è¡¨

/random_team - éš¨æ©Ÿåˆ†çµ„

/add_prize - æ·»åŠ çå“åˆ°å½©æ± ï¼ˆç®¡ç†å“¡ï¼‰

/add_score - èª¿æ•´ç”¨æˆ¶ç©åˆ†ï¼ˆç®¡ç†å“¡ï¼‰

/create_event - å‰µå»ºè©•æ ¸æ´»å‹•ï¼ˆç®¡ç†å“¡ï¼‰

/all_profiles - æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™ï¼ˆç®¡ç†å“¡ï¼‰

/attendance_stats - æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆï¼ˆç®¡ç†å“¡ï¼‰

/ping - æ¸¬è©¦æ©Ÿå™¨äººå»¶é²ï¼ˆé¡å¤–æŒ‡ä»¤ï¼‰

ä¸»è¦ç‰¹é»ï¼š
å®Œæ•´è³‡æ–™åº«ç³»çµ± - åŒ…å«æ‰€æœ‰å¿…è¦çš„è¡¨æ ¼

è©•æ ¸æ´»å‹•ç³»çµ± - å®Œæ•´çš„ç°½åˆ°ã€è·æ¥­é¸æ“‡ã€è©•æ ¸æµç¨‹

ç©åˆ†ç³»çµ± - ç°½åˆ°ç©åˆ†ã€è·æ¥­åŠ æˆã€è©•æ ¸çå‹µ

æŠ½çç³»çµ± - è‡ªå‹•æŠ½çã€ç©åˆ†æŠ½ç

ç”¨æˆ¶çµ±è¨ˆ - å€‹äººè³‡æ–™ã€è·æ¥­çµ±è¨ˆã€è©•æ ¸çµ±è¨ˆ

ç®¡ç†å“¡åŠŸèƒ½ - å®Œæ•´çš„ç®¡ç†å·¥å…·

ä½¿ç”¨èªªæ˜ï¼š
è¤‡è£½å®Œæ•´ç¨‹å¼ç¢¼åˆ°æ‚¨çš„ main.py æª”æ¡ˆ

ç¢ºä¿ Railway ç’°å¢ƒè®Šæ•¸ DISCORD_TOKEN å·²æ­£ç¢ºè¨­ç½®

é‡æ–°éƒ¨ç½²åˆ° Railway

ç­‰å¾…æŒ‡ä»¤åŒæ­¥ï¼ˆå¯èƒ½éœ€è¦å¹¾åˆ†é˜ï¼‰

ä½¿ç”¨ /help æŸ¥çœ‹æ‰€æœ‰å¯ç”¨æŒ‡ä»¤

é€™å€‹ç‰ˆæœ¬å·²ç¶“ä¿®å¾©äº†æŒ‡ä»¤åŒæ­¥å•é¡Œï¼Œä¸¦ç¢ºä¿æ‰€æœ‰13å€‹æŒ‡ä»¤éƒ½èƒ½æ­£å¸¸é‹ä½œï¼

æˆ‘æ˜¯ç›´æ¥åœ¨hubgitæ›´æ”¹ä»£ç¢¼çš„
ç¾åœ¨æƒ…æ³é‚„æ˜¯0å€‹æŒ‡ä»¤, è«‹å•ä½ éœ€è¦æˆ‘çµ¦ä½ ä»¥å‰æˆåŠŸ11å€‹æŒ‡ä»¤çš„
å†å°æ¯”ç¾åœ¨13å€‹æŒ‡ä»¤ä½†éƒ½æ˜¯å¤±æ•—çš„
æ‚¨æåˆ°ä¸€å€‹å¾ˆå¥½çš„å•é¡Œï¼å°æ¯”æˆåŠŸç‰ˆæœ¬å’Œå¤±æ•—ç‰ˆæœ¬å¯ä»¥å¹«åŠ©æˆ‘å€‘æ‰¾åˆ°å•é¡Œã€‚æ˜¯çš„ï¼Œè«‹æä¾›ï¼š

ä»¥å‰æˆåŠŸ11å€‹æŒ‡ä»¤çš„ç¨‹å¼ç¢¼

ç¾åœ¨13å€‹æŒ‡ä»¤ä½†å¤±æ•—çš„ç¨‹å¼ç¢¼

é€™æ¨£æˆ‘å¯ä»¥ï¼š

å°æ¯”å…©å€‹ç‰ˆæœ¬çš„å·®ç•°

æ‰¾å‡ºå°è‡´æŒ‡ä»¤åŒæ­¥å¤±æ•—çš„å•é¡Œ

æä¾›ä¸€å€‹èƒ½æ­£å¸¸å·¥ä½œçš„å®Œæ•´ç‰ˆæœ¬

é€šå¸¸æŒ‡ä»¤åŒæ­¥å¤±æ•—çš„åŸå› æœ‰ï¼š

æŒ‡ä»¤è¨»å†Šæ™‚æ©Ÿå•é¡Œ - åœ¨ on_ready() ä¸­åŒæ­¥ vs åœ¨ setup_hook() ä¸­åŒæ­¥

æ¬Šé™å•é¡Œ - æ©Ÿå™¨äººç¼ºå°‘ applications.commands ç¯„åœ

æŒ‡ä»¤å®šç¾©æ ¼å¼å•é¡Œ - å¯èƒ½æœ‰æŸå€‹æŒ‡ä»¤çš„åƒæ•¸è¨­å®šéŒ¯èª¤

Discord API é™åˆ¶ - è¶…éæŒ‡ä»¤æ•¸é‡æˆ–åç¨±é•·åº¦é™åˆ¶

è«‹å…ˆæä¾›å…©å€‹ç‰ˆæœ¬çš„ç¨‹å¼ç¢¼ï¼Œæˆ‘æœƒå¹«æ‚¨ï¼š

åˆ†æå·®ç•°

æ‰¾å‡ºæ ¹æœ¬åŸå› 

çµ¦æ‚¨ä¸€å€‹ä¿è­‰èƒ½å·¥ä½œçš„ç‰ˆæœ¬

æˆ–è€…ï¼Œæˆ‘å¯ä»¥å…ˆçµ¦æ‚¨ä¸€å€‹ç¶“éæ¸¬è©¦çš„è§£æ±ºæ–¹æ¡ˆï¼š

python
# åœ¨ main() å‡½æ•¸å‰æ·»åŠ é€™è¡Œä¾†æª¢æŸ¥æŒ‡ä»¤è¨»å†Šæƒ…æ³
@bot.event
async def on_connect():
    """é€£æ¥æˆåŠŸæ™‚åŸ·è¡Œ"""
    print("âœ… å·²æˆåŠŸé€£æ¥ Discordï¼")
    print("ğŸ”„ æº–å‚™è¨»å†ŠæŒ‡ä»¤...")
    
    # å»¶é²ä¸€ä¸‹å†åŒæ­¥æŒ‡ä»¤
    await asyncio.sleep(2)
    
    # å¼·åˆ¶æ¸…é™¤æ‰€æœ‰æŒ‡ä»¤å†é‡æ–°è¨»å†Š
    bot.tree.clear_commands(guild=None)
    
    # è¨»å†Šæ‰€æœ‰æŒ‡ä»¤åˆ°æ©Ÿå™¨äºº
    for cmd in bot.tree.walk_commands():
        print(f"  â€¢ /{cmd.name} - {cmd.description}")
    
    try:
        synced = await bot.tree.sync()
        print(f"âœ… å·²è¨»å†Š {len(synced)} å€‹æŒ‡ä»¤")
    except Exception as e:
        print(f"âŒ æŒ‡ä»¤åŒæ­¥å¤±æ•—: {e}")
ä½†æœ€å¥½çš„æ–¹æ³•é‚„æ˜¯è®“æˆ‘çœ‹åˆ°æ‚¨çš„å…©å€‹ç‰ˆæœ¬ï¼Œé€™æ¨£å¯ä»¥ç²¾æº–æ‰¾å‡ºå•é¡Œæ‰€åœ¨ã€‚

è«‹æä¾›ä»¥ä¸‹è³‡è¨Šï¼š

æ‚¨ä¿®æ”¹å¾Œçš„å®Œæ•´ç¨‹å¼ç¢¼ï¼ˆç›®å‰å¤±æ•—çš„13å€‹æŒ‡ä»¤ç‰ˆæœ¬ï¼‰

å¦‚æœå¯ä»¥çš„è©±ï¼Œä¹‹å‰æˆåŠŸ11å€‹æŒ‡ä»¤çš„ç‰ˆæœ¬

é€™æ¨£æˆ‘å¯ä»¥é€²è¡Œè©³ç´°çš„å·®ç•°åˆ†æï¼Œæ‰¾å‡ºç¢ºåˆ‡çš„å•é¡Œé»ï¼

é€™æ˜¯æˆåŠŸçš„11å€‹æŒ‡ä»¤
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å°é›²ALBIONæ©Ÿæ¢°äºº - ç°¡åŒ–è©•æ ¸ç‰ˆæœ¬
ä¸»æŒäººæŒ‰EMOJIè©•æ ¸ï¼Œé è¨­ç‚ºæ™®é€šè©•ç´š
"""

import os
import discord
from discord.ext import commands
from discord import app_commands
import sys
import asyncio
import json
import random
from datetime import datetime, timedelta
from typing import Optional, List
import sqlite3
import time

# ========== è¨­å®š ==========
BOT_NAME = "å°é›²æ©Ÿæ¢°äºº"
OWNER_IDS = [337237662157242368]  # ä½ çš„ Discord ID

# è·æ¥­å°æ‡‰çš„EMOJI
PROFESSION_EMOJIS = {
    "ğŸ›¡ï¸": "å¦å…‹",
    "âš”ï¸": "è¾“å‡º", 
    "ğŸ’š": "æ²»ç–—",
    "ğŸ’›": "è¾…åŠ©"
}

# è©•æ ¸è©•åˆ†é¸é …
RATING_EMOJIS = {
    "â­": "å„ªç§€",
    "ğŸ‘": "è‰¯å¥½", 
    "ğŸ‘Œ": "æ™®é€š",  # é è¨­è©•ç´š
    "âŒ": "ä¸åˆæ ¼"
}

# è©•æ ¸çµæŸEMOJI
RATING_END_EMOJI = "ğŸ"

# ========== ç©åˆ†è¨­å®š ==========
SIGNUP_SCORE = 40  # ç°½åˆ°ç©åˆ†
PROFESSION_BONUS = {
    "å¦å…‹": 0,
    "è¾“å‡º": 0,
    "æ²»ç–—": 20,  # è£œå¸«+20ç©åˆ†
    "è¾…åŠ©": 0
}
RATING_SCORES = {
    "å„ªç§€": 40,    # å„ªç§€+40ç©åˆ†
    "è‰¯å¥½": 10,    # è‰¯å¥½+10ç©åˆ†
    "æ™®é€š": 0,     # æ™®é€š+0ç©åˆ†
    "ä¸åˆæ ¼": -5   # ä¸åˆæ ¼-5ç©åˆ†
}

# Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True
intents.presences = True

bot = commands.Bot(
    command_prefix='!',
    intents=intents,
    help_command=None,
    case_insensitive=True
)

tree = bot.tree

# ========== è³‡æ–™åº«è¨­å®š ==========
DB_NAME = "bot_data.db"

def init_db():
    """åˆå§‹åŒ–è³‡æ–™åº«"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # ç”¨æˆ¶è³‡æ–™è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        total_score INTEGER DEFAULT 0,
        current_score INTEGER DEFAULT 0,
        join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        profession_counts TEXT DEFAULT '{}',
        activity_stats TEXT DEFAULT '{}',
        rating_stats TEXT DEFAULT '{}'
    )
    ''')
    
    # å½©æ± è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS prize_pool (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        prize_name TEXT NOT NULL,
        box_level TEXT NOT NULL,
        quantity INTEGER DEFAULT 1,
        remaining INTEGER DEFAULT 1,
        added_by INTEGER,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(prize_name, box_level)
    )
    ''')
    
    # æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS giveaways (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        prize TEXT,
        winner_count INTEGER DEFAULT 1,
        participants TEXT DEFAULT '[]',
        winners TEXT DEFAULT '[]',
        end_time TIMESTAMP,
        message_id INTEGER,
        channel_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_draws (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        score_cost INTEGER,
        box_level TEXT,
        participants TEXT DEFAULT '[]',
        winner_prize TEXT,
        winner_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†è½‰ç§»ç´€éŒ„
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_transfers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_user_id INTEGER,
        to_user_id INTEGER,
        amount INTEGER,
        reason TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # è©•æ ¸æ´»å‹•
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS evaluation_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        event_name TEXT,
        creator_id INTEGER,
        signup_message_id INTEGER,
        profession_message_id INTEGER,
        rating_message_id INTEGER,
        channel_id INTEGER,
        participants TEXT DEFAULT '[]',
        default_rated TEXT DEFAULT '[]',   --å·²é è¨­è©•ç´šçš„ç”¨æˆ¶
        professions TEXT DEFAULT '{}',
        ratings TEXT DEFAULT '{}',
        is_active BOOLEAN DEFAULT 1,
        start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        signup_end_time TIMESTAMP
    )
    ''')
    
    # æ·»åŠ ç¤ºä¾‹çå“
    sample_prizes = [
        ("æ™®é€šæ­¦å™¨", "ç¶ ç®±", 20),
        ("æ™®é€šè£å‚™", "ç¶ ç®±", 15),
        ("åˆç´šè—¥æ°´", "ç¶ ç®±", 30),
        ("ä¸­ç´šæ­¦å™¨", "è—ç®±", 10),
        ("ä¸­ç´šè£å‚™", "è—ç®±", 8),
        ("ä¸­ç´šè—¥æ°´", "è—ç®±", 15),
        ("é«˜ç´šæ­¦å™¨", "ç´«ç®±", 5),
        ("é«˜ç´šè£å‚™", "ç´«ç®±", 4),
        ("é«˜ç´šè—¥æ°´", "ç´«ç®±", 6),
        ("å‚³å¥‡æ­¦å™¨", "é‡‘ç®±", 2),
        ("å‚³å¥‡è£å‚™", "é‡‘ç®±", 1),
        ("å‚³èªªè—¥æ°´", "é‡‘ç®±", 3),
    ]
    
    for prize_name, box_level, quantity in sample_prizes:
        cursor.execute('''
            INSERT OR IGNORE INTO prize_pool (prize_name, box_level, quantity, remaining)
            VALUES (?, ?, ?, ?)
        ''', (prize_name, box_level, quantity, quantity))
    
    conn.commit()
    conn.close()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")

# ========== é€šç”¨å‡½æ•¸ ==========

def get_user_score(user_id):
    """å–å¾—ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        return result[0], result[1]
    return 0, 0

def update_user_score(user_id, username, amount, reason=""):
    """æ›´æ–°ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if not cursor.fetchone():
        cursor.execute(
            "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
            (user_id, username, max(amount, 0), max(amount, 0))
        )
    else:
        cursor.execute("UPDATE users SET current_score = current_score + ? WHERE user_id = ?", (amount, user_id))
        if amount > 0:
            cursor.execute("UPDATE users SET total_score = total_score + ? WHERE user_id = ?", (amount, user_id))
        cursor.execute("UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE user_id = ?", (user_id,))
    
    if amount < 0 or reason:
        cursor.execute(
            "INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason) VALUES (?, ?, ?, ?)",
            (user_id if amount < 0 else None, 
             user_id if amount > 0 else None, 
             abs(amount), 
             reason if reason else ("ç³»çµ±æ‰£é™¤" if amount < 0 else "ç³»çµ±å¢åŠ "))
        )
    
    conn.commit()
    conn.close()

def get_user_profile(user_id):
    """ç²å–ç”¨æˆ¶å®Œæ•´è³‡æ–™"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score, join_date, profession_counts, activity_stats, rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        current_score, total_score, join_date, profession_str, activity_str, rating_str = result
        
        try:
            join_date_str = datetime.strptime(join_date.split('.')[0], '%Y-%m-%d %H:%M:%S').strftime('%Y-%m-%d')
        except:
            join_date_str = join_date
        
        profession_counts = json.loads(profession_str) if profession_str else {}
        activity_stats = json.loads(activity_str) if activity_str else {}
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        return {
            'user_id': user_id,
            'current_score': current_score,
            'total_score': total_score,
            'join_date': join_date_str,
            'profession_counts': profession_counts,
            'activity_stats': activity_stats,
            'rating_stats': rating_stats
        }
    
    return None

def update_user_profession(user_id, profession):
    """æ›´æ–°ç”¨æˆ¶è·æ¥­çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT profession_counts FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        profession_str = result[0]
        profession_counts = json.loads(profession_str) if profession_str else {}
        
        if profession in profession_counts:
            profession_counts[profession] += 1
        else:
            profession_counts[profession] = 1
        
        bonus_score = PROFESSION_BONUS.get(profession, 0)
        if bonus_score > 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("UPDATE users SET current_score = current_score + ?, total_score = total_score + ? WHERE user_id = ?", 
                         (bonus_score, bonus_score, user_id))
        
        cursor.execute("UPDATE users SET profession_counts = ? WHERE user_id = ?", 
                      (json.dumps(profession_counts), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_activity(user_id, event_name, attended=True):
    """æ›´æ–°ç”¨æˆ¶æ´»å‹•çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT activity_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        activity_str = result[0]
        activity_stats = json.loads(activity_str) if activity_str else {}
        
        # ç²å–ç•¶å‰åŠæœˆæœŸ
        now = datetime.now()
        year_month = now.strftime("%Y-%m")
        day = now.day
        current_period = f"{year_month}-ä¸ŠåŠ" if day <= 15 else f"{year_month}-ä¸‹åŠ"
        
        if current_period not in activity_stats:
            activity_stats[current_period] = {"total": 0, "attended": 0}
        
        activity_stats[current_period]["total"] += 1
        if attended:
            activity_stats[current_period]["attended"] += 1
        
        cursor.execute("UPDATE users SET activity_stats = ? WHERE user_id = ?", 
                      (json.dumps(activity_stats), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_rating(user_id, rating_type):
    """æ›´æ–°ç”¨æˆ¶è©•æ ¸çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        rating_str = result[0]
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        if rating_type in rating_stats:
            rating_stats[rating_type] += 1
        else:
            rating_stats[rating_type] = 1
        
        score = RATING_SCORES.get(rating_type, 0)
        
        if score != 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("""
                UPDATE users 
                SET current_score = current_score + ?, 
                    total_score = CASE 
                                    WHEN total_score + ? > 0 THEN total_score + ?
                                    ELSE 0
                                  END
                WHERE user_id = ?
            """, (score, score, score, user_id))
        
        # ä¿®å¾©ï¼šæ›´æ–°è©•ç´šçµ±è¨ˆæ•¸æ“šåˆ°è³‡æ–™åº«
        cursor.execute("UPDATE users SET rating_stats = ? WHERE user_id = ?", 
                      (json.dumps(rating_stats), user_id))
        
        conn.commit()
    
    conn.close()

def get_current_half_month():
    """ç²å–ç•¶å‰åŠæœˆæœŸ"""
    now = datetime.now()
    year_month = now.strftime("%Y-%m")
    day = now.day
    
    if day <= 15:
        return f"{year_month}-ä¸ŠåŠ"
    else:
        return f"{year_month}-ä¸‹åŠ"

async def end_giveaway(message_id: int, manual: bool = False):
    """çµæŸæŠ½ç"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, creator_id, prize, winner_count, participants, winners, channel_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (message_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        giveaway_id, creator_id, prize, winner_count, participants_json, winners_json, channel_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        channel = bot.get_channel(channel_id)
        
        if not channel:
            conn.close()
            return
        
        try:
            message = await channel.fetch_message(message_id)
        except:
            conn.close()
            return
        
        if participants:
            if len(participants) <= winner_count:
                winners_list = participants
            else:
                winners_list = random.sample(participants, winner_count)
            
            cursor.execute("UPDATE giveaways SET winners = ?, is_active = 0 WHERE id = ?", 
                         (json.dumps(winners_list), giveaway_id))
            conn.commit()
            
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ ğŸ‰",
                description="é–‹çå®Œæˆï¼",
                color=0x00FF00
            )
            
            new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
            new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(len(winners_list)), inline=True)
            new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
            
            winners_text = ""
            for i, winner_id in enumerate(winners_list[:5], 1):
                winners_text += f"{i}. <@{winner_id}>\n"
            
            if len(winners_list) > 5:
                winners_text += f"... é‚„æœ‰ {len(winners_list) - 5} äºº"
            
            if winners_text:
                new_embed.add_field(name="ğŸ† ç²çè€…", value=winners_text, inline=False)
            
            await message.edit(embed=new_embed)
            await message.clear_reactions()
            
            for winner_id in winners_list:
                await channel.send(f"ğŸ‰ æ­å–œ <@{winner_id}> ç²å¾—äº† **{prize}**ï¼")
        else:
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ",
                description="ç„¡äººåƒèˆ‡æŠ½ç" + ("ï¼ˆæ‰‹å‹•çµæŸï¼‰" if manual else ""),
                color=0xFF0000
            )
            await message.edit(embed=new_embed)
            await message.clear_reactions()
        
        conn.close()
        
    except Exception as e:
        print(f"çµæŸæŠ½çéŒ¯èª¤: {e}")

async def end_evaluation(event_id, channel, event_name):
    """çµæŸè©•æ ¸æ´»å‹•"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # ç²å–æ´»å‹•æ•¸æ“š
        cursor.execute("""
            SELECT participants, professions, ratings, rating_message_id 
            FROM evaluation_events 
            WHERE id = ?
        """, (event_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        participants_json, professions_json, ratings_json, rating_message_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        professions = json.loads(professions_json) if professions_json else {}
        ratings = json.loads(ratings_json) if ratings_json else {}
        
        # æ¨™è¨˜æ´»å‹•ç‚ºä¸æ´»èº
        cursor.execute("UPDATE evaluation_events SET is_active = 0 WHERE id = ?", (event_id,))
        conn.commit()
        conn.close()
        
        # å˜—è©¦æ¸…é™¤è©•æ ¸è¨Šæ¯çš„åæ‡‰
        try:
            rating_message = await channel.fetch_message(rating_message_id)
            await rating_message.clear_reactions()
            
            # æ›´æ–°è©•æ ¸è¨Šæ¯
            end_embed = discord.Embed(
                title=f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸï¼š{event_name}",
                description="æ­¤æ´»å‹•çš„è©•æ ¸éšæ®µå·²ç¶“çµæŸï¼Œæ„Ÿè¬æ‰€æœ‰åƒèˆ‡è€…ï¼",
                color=discord.Color.green()
            )
            
            end_embed.add_field(name="ğŸ“Š çµ±è¨ˆä¿¡æ¯", value=f"**ç¸½åƒèˆ‡äººæ•¸ï¼š** {len(participants)} äºº", inline=False)
            
            # é¡¯ç¤ºè©•ç´šåˆ†ä½ˆ
            rating_summary = {}
            for user_id, rating_list in ratings.items():
                if rating_list:
                    latest_rating = rating_list[-1]["rating"]
                    rating_summary[latest_rating] = rating_summary.get(latest_rating, 0) + 1
            
            rating_text = ""
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_summary.get(rating_type, 0)
                if count > 0:
                    rating_text += f"**{rating_type}ï¼š** {count}äºº\n"
            
            if rating_text:
                end_embed.add_field(name="â­ è©•ç´šåˆ†ä½ˆ", value=rating_text, inline=False)
            
            await rating_message.edit(embed=end_embed)
            
        except Exception as e:
            print(f"æ›´æ–°è©•æ ¸è¨Šæ¯éŒ¯èª¤: {e}")
        
        # ç™¼é€çµæŸé€šçŸ¥
        summary_embed = discord.Embed(
            title=f"ğŸ æ´»å‹•ç¸½çµï¼š{event_name}",
            description="è©•æ ¸æ´»å‹•å·²æ­£å¼çµæŸï¼",
            color=discord.Color.gold()
        )
        
        summary_embed.add_field(name="ğŸ‘¥ åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ® è·æ¥­é¸æ“‡", value=f"{len(professions)} äºº", inline=True)
        summary_embed.add_field(name="â­ è©•æ ¸å®Œæˆ", value=f"{len(ratings)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ“Š è©•ç´šåˆ†ä½ˆ", value=f"{len(rating_summary)} ç¨®è©•ç´š", inline=True)
        
        await channel.send(embed=summary_embed)
        
        print(f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸ: {event_name}")
        
    except Exception as e:
        print(f"çµæŸè©•æ ¸æ´»å‹•éŒ¯èª¤: {e}")

# ========== åŒæ­¥æŒ‡ä»¤ ==========

@tree.command(name="sync", description="åŒæ­¥æ–œæ§“æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰")
async def sync_slash(interaction: discord.Interaction):
    """åŒæ­¥æŒ‡ä»¤"""
    await interaction.response.defer(ephemeral=True)
    
    if interaction.user.id not in OWNER_IDS:
        embed = discord.Embed(
            title="âŒ æ¬Šé™ä¸è¶³",
            description="åªæœ‰æ©Ÿå™¨äººæ“æœ‰è€…å¯ä»¥ä½¿ç”¨æ­¤æŒ‡ä»¤",
            color=0xFF0000
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        return
    
    try:
        global_synced = await tree.sync()
        
        embed = discord.Embed(
            title="ğŸ”„ æŒ‡ä»¤åŒæ­¥å®Œæˆ",
            description=f"å·²åŒæ­¥ {len(global_synced)} å€‹æŒ‡ä»¤",
            color=0x43B581
        )
        
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åŒæ­¥å¤±æ•—",
            description=f"éŒ¯èª¤è¨Šæ¯: {str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed, ephemeral=True)

# ========== ç”¨æˆ¶æŒ‡ä»¤ ==========

@tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯ / å¹«åŠ©")
async def help_slash(interaction: discord.Interaction):
    """é¡¯ç¤ºå¹«åŠ©"""
    embed = discord.Embed(
        title="ğŸ¤– å°é›²æ©Ÿæ¢°äºº - å¹«åŠ©ä¸­å¿ƒ",
        description="ä»¥ä¸‹æ˜¯å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ï¼š",
        color=0x7289DA
    )
    
    embed.add_field(
        name="ğŸ‘¤ ç”¨æˆ¶æŒ‡ä»¤",
        value=(
            "`/help` - é¡¯ç¤ºæ­¤å¹«åŠ©è¨Šæ¯\n"
            "`/profile` - æŸ¥çœ‹æˆ‘çš„æ•¸æ“š\n"
            "`/giveaway [çå“] [æ™‚é–“]` - å‰µå»ºæŠ½ç\n"
            "`/score_draw` - ä½¿ç”¨ç©åˆ†æŠ½ç\n"
            "`/score_transfer [ç”¨æˆ¶] [ç©åˆ†]` - è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶\n"
            "`/prizelist` - æŸ¥çœ‹å½©æ± åˆ—è¡¨\n"
            "`/random_team [äººæ•¸] [çµ„æ•¸]` - éš¨æ©Ÿåˆ†çµ„"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ› ï¸ ç®¡ç†å“¡æŒ‡ä»¤",
        value=(
            "`/add_prize [åç¨±] [é¡å‹] [æ•¸é‡]` - èª¿æ•´å½©æ± \n"
            "`/add_score [ç”¨æˆ¶] [ç©åˆ†] [åŸå› ]` - åŠ æ¸›ç©åˆ†\n"
            "`/create_event [æ´»å‹•åç¨±]` - å‰µå»ºè©•æ ¸æ´»å‹•"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ’° ç©åˆ†ç³»çµ±",
        value=(
            "**ç°½åˆ°çå‹µï¼š** 40ç©åˆ†\n"
            "**è·æ¥­åŠ æˆï¼š** è£œå¸«+20ç©åˆ†ï¼ˆå…¶ä»–è·æ¥­ç„¡åŠ æˆï¼‰\n"
            "**è©•æ ¸çå‹µï¼š**\n"
            "  â€¢ å„ªç§€ï¼š+40ç©åˆ†\n"
            "  â€¢ è‰¯å¥½ï¼š+10ç©åˆ†\n"
            "  â€¢ æ™®é€šï¼š+0ç©åˆ†ï¼ˆé è¨­ï¼‰\n"
            "  â€¢ ä¸åˆæ ¼ï¼š-5ç©åˆ†"
        ),
        inline=False
    )
    
    embed.set_footer(text="ä½¿ç”¨ / é–‹é ­è¼¸å…¥æŒ‡ä»¤")
    await interaction.response.send_message(embed=embed)

@tree.command(name="profile", description="æŸ¥çœ‹æˆ‘çš„æ•¸æ“š / æˆ‘çš„æ•¸æ“š")
async def profile_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        user_id = interaction.user.id
        username = interaction.user.name
        
        profile = get_user_profile(user_id)
        
        if not profile:
            conn = sqlite3.connect(DB_NAME)
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
                (user_id, username, 0, 0)
            )
            conn.commit()
            conn.close()
            
            profile = {
                'user_id': user_id,
                'current_score': 0,
                'total_score': 0,
                'join_date': datetime.now().strftime('%Y-%m-%d'),
                'profession_counts': {},
                'activity_stats': {},
                'rating_stats': {}
            }
        
        current_score = profile['current_score']
        total_score = profile['total_score']
        join_date_str = profile['join_date']
        profession_counts = profile['profession_counts']
        activity_stats = profile['activity_stats']
        rating_stats = profile['rating_stats']
        
        current_period = get_current_half_month()
        period_data = activity_stats.get(current_period, {})
        total_events = period_data.get('total', 0)
        attended_events = period_data.get('attended', 0)
        attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
        
        embed = discord.Embed(
            title=f"ğŸ“Š {username} çš„è©•æ ¸æ•¸æ“š",
            color=0x43B581
        )
        
        attendance_info = (
            f"**ç•¶å‰åŠæœˆæœŸï¼š** {current_period}\n"
            f"**ç¸½æ´»å‹•æ•¸ï¼š** {total_events} æ¬¡\n"
            f"**å¯¦éš›å‡ºå¸­ï¼š** {attended_events} æ¬¡\n"
            f"**å‡ºå¸­ç‡ï¼š** {attendance_rate:.1f}%\n\n"
            f"**è¨ˆç®—å…¬å¼ï¼š** (å¯¦éš›å‡ºå¸­æ¬¡æ•¸ Ã· ç¸½æ´»å‹•æ•¸) Ã— 100%\n"
            f"**è¨»ï¼š** åƒ…è¨ˆç®—æ´»å‹•æ™‚é–“å…§ç°½åˆ°ï¼Œéæ™‚ç°½åˆ°ä¸è¨ˆå…¥"
        )
        
        embed.add_field(
            name="ğŸ“… åŠæœˆæœŸå‡ºå¸­ç‡",
            value=attendance_info,
            inline=False
        )
        
        score_info = f"**ç•¶å‰ç©åˆ†ï¼š** {current_score} åˆ†\n"
        score_info += f"**ç¸½ç²å¾—ç©åˆ†ï¼š** {total_score} åˆ†\n"
        score_info += f"**ç¾æœ‰ç©åˆ†å¯ç”¨ï¼š** {current_score} åˆ†\n\n"
        score_info += f"**ç©åˆ†è¦å‰‡ï¼š**\n"
        score_info += f"â€¢ ç°½åˆ°ï¼š+{SIGNUP_SCORE}åˆ†\n"
        for profession, bonus in PROFESSION_BONUS.items():
            if bonus > 0:
                score_info += f"â€¢ {profession}ï¼š+{bonus}åˆ†\n"
        score_info += f"â€¢ å„ªç§€ï¼š+{RATING_SCORES['å„ªç§€']}åˆ†\n"
        score_info += f"â€¢ è‰¯å¥½ï¼š+{RATING_SCORES['è‰¯å¥½']}åˆ†\n"
        score_info += f"â€¢ æ™®é€šï¼š{RATING_SCORES['æ™®é€š']}åˆ†ï¼ˆé è¨­ï¼‰\n"
        score_info += f"â€¢ ä¸åˆæ ¼ï¼š{RATING_SCORES['ä¸åˆæ ¼']}åˆ†"
        
        embed.add_field(
            name="ğŸ’° ç©åˆ†çµ±è¨ˆ",
            value=score_info,
            inline=False
        )
        
        if profession_counts:
            profession_info = ""
            total_plays = sum(profession_counts.values())
            for profession, count in profession_counts.items():
                percentage = (count / total_plays * 100) if total_plays > 0 else 0
                profession_info += f"**{profession}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
        else:
            profession_info = "å°šæœªè¨˜éŒ„è·æ¥­æ•¸æ“š"
        
        embed.add_field(
            name="ğŸ® è·æ¥­çµ±è¨ˆ",
            value=profession_info,
            inline=False
        )
        
        if rating_stats:
            rating_info = ""
            total_ratings = sum(rating_stats.values())
            total_rating_score = 0
            
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_stats.get(rating_type, 0)
                if count > 0:
                    percentage = (count / total_ratings * 100) if total_ratings > 0 else 0
                    score = RATING_SCORES.get(rating_type, 0)
                    rating_info += f"**{rating_type}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
                    total_rating_score += count * score
            
            if total_ratings > 0:
                rating_info += f"\n**è©•æ ¸ç¸½ç²å¾—ç©åˆ†ï¼š** {total_rating_score} åˆ†"
        else:
            rating_info = "å°šæœªæœ‰è©•æ ¸è¨˜éŒ„"
        
        embed.add_field(
            name="â­ è©•æ ¸çµ±è¨ˆ",
            value=rating_info,
            inline=False
        )
        
        embed.add_field(name="ç”¨æˆ¶ID", value=f"`{user_id}`", inline=True)
        embed.add_field(name="åŠ å…¥æ—¥æœŸ", value=join_date_str, inline=True)
        embed.add_field(name="DiscordåŠ å…¥", value=interaction.user.created_at.strftime('%Y-%m-%d'), inline=True)
        
        if interaction.user.avatar:
            embed.set_thumbnail(url=interaction.user.avatar.url)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ ç™¼ç”ŸéŒ¯èª¤",
            description=f"ç„¡æ³•è®€å–ç”¨æˆ¶è³‡æ–™ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@tree.command(name="giveaway", description="å‰µå»ºæŠ½çæ´»å‹• / æŠ½ç")
@app_commands.describe(
    prize="çå“å…§å®¹",
    duration="æŠ½çæŒçºŒæ™‚é–“ï¼ˆä¾‹å¦‚ï¼š60s, 1m, 1h, 1dï¼‰",
    winners="ç²çäººæ•¸"
)
async def giveaway_slash(
    interaction: discord.Interaction,
    prize: str,
    duration: str = "1h",
    winners: int = 1
):
    """å‰µå»ºæŠ½ç"""
    await interaction.response.defer()
    
    try:
        # è§£ææ™‚é–“
        duration_lower = duration.lower().strip()
        seconds = 3600  # é è¨­1å°æ™‚
        
        if duration_lower.endswith('s'):
            seconds = int(duration_lower[:-1])
        elif duration_lower.endswith('m'):
            seconds = int(duration_lower[:-1]) * 60
        elif duration_lower.endswith('h'):
            seconds = int(duration_lower[:-1]) * 3600
        elif duration_lower.endswith('d'):
            seconds = int(duration_lower[:-1]) * 86400
        elif duration_lower.isdigit():
            seconds = int(duration_lower)
        
        if seconds < 10:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“å¿…é ˆè‡³å°‘10ç§’ï¼")
            return
        
        if seconds > 86400 * 7:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“ä¸èƒ½è¶…é7å¤©ï¼")
            return
        
        end_time = datetime.now() + timedelta(seconds=seconds)
        
        # æ ¼å¼åŒ–æ™‚é–“é¡¯ç¤º
        if seconds < 60:
            time_display = f"{seconds}ç§’"
        elif seconds < 3600:
            time_display = f"{seconds//60}åˆ†{seconds%60}ç§’"
        elif seconds < 86400:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            time_display = f"{hours}å°æ™‚{minutes}åˆ†"
        else:
            days = seconds // 86400
            hours = (seconds % 86400) // 3600
            time_display = f"{days}å¤©{hours}å°æ™‚"
        
        embed = discord.Embed(
            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
            color=0xFFD700
        )
        
        embed.add_field(name="ğŸ çå“", value=prize, inline=True)
        embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
        embed.add_field(name="â° çµæŸæ™‚é–“", value=time_display, inline=True)
        embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value="0 äºº", inline=True)
        embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
        embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
        
        creator_name = interaction.user.display_name
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
        giveaway_id = f"giveaway_{int(time.time())}_{random.randint(1000, 9999)}"
        
        embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{current_time}")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ«")
        await message.add_reaction("â¹ï¸")
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO giveaways (creator_id, prize, winner_count, end_time, message_id, channel_id)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (interaction.user.id, prize, winners, end_time, message.id, interaction.channel.id))
        conn.commit()
        conn.close()
        
        print(f"âœ… æŠ½çå·²å‰µå»º: çå“={prize}, æ™‚é–“={seconds}ç§’, è¨Šæ¯ID={message.id}")
        
        async def countdown_timer():
            remaining = seconds
            last_update = time.time()
            
            while remaining > 0:
                await asyncio.sleep(1)
                remaining -= 1
                
                if time.time() - last_update >= 30:
                    if remaining < 60:
                        time_display = f"{remaining}ç§’"
                    elif remaining < 3600:
                        time_display = f"{remaining//60}åˆ†{remaining%60}ç§’"
                    elif remaining < 86400:
                        hours = remaining // 3600
                        minutes = (remaining % 3600) // 60
                        time_display = f"{hours}å°æ™‚{minutes}åˆ†"
                    else:
                        days = remaining // 86400
                        hours = (remaining % 86400) // 3600
                        time_display = f"{days}å¤©{hours}å°æ™‚"
                    
                    try:
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        cursor.execute("SELECT participants FROM giveaways WHERE message_id = ?", (message.id,))
                        result = cursor.fetchone()
                        participants_count = 0
                        if result and result[0]:
                            participants = json.loads(result[0])
                            participants_count = len(participants)
                        conn.close()
                        
                        new_embed = discord.Embed(
                            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
                            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
                            color=0xFFD700
                        )
                        
                        new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
                        new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
                        new_embed.add_field(name="â° çµæŸæ™‚é–“", value=f"{time_display}å…§", inline=True)
                        new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{participants_count} äºº", inline=True)
                        new_embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
                        new_embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
                        
                        new_embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{datetime.now().strftime('%Y-%m-%d %H:%M')}")
                        
                        await message.edit(embed=new_embed)
                        last_update = time.time()
                        
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            await end_giveaway(message.id)
        
        asyncio.create_task(countdown_timer())
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)
        print(f"Giveaway error: {e}")

@tree.command(name="score_draw", description="ä½¿ç”¨ç©åˆ†æŠ½ç / ç©åˆ†æŠ½ç")
async def score_draw_slash(interaction: discord.Interaction):
    """ç©åˆ†æŠ½ç"""
    await interaction.response.defer()
    
    try:
        current_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ² ç©åˆ†æŠ½çç³»çµ±",
            description="è«‹é¸æ“‡è¦æ‰£é™¤çš„ç©åˆ†é€²è¡ŒæŠ½çï¼š",
            color=0x9B59B6
        )
        
        embed.add_field(
            name="ğŸŸ¢ 50ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 70%\nâ€¢ è—ç®± 25%\nâ€¢ ç´«ç®± 4.5%\nâ€¢ é‡‘ç®± 0.5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ”µ 100ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 50%\nâ€¢ è—ç®± 40%\nâ€¢ ç´«ç®± 9%\nâ€¢ é‡‘ç®± 1%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸŸ£ 500ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 10%\nâ€¢ è—ç®± 65%\nâ€¢ ç´«ç®± 20%\nâ€¢ é‡‘ç®± 5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ’° ä½ çš„ç©åˆ†",
            value=f"{current_score} åˆ†",
            inline=False
        )
        
        embed.set_footer(text="é»æ“Šä¸‹æ–¹å°æ‡‰çš„emojié¸æ“‡æŠ½çé¡å‹")
        
        class ScoreDrawView(discord.ui.View):
            def __init__(self, user_id):
                super().__init__(timeout=60)
                self.user_id = user_id
            
            @discord.ui.button(label="50åˆ†", style=discord.ButtonStyle.success, emoji="ğŸŸ¢", row=0)
            async def fifty_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 50)
            
            @discord.ui.button(label="100åˆ†", style=discord.ButtonStyle.primary, emoji="ğŸ”µ", row=0)
            async def hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 100)
            
            @discord.ui.button(label="500åˆ†", style=discord.ButtonStyle.secondary, emoji="ğŸŸ£", row=1)
            async def five_hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 500)
            
            async def process_draw(self, interaction: discord.Interaction, score_cost: int):
                if interaction.user.id != self.user_id:
                    await interaction.response.send_message("âŒ é€™ä¸æ˜¯ä½ çš„æŠ½çï¼", ephemeral=True)
                    return
                
                current_score, _ = get_user_score(interaction.user.id)
                if current_score < score_cost:
                    await interaction.response.send_message(
                        f"âŒ ç©åˆ†ä¸è¶³ï¼éœ€è¦ {score_cost} åˆ†ï¼Œä½ ç›®å‰æœ‰ {current_score} åˆ†",
                        ephemeral=True
                    )
                    return
                
                weights = {
                    50: {"ç¶ ç®±": 70, "è—ç®±": 25, "ç´«ç®±": 4.5, "é‡‘ç®±": 0.5},
                    100: {"ç¶ ç®±": 50, "è—ç®±": 40, "ç´«ç®±": 9, "é‡‘ç®±": 1},
                    500: {"ç¶ ç®±": 10, "è—ç®±": 65, "ç´«ç®±": 20, "é‡‘ç®±": 5}
                }
                
                box_weights = weights[score_cost]
                box_types = list(box_weights.keys())
                box_weights_list = list(box_weights.values())
                selected_box = random.choices(box_types, weights=box_weights_list, k=1)[0]
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute(
                    "SELECT id, prize_name FROM prize_pool WHERE box_level = ? AND remaining > 0 ORDER BY RANDOM() LIMIT 1",
                    (selected_box,)
                )
                result = cursor.fetchone()
                
                if not result:
                    await interaction.response.send_message(f"âŒ {selected_box}ä¸­æ²’æœ‰å¯ç”¨çå“ï¼", ephemeral=True)
                    conn.close()
                    return
                
                prize_id, prize_name = result
                
                update_user_score(interaction.user.id, interaction.user.name, -score_cost, f"ç©åˆ†æŠ½ç ({selected_box})")
                cursor.execute("UPDATE prize_pool SET remaining = remaining - 1 WHERE id = ?", (prize_id,))
                
                cursor.execute('''
                    INSERT INTO score_draws (creator_id, score_cost, box_level, winner_prize, winner_id)
                    VALUES (?, ?, ?, ?, ?)
                ''', (interaction.user.id, score_cost, selected_box, prize_name, interaction.user.id))
                
                conn.commit()
                conn.close()
                
                new_current_score, _ = get_user_score(interaction.user.id)
                
                result_embed = discord.Embed(
                    title="ğŸ‰ æŠ½ççµæœ",
                    description=f"ä½ æŠ½ä¸­äº† **{prize_name}**ï¼",
                    color=0x00FF00
                )
                
                result_embed.add_field(name="æ‰£é™¤ç©åˆ†", value=f"{score_cost} åˆ†", inline=True)
                result_embed.add_field(name="å¯¶ç®±é¡å‹", value=selected_box, inline=True)
                result_embed.add_field(name="ä¸­çæ©Ÿç‡", value=f"{box_weights[selected_box]}%", inline=True)
                result_embed.add_field(name="å‰©é¤˜ç©åˆ†", value=f"{new_current_score} åˆ†", inline=True)
                result_embed.add_field(name="çå“åç¨±", value=prize_name, inline=False)
                
                await interaction.response.send_message(embed=result_embed, ephemeral=False)
                
                for child in self.children:
                    child.disabled = True
                
                await interaction.message.edit(view=self)
        
        view = ScoreDrawView(interaction.user.id)
        await interaction.followup.send(embed=embed, view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@tree.command(name="score_transfer", description="è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶ / ç©åˆ†éæˆ¶")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="è½‰ç§»ç©åˆ†",
    reason="åŸå› ï¼ˆå¯é¸ï¼‰"
)
async def score_transfer_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: Optional[str] = None
):
    """è½‰ç§»ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if amount <= 0:
            await interaction.followup.send("âŒ ç©åˆ†å¿…é ˆå¤§æ–¼ 0")
            return
        
        if user.id == interaction.user.id:
            await interaction.followup.send("âŒ ä¸èƒ½è½‰ç§»ç©åˆ†çµ¦è‡ªå·±")
            return
        
        sender_score, _ = get_user_score(interaction.user.id)
        
        if sender_score < amount:
            await interaction.followup.send(f"âŒ ä½ çš„ç©åˆ†ä¸è¶³ï¼éœ€è¦ {amount} åˆ†ï¼Œä½ ç›®å‰æœ‰ {sender_score} åˆ†")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        update_user_score(interaction.user.id, interaction.user.name, -amount, f"è½‰ç§»çµ¦ {user.name}")
        update_user_score(user.id, user.name, amount, f"ä¾†è‡ª {interaction.user.name} çš„è½‰ç§»")
        
        cursor.execute('''
            INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason)
            VALUES (?, ?, ?, ?)
        ''', (interaction.user.id, user.id, amount, reason or "ç„¡"))
        
        conn.commit()
        conn.close()
        
        new_sender_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ’¸ ç©åˆ†è½‰ç§»æˆåŠŸ",
            description=f"**è½‰å‡ºï¼š** {interaction.user.mention}\n"
                       f"**è½‰å…¥ï¼š** {user.mention}\n"
                       f"**é‡‘é¡ï¼š** {amount} åˆ†\n"
                       f"**åŸå› ï¼š** {reason or 'ç„¡'}\n"
                       f"**ä½ çš„å‰©é¤˜ç©åˆ†ï¼š** {new_sender_score} åˆ†",
            color=0x2ECC71
        )
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è½‰ç§»å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@tree.command(name="prizelist", description="æŸ¥çœ‹å½©æ± åˆ—è¡¨ / å½©æ± ")
async def prizelist_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹å½©æ± """
    await interaction.response.defer()
    
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='prize_pool'")
        if not cursor.fetchone():
            embed = discord.Embed(
                title="âŒ å½©æ± è¡¨æ ¼ä¸å­˜åœ¨",
                description="è«‹é‡æ–°å•Ÿå‹•æ©Ÿå™¨äººä»¥åˆå§‹åŒ–è³‡æ–™åº«",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed)
            conn.close()
            return
        
        cursor.execute("""
            SELECT box_level, 
                   COUNT(*) as total_items,
                   SUM(remaining) as total_remaining
            FROM prize_pool 
            WHERE remaining > 0 
            GROUP BY box_level 
            ORDER BY 
                CASE box_level 
                    WHEN 'é‡‘ç®±' THEN 1 
                    WHEN 'ç´«ç®±' THEN 2 
                    WHEN 'è—ç®±' THEN 3 
                    WHEN 'ç¶ ç®±' THEN 4 
                    ELSE 5 
                END
        """)
        
        results = cursor.fetchall()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ å½©æ± åˆ—è¡¨",
                description="ç›®å‰å½©æ± æ˜¯ç©ºçš„",
                color=0xFFD700
            )
            await interaction.followup.send(embed=embed)
            conn.close()
            return
        
        embed = discord.Embed(
            title="ğŸ å½©æ± åˆ—è¡¨",
            description="å¯ç”¨çš„çå“ï¼ˆæŒ‰å¯¶ç®±ç­‰ç´šåˆ†é¡ï¼‰ï¼š",
            color=0xFFD700
        )
        
        for box_level, total_items, total_remaining in results:
            cursor.execute("""
                SELECT prize_name, remaining 
                FROM prize_pool 
                WHERE box_level = ? AND remaining > 0 
                ORDER BY prize_name
            """, (box_level,))
            
            items = cursor.fetchall()
            
            items_text = ""
            displayed_count = 0
            hidden_count = 0
            
            for prize_name, remaining in items:
                displayed_count += 1
                if displayed_count <= 8:
                    items_text += f"â€¢ {prize_name} (å‰©é¤˜: {remaining})\n"
                else:
                    hidden_count += 1
            
            if hidden_count > 0:
                items_text += f"... é‚„æœ‰ {hidden_count} å€‹çå“\n"
            
            actual_total = sum(item[1] for item in items)
            
            embed.add_field(
                name=f"{box_level} (ç¸½å‰©é¤˜: {actual_total} / çå“ç¨®é¡: {total_items})",
                value=items_text if items_text else "ç„¡çå“",
                inline=False
            )
        
        conn.close()
        
        embed.add_field(
            name="ğŸ“Š ç©åˆ†æŠ½çæ©Ÿç‡",
            value="**50ç©åˆ†ï¼š** ç¶ ç®±70% è—ç®±25% ç´«ç®±4.5% é‡‘ç®±0.5%\n"
                  "**100ç©åˆ†ï¼š** ç¶ ç®±50% è—ç®±40% ç´«ç®±9% é‡‘ç®±1%\n"
                  "**500ç©åˆ†ï¼š** ç¶ ç®±10% è—ç®±65% ç´«ç®±20% é‡‘ç®±5%",
            inline=False
        )
        
        embed.set_footer(text="ä½¿ç”¨ /add_prize æ·»åŠ çå“åˆ°å½©æ± ")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å½©æ± å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@tree.command(name="random_team", description="éš¨æ©Ÿåˆ†çµ„ / éš¨æ©Ÿåˆ†çµ„")
@app_commands.describe(
    team_size="æ¯çµ„äººæ•¸",
    team_count="çµ„æ•¸"
)
async def random_team_slash(
    interaction: discord.Interaction,
    team_size: Optional[int] = None,
    team_count: Optional[int] = None
):
    """éš¨æ©Ÿåˆ†çµ„"""
    await interaction.response.defer()
    
    try:
        if not interaction.guild:
            await interaction.followup.send("âŒ æ­¤æŒ‡ä»¤åªèƒ½åœ¨ä¼ºæœå™¨ä¸­ä½¿ç”¨")
            return
        
        embed = discord.Embed(
            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
            color=0x3498DB
        )
        
        if team_size:
            embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
        if team_count:
            embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
        
        embed.add_field(name="åƒåŠ äººæ•¸", value="0 äºº", inline=True)
        embed.set_footer(text="ç­‰å¾…åƒåŠ è€…...")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ®")
        await message.add_reaction("â–¶ï¸")
        
        participants = []
        
        def check(reaction, user):
            return (
                user != bot.user and
                str(reaction.emoji) in ["ğŸ®", "â–¶ï¸"] and
                reaction.message.id == message.id
            )
        
        try:
            while True:
                reaction, user = await bot.wait_for('reaction_add', timeout=300.0, check=check)
                
                if str(reaction.emoji) == "ğŸ®":
                    if user.id not in participants:
                        participants.append(user.id)
                        
                        new_embed = discord.Embed(
                            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
                            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
                            color=0x3498DB
                        )
                        
                        if team_size:
                            new_embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
                        if team_count:
                            new_embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
                        
                        new_embed.add_field(name="åƒåŠ äººæ•¸", value=f"{len(participants)} äºº", inline=True)
                        
                        if participants:
                            participants_text = ""
                            for i, pid in enumerate(participants[:10], 1):
                                participants_text += f"{i}. <@{pid}>\n"
                            if len(participants) > 10:
                                participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                            
                            new_embed.add_field(name="åƒåŠ è€…", value=participants_text, inline=False)
                        
                        new_embed.set_footer(text=f"ç­‰å¾…ä¸»æŒäººé–‹å§‹... ({len(participants)}äººåƒåŠ )")
                        
                        await message.edit(embed=new_embed)
                        
                elif str(reaction.emoji) == "â–¶ï¸" and user.id == interaction.user.id:
                    if len(participants) < 2:
                        await message.channel.send("âŒ è‡³å°‘éœ€è¦2äººæ‰èƒ½é–‹å§‹åˆ†çµ„", delete_after=5)
                        continue
                    
                    random.shuffle(participants)
                    
                    if team_size:
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    elif team_count:
                        team_size = len(participants) // team_count
                        if len(participants) % team_count != 0:
                            team_size += 1
                    else:
                        if len(participants) <= 4:
                            team_size = 2
                        elif len(participants) <= 8:
                            team_size = 4
                        else:
                            team_size = 5
                        
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    
                    teams = []
                    for i in range(team_count):
                        start_idx = i * team_size
                        end_idx = min((i + 1) * team_size, len(participants))
                        if start_idx < len(participants):
                            teams.append(participants[start_idx:end_idx])
                    
                    result_embed = discord.Embed(
                        title="ğŸ‘¥ åˆ†çµ„çµæœ",
                        description=f"ç¸½äººæ•¸ï¼š{len(participants)} äºº\n"
                                   f"åˆ†çµ„æ–¹å¼ï¼š{team_count} çµ„ï¼Œæ¯çµ„ç´„ {team_size} äºº",
                        color=0x00FF00
                    )
                    
                    for i, team in enumerate(teams, 1):
                        members_list = "\n".join([f"{j+1}. <@{member_id}>" for j, member_id in enumerate(team)])
                        result_embed.add_field(
                            name=f"ç¬¬ {i} çµ„ ({len(team)}äºº)",
                            value=members_list,
                            inline=False
                        )
                    
                    await message.channel.send(embed=result_embed)
                    await message.clear_reactions()
                    break
        
        except asyncio.TimeoutError:
            timeout_embed = discord.Embed(
                title="ğŸ‘¥ åˆ†çµ„è¶…æ™‚",
                description="åˆ†çµ„æ™‚é–“å·²é",
                color=0xFF0000
            )
            await message.edit(embed=timeout_embed)
            await message.clear_reactions()
            
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åˆ†çµ„å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# ========== ç®¡ç†å“¡æŒ‡ä»¤ ==========

@tree.command(name="add_prize", description="æ·»åŠ çå“åˆ°å½©æ±  / èª¿æ•´å½©æ± ")
@app_commands.describe(
    name="çå“åç¨±",
    box_level="å¯¶ç®±ç­‰ç´š (ç¶ ç®±/è—ç®±/ç´«ç®±/é‡‘ç®±)",
    quantity="æ•¸é‡ (æ­£æ•¸æ·»åŠ , è² æ•¸æ¸›å°‘)"
)
async def add_prize_slash(
    interaction: discord.Interaction,
    name: str,
    box_level: str,
    quantity: int
):
    """æ·»åŠ /æ¸›å°‘çå“"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        valid_levels = ["ç¶ ç®±", "è—ç®±", "ç´«ç®±", "é‡‘ç®±"]
        if box_level not in valid_levels:
            await interaction.followup.send(f"âŒ ç„¡æ•ˆçš„å¯¶ç®±ç­‰ç´šï¼è«‹é¸æ“‡ï¼š{', '.join(valid_levels)}")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='prize_pool'")
        if not cursor.fetchone():
            error_embed = discord.Embed(
                title="âŒ å½©æ± è¡¨æ ¼ä¸å­˜åœ¨",
                description="è«‹é‡æ–°å•Ÿå‹•æ©Ÿå™¨äººä»¥åˆå§‹åŒ–è³‡æ–™åº«",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
            conn.close()
            return
        
        if quantity > 0:
            cursor.execute('''
                INSERT INTO prize_pool (prize_name, box_level, quantity, remaining, added_by)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(prize_name, box_level) 
                DO UPDATE SET 
                    quantity = quantity + excluded.quantity,
                    remaining = remaining + excluded.quantity
            ''', (name, box_level, quantity, quantity, interaction.user.id))
            
            action = "æ·»åŠ "
        elif quantity < 0:
            cursor.execute('''
                UPDATE prize_pool 
                SET quantity = quantity + ?,
                    remaining = CASE 
                                    WHEN remaining + ? > 0 THEN remaining + ?
                                    ELSE 0
                                END
                WHERE prize_name = ? AND box_level = ?
            ''', (quantity, quantity, quantity, name, box_level))
            
            if cursor.rowcount == 0:
                await interaction.followup.send(f"âŒ æ‰¾ä¸åˆ°çå“ '{name}' åœ¨ {box_level} ä¸­")
                conn.close()
                return
            
            action = "æ¸›å°‘"
        else:
            await interaction.followup.send("âŒ æ•¸é‡ä¸èƒ½ç‚º 0")
            conn.close()
            return
        
        cursor.execute("SELECT quantity, remaining FROM prize_pool WHERE prize_name = ? AND box_level = ?", 
                      (name, box_level))
        result = cursor.fetchone()
        
        if result:
            total_qty, remaining_qty = result
            
            embed = discord.Embed(
                title=f"âœ… çå“{action}æˆåŠŸ",
                color=0x2ECC71 if quantity > 0 else 0xE74C3C
            )
            
            embed.add_field(name="çå“åç¨±", value=name, inline=True)
            embed.add_field(name="å¯¶ç®±ç­‰ç´š", value=box_level, inline=True)
            embed.add_field(name=f"{action}æ•¸é‡", value=f"{abs(quantity)} å€‹", inline=True)
            embed.add_field(name="ç¸½æ•¸é‡", value=f"{total_qty} å€‹", inline=True)
            embed.add_field(name="å‰©é¤˜æ•¸é‡", value=f"{remaining_qty} å€‹", inline=True)
            embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
            
            await interaction.followup.send(embed=embed)
        else:
            await interaction.followup.send(f"âŒ æ“ä½œå¤±æ•—")
        
        conn.commit()
        conn.close()
        
    except sqlite3.OperationalError as e:
        if "no such column" in str(e) or "no such table" in str(e):
            error_embed = discord.Embed(
                title="âŒ è³‡æ–™åº«çµæ§‹éŒ¯èª¤",
                description="è«‹åˆªé™¤ bot_data.db æª”æ¡ˆå¾Œé‡æ–°å•Ÿå‹•æ©Ÿå™¨äºº",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
        else:
            error_embed = discord.Embed(
                title="âŒ æ“ä½œå¤±æ•—",
                description=f"è³‡æ–™åº«éŒ¯èª¤ï¼š{str(e)}",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æ“ä½œå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@tree.command(name="add_score", description="èª¿æ•´ç”¨æˆ¶ç©åˆ† / åŠ æ¸›ç©åˆ†")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="ç©åˆ†è®ŠåŒ–ï¼ˆæ­£æ•¸ç‚ºå¢åŠ ï¼Œè² æ•¸ç‚ºæ¸›å°‘ï¼‰",
    reason="åŸå› "
)
async def add_score_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: str
):
    """èª¿æ•´ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        if amount == 0:
            await interaction.followup.send("âŒ ç©åˆ†è®ŠåŒ–ä¸èƒ½ç‚º 0")
            return
        
        old_score, old_total = get_user_score(user.id)
        update_user_score(user.id, user.name, amount, f"ç®¡ç†å“¡èª¿æ•´: {reason}")
        new_score, new_total = get_user_score(user.id)
        
        action = "å¢åŠ " if amount > 0 else "æ¸›å°‘"
        embed = discord.Embed(
            title=f"âœ… ç©åˆ†{action}æˆåŠŸ",
            color=0x2ECC71 if amount > 0 else 0xE74C3C
        )
        
        embed.add_field(name="ç”¨æˆ¶", value=user.mention, inline=True)
        embed.add_field(name=f"{action}ç©åˆ†", value=f"{abs(amount)} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå‰ç©åˆ†", value=f"{old_score} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå¾Œç©åˆ†", value=f"{new_score} åˆ†", inline=True)
        embed.add_field(name="ç¸½ç²å¾—ç©åˆ†", value=f"{new_total} åˆ†", inline=True)
        embed.add_field(name="åŸå› ", value=reason, inline=True)
        embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ èª¿æ•´å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

@tree.command(name="create_event", description="å‰µå»ºè©•æ ¸æ´»å‹• / å‰µå»ºè©•æ ¸æ´»å‹•")
@app_commands.describe(
    event_name="æ´»å‹•åç¨±",
    signup_time="ç°½åˆ°æ™‚é–“ï¼ˆåˆ†é˜ï¼‰",
    prize="æ´»å‹•çå“"
)
async def create_event_slash(
    interaction: discord.Interaction,
    event_name: str,
    signup_time: int = 5,
    prize: Optional[str] = None
):
    """å‰µå»ºè©•æ ¸æ´»å‹• - ç°¡åŒ–è©•æ ¸ç‰ˆæœ¬"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        # å»ºç«‹ç°½åˆ°è¨Šæ¯
        signup_embed = discord.Embed(
            title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
            color=discord.Color.blue()
        )
        
        if prize:
            signup_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
        
        signup_embed.add_field(
            name="ğŸ“ ç°½åˆ°éšæ®µ",
            value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°\nè¶…éæ™‚é–“ç°½åˆ°å°‡ä¸è¨ˆç®—å‡ºå¸­ç‡",
            inline=False
        )
        
        signup_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value="0 äºº", inline=True)
        signup_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
        
        # ç™¼é€ç°½åˆ°è¨Šæ¯
        signup_message = await interaction.followup.send(embed=signup_embed, wait=True)
        await signup_message.add_reaction("âœ…")
        
        # å»ºç«‹è·æ¥­é¸æ“‡è¨Šæ¯
        class_embed = discord.Embed(
            title=f"ğŸ® è·æ¥­é¸æ“‡ï¼š{event_name}",
            description="è«‹é¸æ“‡ä½ çš„è·æ¥­ï¼š\n\nğŸ›¡ï¸ å¦å…‹\nâš”ï¸ è¾“å‡º\nğŸ’š æ²»ç–—\nğŸ’› è¾…åŠ©\n\n**æ³¨æ„ï¼šè«‹å…ˆå®Œæˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼**",
            color=discord.Color.green()
        )
        class_embed.set_footer(text="ç°½åˆ°æˆåŠŸå¾Œè«‹é¸æ“‡è·æ¥­")
        
        class_msg = await interaction.channel.send(embed=class_embed)
        for emoji in ["ğŸ›¡ï¸", "âš”ï¸", "ğŸ’š", "ğŸ’›"]:
            await class_msg.add_reaction(emoji)
        
        # è¨ˆç®—ç°½åˆ°çµæŸæ™‚é–“
        signup_end_time = datetime.now() + timedelta(minutes=signup_time)
        
        # ä¿å­˜åˆ°è³‡æ–™åº«
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO evaluation_events (event_name, creator_id, signup_message_id, profession_message_id, channel_id, signup_end_time)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (event_name, interaction.user.id, signup_message.id, class_msg.id, interaction.channel.id, signup_end_time))
        conn.commit()
        conn.close()
        
        print(f"âœ… æ´»å‹•å‰µå»ºæˆåŠŸ: {event_name}, ç°½åˆ°è¨Šæ¯ID: {signup_message.id}, è·æ¥­è¨Šæ¯ID: {class_msg.id}")
        
        async def signup_countdown():
            remaining_minutes = signup_time
            
            while remaining_minutes > 0:
                await asyncio.sleep(60)
                remaining_minutes -= 1
                
                try:
                    conn = sqlite3.connect(DB_NAME)
                    cursor = conn.cursor()
                    cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                    result = cursor.fetchone()
                    
                    participants_count = 0
                    if result and result[0]:
                        participants = json.loads(result[0])
                        participants_count = len(participants)
                    
                    updated_embed = discord.Embed(
                        title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                        color=discord.Color.blue()
                    )
                    
                    if prize:
                        updated_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                    
                    updated_embed.add_field(
                        name="ğŸ“ ç°½åˆ°éšæ®µ",
                        value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°\nè¶…éæ™‚é–“ç°½åˆ°å°‡ä¸è¨ˆç®—å‡ºå¸­ç‡",
                        inline=False
                    )
                    
                    updated_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
                    updated_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{participants_count} äºº", inline=True)
                    updated_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{remaining_minutes} åˆ†é˜", inline=True)
                    updated_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
                    
                    await signup_message.edit(embed=updated_embed)
                    conn.close()
                    
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
            
            # ç°½åˆ°æ™‚é–“çµæŸ
            try:
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                result = cursor.fetchone()
                
                participants = []
                if result and result[0]:
                    participants = json.loads(result[0])
                
                # ç‚ºæ‰€æœ‰ç°½åˆ°æˆåŠŸçš„ç”¨æˆ¶çµ¦äºˆé è¨­ã€Œæ™®é€šã€è©•ç´š
                for user_id in participants:
                    # ç°½åˆ°æˆåŠŸçå‹µ40ç©åˆ†
                    update_user_score(user_id, f"ç”¨æˆ¶{user_id}", SIGNUP_SCORE, f"æ´»å‹•ç°½åˆ°: {event_name}")
                    # æ›´æ–°æ´»å‹•çµ±è¨ˆ
                    update_user_activity(user_id, event_name, attended=True)
                    # çµ¦äºˆé è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ0ç©åˆ†ï¼‰
                    update_user_rating(user_id, "æ™®é€š")
                
                # è¨˜éŒ„å·²é è¨­è©•ç´šçš„ç”¨æˆ¶
                cursor.execute("UPDATE evaluation_events SET default_rated = ?, is_active = 1 WHERE signup_message_id = ?", 
                             (json.dumps(participants), signup_message.id))
                conn.commit()
                conn.close()
                
                # æ›´æ–°ç°½åˆ°çµæŸè¨Šæ¯
                end_embed = discord.Embed(
                    title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                    description="**ç°½åˆ°å·²çµæŸï¼æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ0ç©åˆ†ï¼‰**",
                    color=discord.Color.red()
                )
                
                if prize:
                    end_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                
                end_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value="å·²çµæŸ", inline=True)
                end_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{len(participants)} äºº", inline=True)
                
                if participants:
                    participants_text = "\n".join([f"<@{user_id}>" for user_id in participants[:10]])
                    if len(participants) > 10:
                        participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                    
                    end_embed.add_field(name="ğŸ“‹ åƒèˆ‡è€…åˆ—è¡¨", value=participants_text, inline=False)
                
                end_embed.add_field(name="ğŸ“ è©•æ ¸èªªæ˜", value="ä¸»æŒäººç¾åœ¨å¯ä»¥æŒ‰EMOJIèª¿æ•´è©•ç´šï¼š\nâ­ å„ªç§€ (+40åˆ†)\nğŸ‘ è‰¯å¥½ (+10åˆ†)\nğŸ‘Œ æ™®é€š (0åˆ†ï¼Œé è¨­)\nâŒ ä¸åˆæ ¼ (-5åˆ†)", inline=False)
                end_embed.set_footer(text="åŠæœˆæœŸæ´»å‹•çµ±è¨ˆå·²æ›´æ–° | ç°½åˆ°ç©åˆ†å·²ç™¼æ”¾ | é è¨­è©•ç´šï¼šæ™®é€š")
                
                await signup_message.edit(embed=end_embed)
                await signup_message.clear_reactions()
                
                print(f"âœ… ç°½åˆ°çµæŸ: {event_name}, åƒèˆ‡è€…: {len(participants)}äºº, å·²çµ¦äºˆé è¨­æ™®é€šè©•ç´š")
                
                # å‰µå»ºè©•æ ¸éšæ®µè¨Šæ¯
                rating_embed = discord.Embed(
                    title=f"â­ è©•æ ¸éšæ®µï¼š{event_name}",
                    description="**ä¸»æŒäººå¯ä»¥æŒ‰ä¸‹æ–¹EMOJIèª¿æ•´è©•ç´š**\n\n"
                              f"æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ{RATING_SCORES['æ™®é€š']}ç©åˆ†ï¼‰\n"
                              f"è«‹ä¸»æŒäººé‡å°è¡¨ç¾å„ªç§€æˆ–éœ€è¦æ”¹é€²çš„æˆå“¡èª¿æ•´è©•ç´šï¼š\n\n"
                              f"â­ å„ªç§€ï¼š+{RATING_SCORES['å„ªç§€']}ç©åˆ†\n"
                              f"ğŸ‘ è‰¯å¥½ï¼š+{RATING_SCORES['è‰¯å¥½']}ç©åˆ†\n"
                              f"ğŸ‘Œ æ™®é€šï¼š{RATING_SCORES['æ™®é€š']}ç©åˆ†ï¼ˆé è¨­ï¼‰\n"
                              f"âŒ ä¸åˆæ ¼ï¼š{RATING_SCORES['ä¸åˆæ ¼']}ç©åˆ†\n\n"
                              f"**ä½¿ç”¨æ–¹æ³•ï¼š**\n1. é»æ“Šä¸‹æ–¹å°æ‡‰çš„EMOJI\n2. åœ¨å½ˆå‡ºçš„è¦–çª—ä¸­é¸æ“‡ç”¨æˆ¶\n3. ç³»çµ±æœƒè‡ªå‹•æ›´æ–°è©•ç´š",
                    color=discord.Color.gold()
                )
                
                if participants:
                    rating_embed.add_field(
                        name="ğŸ‘¥ åƒèˆ‡è€…åˆ—è¡¨",
                        value="\n".join([f"<@{user_id}>" for user_id in participants[:15]]) + 
                             (f"\n... é‚„æœ‰ {len(participants)-15} äºº" if len(participants) > 15 else ""),
                        inline=False
                    )
                
                rating_msg = await interaction.channel.send(embed=rating_embed)
                
                # æ·»åŠ è©•æ ¸EMOJIï¼ˆåŒ…æ‹¬çµæŸEMOJIï¼‰
                for emoji in ["â­", "ğŸ‘", "ğŸ‘Œ", "âŒ", RATING_END_EMOJI]:
                    await rating_msg.add_reaction(emoji)
                
                # æ›´æ–°è³‡æ–™åº«ä¸­çš„è©•æ ¸è¨Šæ¯ID
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("UPDATE evaluation_events SET rating_message_id = ? WHERE signup_message_id = ?", 
                             (rating_msg.id, signup_message.id))
                conn.commit()
                conn.close()
                
                print(f"âœ… è©•æ ¸éšæ®µå·²å‰µå»º: {event_name}, è©•æ ¸è¨Šæ¯ID: {rating_msg.id}")
                
            except Exception as e:
                print(f"ç°½åˆ°çµæŸè™•ç†éŒ¯èª¤: {e}")
        
        asyncio.create_task(signup_countdown())
        
        success_embed = discord.Embed(
            title="âœ… æ´»å‹•å‰µå»ºæˆåŠŸ",
            description=f"**æ´»å‹•åç¨±ï¼š** {event_name}\n**ç°½åˆ°æ™‚é–“ï¼š** {signup_time} åˆ†é˜\n**åƒèˆ‡æ–¹å¼ï¼š** æŒ‰ âœ… åæ‡‰ç°½åˆ°",
            color=discord.Color.green()
        )
        
        success_embed.add_field(name="ç°½åˆ°è¨Šæ¯", value=f"[é»æ“ŠæŸ¥çœ‹](https://discord.com/channels/{interaction.guild.id}/{interaction.channel.id}/{signup_message.id})", inline=True)
        success_embed.add_field(name="è·æ¥­é¸æ“‡", value=f"[é»æ“ŠæŸ¥çœ‹](https://discord.com/channels/{interaction.guild.id}/{interaction.channel.id}/{class_msg.id})", inline=True)
        
        await interaction.followup.send(embed=success_embed, ephemeral=True)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæ´»å‹•å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# ========== äº‹ä»¶è™•ç† ==========

@bot.event
async def on_ready():
    """æ©Ÿå™¨äººä¸Šç·š"""
    print(f"\n{'='*60}")
    print(f"ğŸ¤– {BOT_NAME} å·²ä¸Šç·š")
    print(f"ğŸ“Š ä¼ºæœå™¨æ•¸é‡: {len(bot.guilds)}")
    print(f"{'='*60}")
    
    init_db()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")
    
    try:
        print("\nğŸ”„ æ­£åœ¨åŒæ­¥æŒ‡ä»¤...")
        global_synced = await tree.sync()
        print(f"âœ… å·²åŒæ­¥ {len(global_synced)} å€‹æŒ‡ä»¤")
        
        print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
        for cmd in global_synced:
            print(f"  â€¢ /{cmd.name} - {cmd.description}")
        
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")
    
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="/help æŸ¥çœ‹æŒ‡ä»¤"
        )
    )
    
    print(f"\nğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼")

@bot.event
async def on_raw_reaction_add(payload):
    """è™•ç†åæ‡‰äº‹ä»¶ - ç°¡åŒ–è©•æ ¸ç‰ˆæœ¬"""
    if payload.user_id == bot.user.id:
        return
    
    try:
        emoji = str(payload.emoji)
        user_id = payload.user_id
        
        # å–å¾—é »é“
        channel = bot.get_channel(payload.channel_id)
        if not channel:
            return
        
        # ç²å–è¨Šæ¯
        try:
            message = await channel.fetch_message(payload.message_id)
        except:
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # å…ˆæª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸çµæŸåæ‡‰
        cursor.execute("""
            SELECT id, channel_id, event_name 
            FROM evaluation_events 
            WHERE rating_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        rating_event = cursor.fetchone()
        
        if rating_event and emoji == RATING_END_EMOJI:
            event_id, event_channel_id, event_name = rating_event
            
            # æª¢æŸ¥æ˜¯å¦ç‚ºç®¡ç†å“¡
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    # ä¸æ˜¯ç®¡ç†å“¡ï¼Œç§»é™¤åæ‡‰
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥çµæŸè©•æ ¸æ´»å‹•ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            # ç¢ºèªçµæŸè©•æ ¸
            confirm_embed = discord.Embed(
                title="ğŸ ç¢ºèªçµæŸè©•æ ¸æ´»å‹•",
                description=f"ä½ ç¢ºå®šè¦çµæŸ **{event_name}** çš„è©•æ ¸éšæ®µå—ï¼Ÿ\n\n"
                          f"çµæŸå¾Œå°‡ï¼š\n"
                          f"â€¢ ç„¡æ³•å†é€²è¡Œè©•æ ¸\n"
                          f"â€¢ æ¸…é™¤è©•æ ¸è¨Šæ¯çš„æ‰€æœ‰åæ‡‰\n"
                          f"â€¢ æ´»å‹•æ¨™è¨˜ç‚ºå·²å®Œæˆ",
                color=discord.Color.orange()
            )
            
            class ConfirmEndView(discord.ui.View):
                def __init__(self, event_id, channel, event_name):
                    super().__init__(timeout=60)
                    self.event_id = event_id
                    self.channel = channel
                    self.event_name = event_name
                
                @discord.ui.button(label="ç¢ºå®šçµæŸ", style=discord.ButtonStyle.danger, emoji="âœ…")
                async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.defer()
                    
                    # çµæŸè©•æ ¸æ´»å‹•
                    await end_evaluation(self.event_id, self.channel, self.event_name)
                    
                    # ç¦ç”¨æŒ‰éˆ•
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
                    
                    await interaction.followup.send(f"âœ… å·²æˆåŠŸçµæŸ **{self.event_name}** çš„è©•æ ¸éšæ®µï¼")
                
                @discord.ui.button(label="å–æ¶ˆ", style=discord.ButtonStyle.secondary, emoji="âŒ")
                async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.send_message("å·²å–æ¶ˆçµæŸè©•æ ¸æ´»å‹•", ephemeral=True)
                    
                    # ç¦ç”¨æŒ‰éˆ•
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
            
            view = ConfirmEndView(event_id, channel, event_name)
            await channel.send(f"<@{user_id}>", embed=confirm_embed, view=view)
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸åæ‡‰
        if rating_event and emoji in RATING_EMOJIS:
            event_id, event_channel_id, event_name = rating_event
            rating_type = RATING_EMOJIS[emoji]
            
            print(f"æª¢æ¸¬åˆ°è©•æ ¸åæ‡‰: event_id={event_id}, rating_type={rating_type}, user_id={user_id}")
            
            # æª¢æŸ¥æ˜¯å¦ç‚ºç®¡ç†å“¡
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    # ä¸æ˜¯ç®¡ç†å“¡ï¼Œç§»é™¤åæ‡‰
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥é€²è¡Œè©•æ ¸ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            participants = []
            if result and result[0]:
                participants = json.loads(result[0])
            
            if not participants:
                await channel.send("âŒ æ²’æœ‰åƒèˆ‡è€…å¯ä»¥è©•æ ¸", delete_after=5)
                conn.close()
                return
            
            print(f"æ´»å‹• {event_name} æœ‰ {len(participants)} ä½åƒèˆ‡è€…å¯ä»¥è©•æ ¸")
            
            # å‰µå»ºé¸æ“‡åƒèˆ‡è€…çš„è¦–çª—
            class ParticipantSelectView(discord.ui.View):
                def __init__(self, participants, event_id, rating_type, channel, bot_instance):
                    super().__init__(timeout=60)
                    self.participants = participants
                    self.event_id = event_id
                    self.rating_type = rating_type
                    self.channel = channel
                    self.bot = bot_instance
                    
                    # å»ºç«‹é¸é …
                    options = []
                    for pid in participants[:25]:  # Discordé™åˆ¶æœ€å¤š25å€‹é¸é …
                        member = self.bot.get_user(int(pid))
                        display_name = member.display_name if member else f"ç”¨æˆ¶ID: {pid}"
                        options.append(discord.SelectOption(
                            label=display_name[:100],  # Discordé™åˆ¶æ¨™é¡Œé•·åº¦
                            value=str(pid),
                            description=f"é»æ“Šé¸æ“‡æ­¤ç”¨æˆ¶é€²è¡Œ {rating_type} è©•æ ¸"
                        ))
                    
                    # å»ºç«‹é¸æ“‡å™¨
                    select = discord.ui.Select(
                        placeholder=f"é¸æ“‡è¦è©•æ ¸ç‚º {rating_type} çš„åƒèˆ‡è€…",
                        options=options,
                        min_values=1,
                        max_values=1
                    )
                    
                    # å®šç¾©å›èª¿å‡½æ•¸
                    async def select_callback(interaction: discord.Interaction):
                        if not interaction.user.guild_permissions.administrator:
                            await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                            return
                        
                        selected_user_id = int(select.values[0])
                        selected_member = self.bot.get_user(selected_user_id)
                        display_name = selected_member.display_name if selected_member else f"ç”¨æˆ¶ID: {selected_user_id}"
                        
                        print(f"é¸æ“‡äº†ç”¨æˆ¶ {display_name} ({selected_user_id}) é€²è¡Œ {rating_type} è©•æ ¸")
                        
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        
                        cursor.execute("SELECT ratings FROM evaluation_events WHERE id = ?", (self.event_id,))
                        result = cursor.fetchone()
                        
                        ratings = {}
                        if result and result[0]:
                            ratings = json.loads(result[0])
                        
                        # æª¢æŸ¥ä¹‹å‰çš„è©•ç´š
                        old_rating = None
                        if str(selected_user_id) in ratings and ratings[str(selected_user_id)]:
                            old_rating = ratings[str(selected_user_id)][-1]["rating"] if ratings[str(selected_user_id)] else None
                        
                        # æ›´æ–°è©•ç´š
                        if str(selected_user_id) not in ratings:
                            ratings[str(selected_user_id)] = []
                        
                        ratings[str(selected_user_id)].append({
                            "rater": interaction.user.id,
                            "rating": self.rating_type,
                            "time": datetime.now().isoformat()
                        })
                        
                        cursor.execute("UPDATE evaluation_events SET ratings = ? WHERE id = ?", 
                                     (json.dumps(ratings), self.event_id))
                        conn.commit()
                        conn.close()
                        
                        # æ›´æ–°ç”¨æˆ¶è©•æ ¸çµ±è¨ˆï¼ˆç§»é™¤èˆŠè©•ç´šç©åˆ†ï¼ŒåŠ ä¸Šæ–°è©•ç´šç©åˆ†ï¼‰
                        if old_rating and old_rating != self.rating_type:
                            # ç§»é™¤èˆŠè©•ç´šç©åˆ†
                            old_score = RATING_SCORES.get(old_rating, 0)
                            update_user_score(selected_user_id, display_name, -old_score, f"è©•ç´šè®Šæ›´: {old_rating} â†’ {self.rating_type}")
                            print(f"ç§»é™¤èˆŠè©•ç´šç©åˆ†: {old_rating} (-{old_score}åˆ†)")
                        
                        # åŠ ä¸Šæ–°è©•ç´šç©åˆ†
                        new_score = RATING_SCORES.get(self.rating_type, 0)
                        update_user_rating(selected_user_id, self.rating_type)
                        
                        if new_score != 0:
                            update_user_score(selected_user_id, display_name, new_score, f"æ´»å‹•è©•æ ¸: {self.rating_type}")
                            print(f"æ·»åŠ æ–°è©•ç´šç©åˆ†: {self.rating_type} (+{new_score}åˆ†)")
                        
                        # ç™¼é€çµæœ
                        score_change = RATING_SCORES.get(self.rating_type, 0)
                        score_text = f"ï¼ˆç©åˆ†è®Šå‹•: {'+' if score_change > 0 else ''}{score_change}åˆ†ï¼‰" if score_change != 0 else ""
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            result_text = f"å·²å°‡ <@{selected_user_id}> ({display_name}) çš„è©•ç´šå¾ **{old_rating}** ({old_score}åˆ†) è®Šæ›´ç‚º **{self.rating_type}** {score_text}"
                        else:
                            result_text = f"å·²ç‚º <@{selected_user_id}> ({display_name}) è©•æ ¸ï¼š**{self.rating_type}** {score_text}"
                        
                        result_embed = discord.Embed(
                            title="âœ… è©•æ ¸å®Œæˆ",
                            description=result_text,
                            color=discord.Color.green() if score_change >= 0 else discord.Color.red()
                        )
                        
                        result_embed.add_field(name="è©•æ ¸è€…", value=interaction.user.mention, inline=True)
                        result_embed.add_field(name="æ–°è©•ç´š", value=self.rating_type, inline=True)
                        result_embed.add_field(name="ç©åˆ†è®Šå‹•", value=f"{score_change} åˆ†", inline=True)
                        
                        await interaction.response.send_message(embed=result_embed)
                        
                        # ç¦ç”¨è¦–çª—
                        for child in self.children:
                            child.disabled = True
                        await interaction.message.edit(view=self)
                    
                    select.callback = select_callback
                    self.add_item(select)
            
            view = ParticipantSelectView(participants, event_id, rating_type, channel, bot)
            
            # ç™¼é€é¸æ“‡è¦–çª—
            select_message = await channel.send(f"<@{user_id}> è«‹é¸æ“‡è¦è©•æ ¸ç‚º **{rating_type}** çš„åƒèˆ‡è€…ï¼š", view=view)
            print(f"å·²ç™¼é€é¸æ“‡è¦–çª—: message_id={select_message.id}")
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºæŠ½çè¨Šæ¯
        cursor.execute("""
            SELECT id, participants, creator_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (payload.message_id,))
        giveaway = cursor.fetchone()
        
        if giveaway:
            giveaway_id, participants_json, creator_id = giveaway
            
            if emoji == "ğŸ«":
                participants = json.loads(participants_json) if participants_json else []
                
                if user_id not in participants:
                    participants.append(user_id)
                    cursor.execute("UPDATE giveaways SET participants = ? WHERE id = ?", 
                                 (json.dumps(participants), giveaway_id))
                    conn.commit()
                    
                    try:
                        if message.embeds:
                            embed = message.embeds[0]
                            
                            new_embed = discord.Embed(
                                title=embed.title,
                                description=embed.description,
                                color=embed.color
                            )
                            
                            for field in embed.fields:
                                if field.name == "ğŸ« åƒèˆ‡äººæ•¸":
                                    new_embed.add_field(
                                        name="ğŸ« åƒèˆ‡äººæ•¸", 
                                        value=f"{len(participants)} äºº", 
                                        inline=field.inline
                                    )
                                else:
                                    new_embed.add_field(
                                        name=field.name, 
                                        value=field.value, 
                                        inline=field.inline
                                    )
                            
                            if embed.footer:
                                new_embed.set_footer(text=embed.footer.text)
                            
                            await message.edit(embed=new_embed)
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            elif emoji == "â¹ï¸" and user_id == creator_id:
                await end_giveaway(payload.message_id, manual=True)
                await channel.send(f"â¹ï¸ ä¸»è¾¦äººæ‰‹å‹•çµæŸäº†æŠ½çï¼")
        
        # è™•ç†è©•æ ¸æ´»å‹•ç°½åˆ°
        cursor.execute("""
            SELECT id, participants, signup_end_time 
            FROM evaluation_events 
            WHERE signup_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        signup_event = cursor.fetchone()
        
        if signup_event and emoji == "âœ…":
            event_id, participants_json, signup_end_time_str = signup_event
            
            try:
                # å®‰å…¨è§£ææ™‚é–“
                if signup_end_time_str:
                    try:
                        signup_end_time = datetime.strptime(signup_end_time_str.split('.')[0], '%Y-%m-%d %H:%M:%S')
                    except:
                        try:
                            signup_end_time = datetime.strptime(signup_end_time_str, '%Y-%m-%d %H:%M:%S.%f')
                        except:
                            signup_end_time = None
                else:
                    signup_end_time = None
                
                if signup_end_time and datetime.now() > signup_end_time:
                    try:
                        await message.remove_reaction("âœ…", payload.member)
                        await channel.send(f"âŒ <@{user_id}> ç°½åˆ°æ™‚é–“å·²éï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as time_error:
                print(f"æ™‚é–“è§£æéŒ¯èª¤: {time_error}")
            
            participants = json.loads(participants_json) if participants_json else []
            
            if user_id not in participants:
                participants.append(user_id)
                cursor.execute("UPDATE evaluation_events SET participants = ? WHERE id = ?", 
                             (json.dumps(participants), event_id))
                conn.commit()
                
                print(f"âœ… ç”¨æˆ¶ {user_id} æˆåŠŸç°½åˆ°æ´»å‹• {event_id}")
                
                try:
                    if message.embeds:
                        embed = message.embeds[0]
                        
                        new_embed = discord.Embed(
                            title=embed.title,
                            description=embed.description,
                            color=embed.color
                        )
                        
                        for field in embed.fields:
                            if field.name == "ğŸ‘¥ å·²ç°½åˆ°":
                                new_embed.add_field(
                                    name="ğŸ‘¥ å·²ç°½åˆ°", 
                                    value=f"{len(participants)} äºº", 
                                    inline=field.inline
                                )
                            elif field.name == "â±ï¸ å‰©é¤˜æ™‚é–“":
                                new_embed.add_field(
                                    name=field.name,
                                    value=field.value,
                                    inline=field.inline
                                )
                            else:
                                new_embed.add_field(
                                    name=field.name, 
                                    value=field.value, 
                                    inline=field.inline
                                )
                        
                        if embed.footer:
                            new_embed.set_footer(text=embed.footer.text)
                        
                        await message.edit(embed=new_embed)
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
        
        # è™•ç†è·æ¥­é¸æ“‡
        cursor.execute("""
            SELECT id, professions 
            FROM evaluation_events 
            WHERE profession_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        profession_event = cursor.fetchone()
        
        if profession_event and emoji in PROFESSION_EMOJIS:
            event_id, professions_json = profession_event
            profession_name = PROFESSION_EMOJIS[emoji]
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            if result and result[0]:
                participants = json.loads(result[0])
                
                if user_id in participants:
                    professions = json.loads(professions_json) if professions_json else {}
                    
                    if str(user_id) not in professions:
                        professions[str(user_id)] = profession_name
                        cursor.execute("UPDATE evaluation_events SET professions = ? WHERE id = ?", 
                                     (json.dumps(professions), event_id))
                        conn.commit()
                        
                        update_user_profession(user_id, profession_name)
                        
                        try:
                            bonus = PROFESSION_BONUS.get(profession_name, 0)
                            bonus_text = f"ï¼ˆç²å¾—è·æ¥­åŠ æˆï¼š+{bonus}ç©åˆ†ï¼‰" if bonus > 0 else ""
                            await channel.send(f"âœ… <@{user_id}> å·²é¸æ“‡è·æ¥­ï¼š**{profession_name}**{bonus_text}", delete_after=5)
                        except:
                            pass
                    else:
                        try:
                            await message.remove_reaction(emoji, payload.member)
                            await channel.send(f"âš ï¸ <@{user_id}> ä½ å·²ç¶“é¸æ“‡éè·æ¥­äº†ï¼", delete_after=5)
                        except:
                            pass
                else:
                    try:
                        await message.remove_reaction(emoji, payload.member)
                        await channel.send(f"âŒ <@{user_id}> è«‹å…ˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼", delete_after=5)
                    except:
                        pass
        
        conn.close()
        
    except Exception as e:
        print(f"è™•ç†åæ‡‰éŒ¯èª¤: {e}")
        import traceback
        traceback.print_exc()

# ========== ä¸»ç¨‹å¼ ==========

def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    print(f"{'='*50}")
    print(f"ğŸš€ å•Ÿå‹• {BOT_NAME} - Railway é›²ç«¯ç‰ˆæœ¬")
    print(f"ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´")
    print(f"ğŸ”§ æ“æœ‰è€…ID: {OWNER_IDS}")
    print(f"ğŸ“ è³‡æ–™åº«ä½ç½®: {DB_NAME}")
    print(f"{'='*50}")
    
    # å¾ç’°å¢ƒè®Šæ•¸è®€å– Token
    token = os.getenv("DISCORD_TOKEN")
    
    if not token or token == "ä½ çš„_bot_token_åœ¨é€™è£¡":
        print("âŒ æ‰¾ä¸åˆ°æœ‰æ•ˆçš„ Tokenï¼")
        print("ğŸ’¡ è«‹åœ¨ Railway è¨­å®šç’°å¢ƒè®Šæ•¸ï¼š")
        print("   1. é€²å…¥ Railway å°ˆæ¡ˆ")
        print("   2. é»æ“Š Settings")
        print("   3. é»æ“Š Variables")
        print("   4. æ–°å¢ DISCORD_TOKEN = ä½ çš„_bot_token")
        sys.exit(1)
    
    print("âœ… Token è®€å–æˆåŠŸ")
    print("ğŸ”„ æ­£åœ¨é€£æ¥ Discord...")
    
    try:
        bot.run(token)
    except discord.LoginFailure:
        print("âŒ ç™»å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º")
        print("ğŸ’¡ è«‹åˆ° Discord Developer Portal é‡ç½® Token")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")

if __name__ == "__main__":

    main()

é€™æ˜¯å¤±æ•—çš„
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å°é›²ALBIONæ©Ÿæ¢°äºº - å®Œæ•´åŠŸèƒ½ç‰ˆæœ¬
13å€‹æŒ‡ä»¤å…¨éƒ¨å¯ç”¨
"""

import os
import discord
from discord.ext import commands
from discord import app_commands
import sys
import asyncio
import json
import random
from datetime import datetime, timedelta
from typing import Optional, List
import sqlite3
import time

# ========== è¨­å®š ==========
BOT_NAME = "å°é›²æ©Ÿæ¢°äºº"
OWNER_IDS = [337237662157242368]  # ä½ çš„ Discord ID

# è·æ¥­å°æ‡‰çš„EMOJI
PROFESSION_EMOJIS = {
    "ğŸ›¡ï¸": "å¦å…‹",
    "âš”ï¸": "è¾“å‡º", 
    "ğŸ’š": "æ²»ç–—",
    "ğŸ’›": "è¾…åŠ©"
}

# è©•æ ¸è©•åˆ†é¸é …
RATING_EMOJIS = {
    "â­": "å„ªç§€",
    "ğŸ‘": "è‰¯å¥½", 
    "ğŸ‘Œ": "æ™®é€š",  # é è¨­è©•ç´š
    "âŒ": "ä¸åˆæ ¼"
}

# è©•æ ¸çµæŸEMOJI
RATING_END_EMOJI = "ğŸ"

# ========== ç©åˆ†è¨­å®š ==========
SIGNUP_SCORE = 40  # ç°½åˆ°ç©åˆ†
PROFESSION_BONUS = {
    "å¦å…‹": 0,
    "è¾“å‡º": 0,
    "æ²»ç–—": 20,  # è£œå¸«+20ç©åˆ†
    "è¾…åŠ©": 0
}
RATING_SCORES = {
    "å„ªç§€": 40,    # å„ªç§€+40ç©åˆ†
    "è‰¯å¥½": 10,    # è‰¯å¥½+10ç©åˆ†
    "æ™®é€š": 0,     # æ™®é€š+0ç©åˆ†
    "ä¸åˆæ ¼": -5   # ä¸åˆæ ¼-5ç©åˆ†
}

# Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True
intents.presences = True

bot = commands.Bot(
    command_prefix='!',
    intents=intents,
    help_command=None,
    case_insensitive=True
)

# ========== è³‡æ–™åº«è¨­å®š ==========
DB_NAME = "bot_data.db"

def init_db():
    """åˆå§‹åŒ–è³‡æ–™åº«"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # ç”¨æˆ¶è³‡æ–™è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        total_score INTEGER DEFAULT 0,
        current_score INTEGER DEFAULT 0,
        join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        profession_counts TEXT DEFAULT '{}',
        activity_stats TEXT DEFAULT '{}',
        rating_stats TEXT DEFAULT '{}'
    )
    ''')
    
    # å½©æ± è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS prize_pool (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        prize_name TEXT NOT NULL,
        box_level TEXT NOT NULL,
        quantity INTEGER DEFAULT 1,
        remaining INTEGER DEFAULT 1,
        added_by INTEGER,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(prize_name, box_level)
    )
    ''')
    
    # æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS giveaways (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        prize TEXT,
        winner_count INTEGER DEFAULT 1,
        participants TEXT DEFAULT '[]',
        winners TEXT DEFAULT '[]',
        end_time TIMESTAMP,
        message_id INTEGER,
        channel_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_draws (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        score_cost INTEGER,
        box_level TEXT,
        participants TEXT DEFAULT '[]',
        winner_prize TEXT,
        winner_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†è½‰ç§»ç´€éŒ„
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_transfers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_user_id INTEGER,
        to_user_id INTEGER,
        amount INTEGER,
        reason TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # è©•æ ¸æ´»å‹•
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS evaluation_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        event_name TEXT,
        creator_id INTEGER,
        signup_message_id INTEGER,
        profession_message_id INTEGER,
        rating_message_id INTEGER,
        channel_id INTEGER,
        participants TEXT DEFAULT '[]',
        default_rated TEXT DEFAULT '[]',
        professions TEXT DEFAULT '{}',
        ratings TEXT DEFAULT '{}',
        is_active BOOLEAN DEFAULT 1,
        start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        signup_end_time TIMESTAMP
    )
    ''')
    
    # æ·»åŠ ç¤ºä¾‹çå“
    sample_prizes = [
        ("æ™®é€šæ­¦å™¨", "ç¶ ç®±", 20),
        ("æ™®é€šè£å‚™", "ç¶ ç®±", 15),
        ("åˆç´šè—¥æ°´", "ç¶ ç®±", 30),
        ("ä¸­ç´šæ­¦å™¨", "è—ç®±", 10),
        ("ä¸­ç´šè£å‚™", "è—ç®±", 8),
        ("ä¸­ç´šè—¥æ°´", "è—ç®±", 15),
        ("é«˜ç´šæ­¦å™¨", "ç´«ç®±", 5),
        ("é«˜ç´šè£å‚™", "ç´«ç®±", 4),
        ("é«˜ç´šè—¥æ°´", "ç´«ç®±", 6),
        ("å‚³å¥‡æ­¦å™¨", "é‡‘ç®±", 2),
        ("å‚³å¥‡è£å‚™", "é‡‘ç®±", 1),
        ("å‚³èªªè—¥æ°´", "é‡‘ç®±", 3),
    ]
    
    for prize_name, box_level, quantity in sample_prizes:
        cursor.execute('''
            INSERT OR IGNORE INTO prize_pool (prize_name, box_level, quantity, remaining)
            VALUES (?, ?, ?, ?)
        ''', (prize_name, box_level, quantity, quantity))
    
    conn.commit()
    conn.close()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")

# ========== é€šç”¨å‡½æ•¸ ==========

def get_user_score(user_id):
    """å–å¾—ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        return result[0], result[1]
    return 0, 0

def update_user_score(user_id, username, amount, reason=""):
    """æ›´æ–°ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if not cursor.fetchone():
        cursor.execute(
            "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
            (user_id, username, max(amount, 0), max(amount, 0))
        )
    else:
        cursor.execute("UPDATE users SET current_score = current_score + ? WHERE user_id = ?", (amount, user_id))
        if amount > 0:
            cursor.execute("UPDATE users SET total_score = total_score + ? WHERE user_id = ?", (amount, user_id))
        cursor.execute("UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE user_id = ?", (user_id,))
    
    if amount < 0 or reason:
        cursor.execute(
            "INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason) VALUES (?, ?, ?, ?)",
            (user_id if amount < 0 else None, 
             user_id if amount > 0 else None, 
             abs(amount), 
             reason if reason else ("ç³»çµ±æ‰£é™¤" if amount < 0 else "ç³»çµ±å¢åŠ "))
        )
    
    conn.commit()
    conn.close()

def get_user_profile(user_id):
    """ç²å–ç”¨æˆ¶å®Œæ•´è³‡æ–™"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score, join_date, profession_counts, activity_stats, rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        current_score, total_score, join_date, profession_str, activity_str, rating_str = result
        
        try:
            join_date_str = datetime.strptime(join_date.split('.')[0], '%Y-%m-%d %H:%M:%S').strftime('%Y-%m-%d')
        except:
            join_date_str = join_date
        
        profession_counts = json.loads(profession_str) if profession_str else {}
        activity_stats = json.loads(activity_str) if activity_str else {}
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        return {
            'user_id': user_id,
            'current_score': current_score,
            'total_score': total_score,
            'join_date': join_date_str,
            'profession_counts': profession_counts,
            'activity_stats': activity_stats,
            'rating_stats': rating_stats
        }
    
    return None

def update_user_profession(user_id, profession):
    """æ›´æ–°ç”¨æˆ¶è·æ¥­çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT profession_counts FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        profession_str = result[0]
        profession_counts = json.loads(profession_str) if profession_str else {}
        
        if profession in profession_counts:
            profession_counts[profession] += 1
        else:
            profession_counts[profession] = 1
        
        bonus_score = PROFESSION_BONUS.get(profession, 0)
        if bonus_score > 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("UPDATE users SET current_score = current_score + ?, total_score = total_score + ? WHERE user_id = ?", 
                         (bonus_score, bonus_score, user_id))
        
        cursor.execute("UPDATE users SET profession_counts = ? WHERE user_id = ?", 
                      (json.dumps(profession_counts), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_activity(user_id, event_name, attended=True):
    """æ›´æ–°ç”¨æˆ¶æ´»å‹•çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT activity_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        activity_str = result[0]
        activity_stats = json.loads(activity_str) if activity_str else {}
        
        # ç²å–ç•¶å‰åŠæœˆæœŸ
        now = datetime.now()
        year_month = now.strftime("%Y-%m")
        day = now.day
        current_period = f"{year_month}-ä¸ŠåŠ" if day <= 15 else f"{year_month}-ä¸‹åŠ"
        
        if current_period not in activity_stats:
            activity_stats[current_period] = {"total": 0, "attended": 0}
        
        activity_stats[current_period]["total"] += 1
        if attended:
            activity_stats[current_period]["attended"] += 1
        
        cursor.execute("UPDATE users SET activity_stats = ? WHERE user_id = ?", 
                      (json.dumps(activity_stats), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_rating(user_id, rating_type):
    """æ›´æ–°ç”¨æˆ¶è©•æ ¸çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        rating_str = result[0]
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        if rating_type in rating_stats:
            rating_stats[rating_type] += 1
        else:
            rating_stats[rating_type] = 1
        
        score = RATING_SCORES.get(rating_type, 0)
        
        if score != 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("""
                UPDATE users 
                SET current_score = current_score + ?, 
                    total_score = CASE 
                                    WHEN total_score + ? > 0 THEN total_score + ?
                                    ELSE 0
                                  END
                WHERE user_id = ?
            """, (score, score, score, user_id))
        
        cursor.execute("UPDATE users SET rating_stats = ? WHERE user_id = ?", 
                      (json.dumps(rating_stats), user_id))
        
        conn.commit()
    
    conn.close()

def get_current_half_month():
    """ç²å–ç•¶å‰åŠæœˆæœŸ"""
    now = datetime.now()
    year_month = now.strftime("%Y-%m")
    day = now.day
    
    if day <= 15:
        return f"{year_month}-ä¸ŠåŠ"
    else:
        return f"{year_month}-ä¸‹åŠ"

async def end_giveaway(message_id: int, manual: bool = False):
    """çµæŸæŠ½ç"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, creator_id, prize, winner_count, participants, winners, channel_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (message_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        giveaway_id, creator_id, prize, winner_count, participants_json, winners_json, channel_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        channel = bot.get_channel(channel_id)
        
        if not channel:
            conn.close()
            return
        
        try:
            message = await channel.fetch_message(message_id)
        except:
            conn.close()
            return
        
        if participants:
            if len(participants) <= winner_count:
                winners_list = participants
            else:
                winners_list = random.sample(participants, winner_count)
            
            cursor.execute("UPDATE giveaways SET winners = ?, is_active = 0 WHERE id = ?", 
                         (json.dumps(winners_list), giveaway_id))
            conn.commit()
            
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ ğŸ‰",
                description="é–‹çå®Œæˆï¼",
                color=0x00FF00
            )
            
            new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
            new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(len(winners_list)), inline=True)
            new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
            
            winners_text = ""
            for i, winner_id in enumerate(winners_list[:5], 1):
                winners_text += f"{i}. <@{winner_id}>\n"
            
            if len(winners_list) > 5:
                winners_text += f"... é‚„æœ‰ {len(winners_list) - 5} äºº"
            
            if winners_text:
                new_embed.add_field(name="ğŸ† ç²çè€…", value=winners_text, inline=False)
            
            await message.edit(embed=new_embed)
            await message.clear_reactions()
            
            for winner_id in winners_list:
                await channel.send(f"ğŸ‰ æ­å–œ <@{winner_id}> ç²å¾—äº† **{prize}**ï¼")
        else:
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ",
                description="ç„¡äººåƒèˆ‡æŠ½ç" + ("ï¼ˆæ‰‹å‹•çµæŸï¼‰" if manual else ""),
                color=0xFF0000
            )
            await message.edit(embed=new_embed)
            await message.clear_reactions()
        
        conn.close()
        
    except Exception as e:
        print(f"çµæŸæŠ½çéŒ¯èª¤: {e}")

async def end_evaluation(event_id, channel, event_name):
    """çµæŸè©•æ ¸æ´»å‹•"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT participants, professions, ratings, rating_message_id 
            FROM evaluation_events 
            WHERE id = ?
        """, (event_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        participants_json, professions_json, ratings_json, rating_message_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        professions = json.loads(professions_json) if professions_json else {}
        ratings = json.loads(ratings_json) if ratings_json else {}
        
        cursor.execute("UPDATE evaluation_events SET is_active = 0 WHERE id = ?", (event_id,))
        conn.commit()
        conn.close()
        
        try:
            rating_message = await channel.fetch_message(rating_message_id)
            await rating_message.clear_reactions()
            
            end_embed = discord.Embed(
                title=f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸï¼š{event_name}",
                description="æ­¤æ´»å‹•çš„è©•æ ¸éšæ®µå·²ç¶“çµæŸï¼Œæ„Ÿè¬æ‰€æœ‰åƒèˆ‡è€…ï¼",
                color=discord.Color.green()
            )
            
            end_embed.add_field(name="ğŸ“Š çµ±è¨ˆä¿¡æ¯", value=f"**ç¸½åƒèˆ‡äººæ•¸ï¼š** {len(participants)} äºº", inline=False)
            
            rating_summary = {}
            for user_id, rating_list in ratings.items():
                if rating_list:
                    latest_rating = rating_list[-1]["rating"]
                    rating_summary[latest_rating] = rating_summary.get(latest_rating, 0) + 1
            
            rating_text = ""
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_summary.get(rating_type, 0)
                if count > 0:
                    rating_text += f"**{rating_type}ï¼š** {count}äºº\n"
            
            if rating_text:
                end_embed.add_field(name="â­ è©•ç´šåˆ†ä½ˆ", value=rating_text, inline=False)
            
            await rating_message.edit(embed=end_embed)
            
        except Exception as e:
            print(f"æ›´æ–°è©•æ ¸è¨Šæ¯éŒ¯èª¤: {e}")
        
        summary_embed = discord.Embed(
            title=f"ğŸ æ´»å‹•ç¸½çµï¼š{event_name}",
            description="è©•æ ¸æ´»å‹•å·²æ­£å¼çµæŸï¼",
            color=discord.Color.gold()
        )
        
        summary_embed.add_field(name="ğŸ‘¥ åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ® è·æ¥­é¸æ“‡", value=f"{len(professions)} äºº", inline=True)
        summary_embed.add_field(name="â­ è©•æ ¸å®Œæˆ", value=f"{len(ratings)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ“Š è©•ç´šåˆ†ä½ˆ", value=f"{len(rating_summary)} ç¨®è©•ç´š", inline=True)
        
        await channel.send(embed=summary_embed)
        
        print(f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸ: {event_name}")
        
    except Exception as e:
        print(f"çµæŸè©•æ ¸æ´»å‹•éŒ¯èª¤: {e}")

# ========== äº‹ä»¶è™•ç† ==========

@bot.event
async def setup_hook():
    """æ©Ÿå™¨äººè¨­ç½®é‰¤å­"""
    print("ğŸ”„ æ­£åœ¨è¨­ç½®æŒ‡ä»¤æ¨¹...")
    try:
        synced = await bot.tree.sync()
        print(f"âœ… æŒ‡ä»¤æ¨¹è¨­ç½®å®Œæˆï¼Œå·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
    except Exception as e:
        print(f"âŒ è¨­ç½®æŒ‡ä»¤æ¨¹å¤±æ•—: {e}")

@bot.event
async def on_ready():
    """æ©Ÿå™¨äººä¸Šç·š"""
    print(f"\n{'='*60}")
    print(f"ğŸ¤– {BOT_NAME} å·²ä¸Šç·š")
    print(f"ğŸ“Š ä¼ºæœå™¨æ•¸é‡: {len(bot.guilds)}")
    print(f"{'='*60}")
    
    init_db()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")
    
    # ç­‰å¾…ä¸€ä¸‹å†åŒæ­¥æŒ‡ä»¤
    await asyncio.sleep(2)
    
    try:
        print("ğŸ”„ æ­£åœ¨åŒæ­¥æŒ‡ä»¤...")
        
        # å…ˆæ¸…é™¤æ‰€æœ‰ç¾æœ‰æŒ‡ä»¤
        bot.tree.clear_commands(guild=None)
        
        # é‡æ–°åŒæ­¥å…¨å±€æŒ‡ä»¤
        synced = await bot.tree.sync()
        
        print(f"âœ… å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        
        # é¡¯ç¤ºå¯ç”¨æŒ‡ä»¤
        if synced:
            print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
            for cmd in synced:
                print(f"  â€¢ /{cmd.name} - {cmd.description}")
        
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")
        # å¦‚æœå¤±æ•—ï¼Œå˜—è©¦å»¶é²å¾Œå†è©¦ä¸€æ¬¡
        try:
            await asyncio.sleep(3)
            synced = await bot.tree.sync()
            print(f"âœ… é‡è©¦å¾Œå·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤")
        except Exception as e2:
            print(f"âŒ é‡è©¦ä¹Ÿå¤±æ•—: {e2}")
    
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="/help æŸ¥çœ‹æŒ‡ä»¤"
        )
    )
    
    print(f"\nğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼")

@bot.event
async def on_raw_reaction_add(payload):
    """è™•ç†åæ‡‰äº‹ä»¶"""
    if payload.user_id == bot.user.id:
        return
    
    try:
        emoji = str(payload.emoji)
        user_id = payload.user_id
        
        channel = bot.get_channel(payload.channel_id)
        if not channel:
            return
        
        try:
            message = await channel.fetch_message(payload.message_id)
        except:
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸çµæŸåæ‡‰
        cursor.execute("""
            SELECT id, channel_id, event_name 
            FROM evaluation_events 
            WHERE rating_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        rating_event = cursor.fetchone()
        
        if rating_event and emoji == RATING_END_EMOJI:
            event_id, event_channel_id, event_name = rating_event
            
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥çµæŸè©•æ ¸æ´»å‹•ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            confirm_embed = discord.Embed(
                title="ğŸ ç¢ºèªçµæŸè©•æ ¸æ´»å‹•",
                description=f"ä½ ç¢ºå®šè¦çµæŸ **{event_name}** çš„è©•æ ¸éšæ®µå—ï¼Ÿ",
                color=discord.Color.orange()
            )
            
            class ConfirmEndView(discord.ui.View):
                def __init__(self, event_id, channel, event_name):
                    super().__init__(timeout=60)
                    self.event_id = event_id
                    self.channel = channel
                    self.event_name = event_name
                
                @discord.ui.button(label="ç¢ºå®šçµæŸ", style=discord.ButtonStyle.danger, emoji="âœ…")
                async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.defer()
                    await end_evaluation(self.event_id, self.channel, self.event_name)
                    
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
                    
                    await interaction.followup.send(f"âœ… å·²æˆåŠŸçµæŸ **{self.event_name}** çš„è©•æ ¸éšæ®µï¼")
                
                @discord.ui.button(label="å–æ¶ˆ", style=discord.ButtonStyle.secondary, emoji="âŒ")
                async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.send_message("å·²å–æ¶ˆçµæŸè©•æ ¸æ´»å‹•", ephemeral=True)
                    
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
            
            view = ConfirmEndView(event_id, channel, event_name)
            await channel.send(f"<@{user_id}>", embed=confirm_embed, view=view)
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸åæ‡‰
        if rating_event and emoji in RATING_EMOJIS:
            event_id, event_channel_id, event_name = rating_event
            rating_type = RATING_EMOJIS[emoji]
            
            print(f"æª¢æ¸¬åˆ°è©•æ ¸åæ‡‰: event_id={event_id}, rating_type={rating_type}, user_id={user_id}")
            
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥é€²è¡Œè©•æ ¸ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            participants = []
            if result and result[0]:
                participants = json.loads(result[0])
            
            if not participants:
                await channel.send("âŒ æ²’æœ‰åƒèˆ‡è€…å¯ä»¥è©•æ ¸", delete_after=5)
                conn.close()
                return
            
            print(f"æ´»å‹• {event_name} æœ‰ {len(participants)} ä½åƒèˆ‡è€…å¯ä»¥è©•æ ¸")
            
            class ParticipantSelectView(discord.ui.View):
                def __init__(self, participants, event_id, rating_type, channel, bot_instance):
                    super().__init__(timeout=60)
                    self.participants = participants
                    self.event_id = event_id
                    self.rating_type = rating_type
                    self.channel = channel
                    self.bot = bot_instance
                    
                    options = []
                    for pid in participants[:25]:
                        member = self.bot.get_user(int(pid))
                        display_name = member.display_name if member else f"ç”¨æˆ¶ID: {pid}"
                        options.append(discord.SelectOption(
                            label=display_name[:100],
                            value=str(pid),
                            description=f"é»æ“Šé¸æ“‡æ­¤ç”¨æˆ¶é€²è¡Œ {rating_type} è©•æ ¸"
                        ))
                    
                    select = discord.ui.Select(
                        placeholder=f"é¸æ“‡è¦è©•æ ¸ç‚º {rating_type} çš„åƒèˆ‡è€…",
                        options=options,
                        min_values=1,
                        max_values=1
                    )
                    
                    async def select_callback(interaction: discord.Interaction):
                        if not interaction.user.guild_permissions.administrator:
                            await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                            return
                        
                        selected_user_id = int(select.values[0])
                        selected_member = self.bot.get_user(selected_user_id)
                        display_name = selected_member.display_name if selected_member else f"ç”¨æˆ¶ID: {selected_user_id}"
                        
                        print(f"é¸æ“‡äº†ç”¨æˆ¶ {display_name} ({selected_user_id}) é€²è¡Œ {rating_type} è©•æ ¸")
                        
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        
                        cursor.execute("SELECT ratings FROM evaluation_events WHERE id = ?", (self.event_id,))
                        result = cursor.fetchone()
                        
                        ratings = {}
                        if result and result[0]:
                            ratings = json.loads(result[0])
                        
                        old_rating = None
                        if str(selected_user_id) in ratings and ratings[str(selected_user_id)]:
                            old_rating = ratings[str(selected_user_id)][-1]["rating"] if ratings[str(selected_user_id)] else None
                        
                        if str(selected_user_id) not in ratings:
                            ratings[str(selected_user_id)] = []
                        
                        ratings[str(selected_user_id)].append({
                            "rater": interaction.user.id,
                            "rating": self.rating_type,
                            "time": datetime.now().isoformat()
                        })
                        
                        cursor.execute("UPDATE evaluation_events SET ratings = ? WHERE id = ?", 
                                     (json.dumps(ratings), self.event_id))
                        conn.commit()
                        conn.close()
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            update_user_score(selected_user_id, display_name, -old_score, f"è©•ç´šè®Šæ›´: {old_rating} â†’ {self.rating_type}")
                            print(f"ç§»é™¤èˆŠè©•ç´šç©åˆ†: {old_rating} (-{old_score}åˆ†)")
                        
                        new_score = RATING_SCORES.get(self.rating_type, 0)
                        update_user_rating(selected_user_id, self.rating_type)
                        
                        if new_score != 0:
                            update_user_score(selected_user_id, display_name, new_score, f"æ´»å‹•è©•æ ¸: {self.rating_type}")
                            print(f"æ·»åŠ æ–°è©•ç´šç©åˆ†: {self.rating_type} (+{new_score}åˆ†)")
                        
                        score_change = RATING_SCORES.get(self.rating_type, 0)
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            result_text = f"å·²å°‡ <@{selected_user_id}> ({display_name}) çš„è©•ç´šå¾ **{old_rating}** ({old_score}åˆ†) è®Šæ›´ç‚º **{self.rating_type}** ({'+' if score_change > 0 else ''}{score_change}åˆ†)"
                        else:
                            result_text = f"å·²ç‚º <@{selected_user_id}> ({display_name}) è©•æ ¸ï¼š**{self.rating_type}** ({'+' if score_change > 0 else ''}{score_change}åˆ†)"
                        
                        result_embed = discord.Embed(
                            title="âœ… è©•æ ¸å®Œæˆ",
                            description=result_text,
                            color=discord.Color.green() if score_change >= 0 else discord.Color.red()
                        )
                        
                        result_embed.add_field(name="è©•æ ¸è€…", value=interaction.user.mention, inline=True)
                        result_embed.add_field(name="æ–°è©•ç´š", value=self.rating_type, inline=True)
                        result_embed.add_field(name="ç©åˆ†è®Šå‹•", value=f"{score_change} åˆ†", inline=True)
                        
                        await interaction.response.send_message(embed=result_embed)
                        
                        for child in self.children:
                            child.disabled = True
                        await interaction.message.edit(view=self)
                    
                    select.callback = select_callback
                    self.add_item(select)
            
            view = ParticipantSelectView(participants, event_id, rating_type, channel, bot)
            select_message = await channel.send(f"<@{user_id}> è«‹é¸æ“‡è¦è©•æ ¸ç‚º **{rating_type}** çš„åƒèˆ‡è€…ï¼š", view=view)
            print(f"å·²ç™¼é€é¸æ“‡è¦–çª—: message_id={select_message.id}")
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºæŠ½çè¨Šæ¯
        cursor.execute("""
            SELECT id, participants, creator_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (payload.message_id,))
        giveaway = cursor.fetchone()
        
        if giveaway:
            giveaway_id, participants_json, creator_id = giveaway
            
            if emoji == "ğŸ«":
                participants = json.loads(participants_json) if participants_json else []
                
                if user_id not in participants:
                    participants.append(user_id)
                    cursor.execute("UPDATE giveaways SET participants = ? WHERE id = ?", 
                                 (json.dumps(participants), giveaway_id))
                    conn.commit()
                    
                    try:
                        if message.embeds:
                            embed = message.embeds[0]
                            new_embed = discord.Embed(
                                title=embed.title,
                                description=embed.description,
                                color=embed.color
                            )
                            
                            for field in embed.fields:
                                if field.name == "ğŸ« åƒèˆ‡äººæ•¸":
                                    new_embed.add_field(
                                        name="ğŸ« åƒèˆ‡äººæ•¸", 
                                        value=f"{len(participants)} äºº", 
                                        inline=field.inline
                                    )
                                else:
                                    new_embed.add_field(
                                        name=field.name, 
                                        value=field.value, 
                                        inline=field.inline
                                    )
                            
                            if embed.footer:
                                new_embed.set_footer(text=embed.footer.text)
                            
                            await message.edit(embed=new_embed)
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            elif emoji == "â¹ï¸" and user_id == creator_id:
                await end_giveaway(payload.message_id, manual=True)
                await channel.send(f"â¹ï¸ ä¸»è¾¦äººæ‰‹å‹•çµæŸäº†æŠ½çï¼")
        
        # è™•ç†è©•æ ¸æ´»å‹•ç°½åˆ°
        cursor.execute("""
            SELECT id, participants, signup_end_time 
            FROM evaluation_events 
            WHERE signup_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        signup_event = cursor.fetchone()
        
        if signup_event and emoji == "âœ…":
            event_id, participants_json, signup_end_time_str = signup_event
            
            try:
                if signup_end_time_str:
                    try:
                        signup_end_time = datetime.strptime(signup_end_time_str.split('.')[0], '%Y-%m-%d %H:%M:%S')
                    except:
                        try:
                            signup_end_time = datetime.strptime(signup_end_time_str, '%Y-%m-%d %H:%M:%S.%f')
                        except:
                            signup_end_time = None
                else:
                    signup_end_time = None
                
                if signup_end_time and datetime.now() > signup_end_time:
                    try:
                        await message.remove_reaction("âœ…", payload.member)
                        await channel.send(f"âŒ <@{user_id}> ç°½åˆ°æ™‚é–“å·²éï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as time_error:
                print(f"æ™‚é–“è§£æéŒ¯èª¤: {time_error}")
            
            participants = json.loads(participants_json) if participants_json else []
            
            if user_id not in participants:
                participants.append(user_id)
                cursor.execute("UPDATE evaluation_events SET participants = ? WHERE id = ?", 
                             (json.dumps(participants), event_id))
                conn.commit()
                
                print(f"âœ… ç”¨æˆ¶ {user_id} æˆåŠŸç°½åˆ°æ´»å‹• {event_id}")
                
                try:
                    if message.embeds:
                        embed = message.embeds[0]
                        new_embed = discord.Embed(
                            title=embed.title,
                            description=embed.description,
                            color=embed.color
                        )
                        
                        for field in embed.fields:
                            if field.name == "ğŸ‘¥ å·²ç°½åˆ°":
                                new_embed.add_field(
                                    name="ğŸ‘¥ å·²ç°½åˆ°", 
                                    value=f"{len(participants)} äºº", 
                                    inline=field.inline
                                )
                            elif field.name == "â±ï¸ å‰©é¤˜æ™‚é–“":
                                new_embed.add_field(
                                    name=field.name,
                                    value=field.value,
                                    inline=field.inline
                                )
                            else:
                                new_embed.add_field(
                                    name=field.name, 
                                    value=field.value, 
                                    inline=field.inline
                                )
                        
                        if embed.footer:
                            new_embed.set_footer(text=embed.footer.text)
                        
                        await message.edit(embed=new_embed)
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
        
        # è™•ç†è·æ¥­é¸æ“‡
        cursor.execute("""
            SELECT id, professions 
            FROM evaluation_events 
            WHERE profession_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        profession_event = cursor.fetchone()
        
        if profession_event and emoji in PROFESSION_EMOJIS:
            event_id, professions_json = profession_event
            profession_name = PROFESSION_EMOJIS[emoji]
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            if result and result[0]:
                participants = json.loads(result[0])
                
                if user_id in participants:
                    professions = json.loads(professions_json) if professions_json else {}
                    
                    if str(user_id) not in professions:
                        professions[str(user_id)] = profession_name
                        cursor.execute("UPDATE evaluation_events SET professions = ? WHERE id = ?", 
                                     (json.dumps(professions), event_id))
                        conn.commit()
                        
                        update_user_profession(user_id, profession_name)
                        
                        try:
                            bonus = PROFESSION_BONUS.get(profession_name, 0)
                            bonus_text = f"ï¼ˆç²å¾—è·æ¥­åŠ æˆï¼š+{bonus}ç©åˆ†ï¼‰" if bonus > 0 else ""
                            await channel.send(f"âœ… <@{user_id}> å·²é¸æ“‡è·æ¥­ï¼š**{profession_name}**{bonus_text}", delete_after=5)
                        except:
                            pass
                    else:
                        try:
                            await message.remove_reaction(emoji, payload.member)
                            await channel.send(f"âš ï¸ <@{user_id}> ä½ å·²ç¶“é¸æ“‡éè·æ¥­äº†ï¼", delete_after=5)
                        except:
                            pass
                else:
                    try:
                        await message.remove_reaction(emoji, payload.member)
                        await channel.send(f"âŒ <@{user_id}> è«‹å…ˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼", delete_after=5)
                    except:
                        pass
        
        conn.close()
        
    except Exception as e:
        print(f"è™•ç†åæ‡‰éŒ¯èª¤: {e}")
        import traceback
        traceback.print_exc()

# ========== æ–œæ§“æŒ‡ä»¤ ==========

# æŒ‡ä»¤ 1: help
@bot.tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯")
async def help_slash(interaction: discord.Interaction):
    """é¡¯ç¤ºå¹«åŠ©"""
    embed = discord.Embed(
        title="ğŸ¤– å°é›²æ©Ÿæ¢°äºº - å¹«åŠ©ä¸­å¿ƒ",
        description="ä»¥ä¸‹æ˜¯å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ï¼š",
        color=0x7289DA
    )
    
    embed.add_field(
        name="ğŸ‘¤ ç”¨æˆ¶æŒ‡ä»¤",
        value=(
            "`/help` - é¡¯ç¤ºæ­¤å¹«åŠ©è¨Šæ¯\n"
            "`/profile` - æŸ¥çœ‹æˆ‘çš„æ•¸æ“š\n"
            "`/giveaway` - å‰µå»ºæŠ½ç\n"
            "`/score_draw` - ä½¿ç”¨ç©åˆ†æŠ½ç\n"
            "`/score_transfer` - è½‰ç§»ç©åˆ†\n"
            "`/prizelist` - æŸ¥çœ‹å½©æ± åˆ—è¡¨\n"
            "`/random_team` - éš¨æ©Ÿåˆ†çµ„"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ› ï¸ ç®¡ç†å“¡æŒ‡ä»¤",
        value=(
            "`/add_prize` - èª¿æ•´å½©æ± \n"
            "`/add_score` - åŠ æ¸›ç©åˆ†\n"
            "`/create_event` - å‰µå»ºè©•æ ¸æ´»å‹•\n"
            "`/all_profiles` - æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™\n"
            "`/attendance_stats` - æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ\n"
            "`/sync` - åŒæ­¥æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰\n"
            "`/ping` - æ¸¬è©¦æ©Ÿå™¨äººå»¶é²"
        ),
        inline=False
    )
    
    embed.set_footer(text="å…±13å€‹æŒ‡ä»¤ | ä½¿ç”¨ / é–‹é ­è¼¸å…¥æŒ‡ä»¤")
    await interaction.response.send_message(embed=embed)

# æŒ‡ä»¤ 2: sync
@bot.tree.command(name="sync", description="åŒæ­¥æ–œæ§“æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰")
async def sync_slash(interaction: discord.Interaction):
    """åŒæ­¥æŒ‡ä»¤"""
    await interaction.response.defer(ephemeral=True)
    
    if interaction.user.id not in OWNER_IDS:
        embed = discord.Embed(
            title="âŒ æ¬Šé™ä¸è¶³",
            description="åªæœ‰æ©Ÿå™¨äººæ“æœ‰è€…å¯ä»¥ä½¿ç”¨æ­¤æŒ‡ä»¤",
            color=0xFF0000
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        return
    
    try:
        print("ğŸ”„ æ‰‹å‹•åŒæ­¥æŒ‡ä»¤ä¸­...")
        bot.tree.clear_commands(guild=None)
        synced = await bot.tree.sync()
        
        embed = discord.Embed(
            title="ğŸ”„ æŒ‡ä»¤åŒæ­¥å®Œæˆ",
            description=f"å·²åŒæ­¥ {len(synced)} å€‹æŒ‡ä»¤åˆ°æ‰€æœ‰ä¼ºæœå™¨",
            color=0x43B581
        )
        
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åŒæ­¥å¤±æ•—",
            description=f"éŒ¯èª¤è¨Šæ¯: {str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed, ephemeral=True)

# æŒ‡ä»¤ 3: profile
@bot.tree.command(name="profile", description="æŸ¥çœ‹æˆ‘çš„æ•¸æ“š")
async def profile_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        user_id = interaction.user.id
        username = interaction.user.name
        
        profile = get_user_profile(user_id)
        
        if not profile:
            conn = sqlite3.connect(DB_NAME)
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
                (user_id, username, 0, 0)
            )
            conn.commit()
            conn.close()
            
            profile = {
                'user_id': user_id,
                'current_score': 0,
                'total_score': 0,
                'join_date': datetime.now().strftime('%Y-%m-%d'),
                'profession_counts': {},
                'activity_stats': {},
                'rating_stats': {}
            }
        
        current_score = profile['current_score']
        total_score = profile['total_score']
        join_date_str = profile['join_date']
        profession_counts = profile['profession_counts']
        activity_stats = profile['activity_stats']
        rating_stats = profile['rating_stats']
        
        current_period = get_current_half_month()
        period_data = activity_stats.get(current_period, {})
        total_events = period_data.get('total', 0)
        attended_events = period_data.get('attended', 0)
        attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
        
        embed = discord.Embed(
            title=f"ğŸ“Š {username} çš„è©•æ ¸æ•¸æ“š",
            color=0x43B581
        )
        
        attendance_info = (
            f"**ç•¶å‰åŠæœˆæœŸï¼š** {current_period}\n"
            f"**ç¸½æ´»å‹•æ•¸ï¼š** {total_events} æ¬¡\n"
            f"**å¯¦éš›å‡ºå¸­ï¼š** {attended_events} æ¬¡\n"
            f"**å‡ºå¸­ç‡ï¼š** {attendance_rate:.1f}%\n"
        )
        
        embed.add_field(
            name="ğŸ“… åŠæœˆæœŸå‡ºå¸­ç‡",
            value=attendance_info,
            inline=False
        )
        
        score_info = f"**ç•¶å‰ç©åˆ†ï¼š** {current_score} åˆ†\n"
        score_info += f"**ç¸½ç²å¾—ç©åˆ†ï¼š** {total_score} åˆ†\n\n"
        score_info += f"**ç©åˆ†è¦å‰‡ï¼š**\n"
        score_info += f"â€¢ ç°½åˆ°ï¼š+{SIGNUP_SCORE}åˆ†\n"
        for profession, bonus in PROFESSION_BONUS.items():
            if bonus > 0:
                score_info += f"â€¢ {profession}ï¼š+{bonus}åˆ†\n"
        score_info += f"â€¢ å„ªç§€ï¼š+{RATING_SCORES['å„ªç§€']}åˆ†\n"
        score_info += f"â€¢ è‰¯å¥½ï¼š+{RATING_SCORES['è‰¯å¥½']}åˆ†\n"
        score_info += f"â€¢ æ™®é€šï¼š{RATING_SCORES['æ™®é€š']}åˆ†ï¼ˆé è¨­ï¼‰\n"
        score_info += f"â€¢ ä¸åˆæ ¼ï¼š{RATING_SCORES['ä¸åˆæ ¼']}åˆ†"
        
        embed.add_field(
            name="ğŸ’° ç©åˆ†çµ±è¨ˆ",
            value=score_info,
            inline=False
        )
        
        if profession_counts:
            profession_info = ""
            total_plays = sum(profession_counts.values())
            for profession, count in profession_counts.items():
                percentage = (count / total_plays * 100) if total_plays > 0 else 0
                profession_info += f"**{profession}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
        else:
            profession_info = "å°šæœªè¨˜éŒ„è·æ¥­æ•¸æ“š"
        
        embed.add_field(
            name="ğŸ® è·æ¥­çµ±è¨ˆ",
            value=profession_info,
            inline=False
        )
        
        if rating_stats:
            rating_info = ""
            total_ratings = sum(rating_stats.values())
            total_rating_score = 0
            
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_stats.get(rating_type, 0)
                if count > 0:
                    percentage = (count / total_ratings * 100) if total_ratings > 0 else 0
                    score = RATING_SCORES.get(rating_type, 0)
                    rating_info += f"**{rating_type}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
                    total_rating_score += count * score
            
            if total_ratings > 0:
                rating_info += f"\n**è©•æ ¸ç¸½ç²å¾—ç©åˆ†ï¼š** {total_rating_score} åˆ†"
        else:
            rating_info = "å°šæœªæœ‰è©•æ ¸è¨˜éŒ„"
        
        embed.add_field(
            name="â­ è©•æ ¸çµ±è¨ˆ",
            value=rating_info,
            inline=False
        )
        
        embed.add_field(name="ç”¨æˆ¶ID", value=f"`{user_id}`", inline=True)
        embed.add_field(name="åŠ å…¥æ—¥æœŸ", value=join_date_str, inline=True)
        
        if interaction.user.avatar:
            embed.set_thumbnail(url=interaction.user.avatar.url)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ ç™¼ç”ŸéŒ¯èª¤",
            description=f"ç„¡æ³•è®€å–ç”¨æˆ¶è³‡æ–™ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 4: giveaway
@bot.tree.command(name="giveaway", description="å‰µå»ºæŠ½çæ´»å‹•")
@app_commands.describe(
    prize="çå“å…§å®¹",
    duration="æŠ½çæŒçºŒæ™‚é–“ï¼ˆä¾‹å¦‚ï¼š60s, 1m, 1h, 1dï¼‰",
    winners="ç²çäººæ•¸"
)
async def giveaway_slash(
    interaction: discord.Interaction,
    prize: str,
    duration: str = "1h",
    winners: int = 1
):
    """å‰µå»ºæŠ½ç"""
    await interaction.response.defer()
    
    try:
        duration_lower = duration.lower().strip()
        seconds = 3600
        
        if duration_lower.endswith('s'):
            seconds = int(duration_lower[:-1])
        elif duration_lower.endswith('m'):
            seconds = int(duration_lower[:-1]) * 60
        elif duration_lower.endswith('h'):
            seconds = int(duration_lower[:-1]) * 3600
        elif duration_lower.endswith('d'):
            seconds = int(duration_lower[:-1]) * 86400
        elif duration_lower.isdigit():
            seconds = int(duration_lower)
        
        if seconds < 10:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“å¿…é ˆè‡³å°‘10ç§’ï¼")
            return
        
        if seconds > 86400 * 7:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“ä¸èƒ½è¶…é7å¤©ï¼")
            return
        
        end_time = datetime.now() + timedelta(seconds=seconds)
        
        if seconds < 60:
            time_display = f"{seconds}ç§’"
        elif seconds < 3600:
            time_display = f"{seconds//60}åˆ†{seconds%60}ç§’"
        elif seconds < 86400:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            time_display = f"{hours}å°æ™‚{minutes}åˆ†"
        else:
            days = seconds // 86400
            hours = (seconds % 86400) // 3600
            time_display = f"{days}å¤©{hours}å°æ™‚"
        
        embed = discord.Embed(
            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
            color=0xFFD700
        )
        
        embed.add_field(name="ğŸ çå“", value=prize, inline=True)
        embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
        embed.add_field(name="â° çµæŸæ™‚é–“", value=time_display, inline=True)
        embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value="0 äºº", inline=True)
        embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
        embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
        
        creator_name = interaction.user.display_name
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
        giveaway_id = f"giveaway_{int(time.time())}_{random.randint(1000, 9999)}"
        
        embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{current_time}")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ«")
        await message.add_reaction("â¹ï¸")
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO giveaways (creator_id, prize, winner_count, end_time, message_id, channel_id)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (interaction.user.id, prize, winners, end_time, message.id, interaction.channel.id))
        conn.commit()
        conn.close()
        
        print(f"âœ… æŠ½çå·²å‰µå»º: çå“={prize}, æ™‚é–“={seconds}ç§’, è¨Šæ¯ID={message.id}")
        
        async def countdown_timer():
            remaining = seconds
            last_update = time.time()
            
            while remaining > 0:
                await asyncio.sleep(1)
                remaining -= 1
                
                if time.time() - last_update >= 30:
                    if remaining < 60:
                        time_display = f"{remaining}ç§’"
                    elif remaining < 3600:
                        time_display = f"{remaining//60}åˆ†{remaining%60}ç§’"
                    elif remaining < 86400:
                        hours = remaining // 3600
                        minutes = (remaining % 3600) // 60
                        time_display = f"{hours}å°æ™‚{minutes}åˆ†"
                    else:
                        days = remaining // 86400
                        hours = (remaining % 86400) // 3600
                        time_display = f"{days}å¤©{hours}å°æ™‚"
                    
                    try:
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        cursor.execute("SELECT participants FROM giveaways WHERE message_id = ?", (message.id,))
                        result = cursor.fetchone()
                        participants_count = 0
                        if result and result[0]:
                            participants = json.loads(result[0])
                            participants_count = len(participants)
                        conn.close()
                        
                        new_embed = discord.Embed(
                            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
                            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
                            color=0xFFD700
                        )
                        
                        new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
                        new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
                        new_embed.add_field(name="â° çµæŸæ™‚é–“", value=f"{time_display}å…§", inline=True)
                        new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{participants_count} äºº", inline=True)
                        new_embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
                        new_embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
                        
                        new_embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{datetime.now().strftime('%Y-%m-%d %H:%M')}")
                        
                        await message.edit(embed=new_embed)
                        last_update = time.time()
                        
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            await end_giveaway(message.id)
        
        asyncio.create_task(countdown_timer())
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 5: score_draw
@bot.tree.command(name="score_draw", description="ä½¿ç”¨ç©åˆ†æŠ½ç")
async def score_draw_slash(interaction: discord.Interaction):
    """ç©åˆ†æŠ½ç"""
    await interaction.response.defer()
    
    try:
        current_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ² ç©åˆ†æŠ½çç³»çµ±",
            description="è«‹é¸æ“‡è¦æ‰£é™¤çš„ç©åˆ†é€²è¡ŒæŠ½çï¼š",
            color=0x9B59B6
        )
        
        embed.add_field(
            name="ğŸŸ¢ 50ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 70%\nâ€¢ è—ç®± 25%\nâ€¢ ç´«ç®± 4.5%\nâ€¢ é‡‘ç®± 0.5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ”µ 100ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 50%\nâ€¢ è—ç®± 40%\nâ€¢ ç´«ç®± 9%\nâ€¢ é‡‘ç®± 1%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸŸ£ 500ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 10%\nâ€¢ è—ç®± 65%\nâ€¢ ç´«ç®± 20%\nâ€¢ é‡‘ç®± 5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ’° ä½ çš„ç©åˆ†",
            value=f"{current_score} åˆ†",
            inline=False
        )
        
        embed.set_footer(text="é»æ“Šä¸‹æ–¹å°æ‡‰çš„emojié¸æ“‡æŠ½çé¡å‹")
        
        class ScoreDrawView(discord.ui.View):
            def __init__(self, user_id):
                super().__init__(timeout=60)
                self.user_id = user_id
            
            @discord.ui.button(label="50åˆ†", style=discord.ButtonStyle.success, emoji="ğŸŸ¢", row=0)
            async def fifty_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 50)
            
            @discord.ui.button(label="100åˆ†", style=discord.ButtonStyle.primary, emoji="ğŸ”µ", row=0)
            async def hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 100)
            
            @discord.ui.button(label="500åˆ†", style=discord.ButtonStyle.secondary, emoji="ğŸŸ£", row=1)
            async def five_hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 500)
            
            async def process_draw(self, interaction: discord.Interaction, score_cost: int):
                if interaction.user.id != self.user_id:
                    await interaction.response.send_message("âŒ é€™ä¸æ˜¯ä½ çš„æŠ½çï¼", ephemeral=True)
                    return
                
                current_score, _ = get_user_score(interaction.user.id)
                if current_score < score_cost:
                    await interaction.response.send_message(
                        f"âŒ ç©åˆ†ä¸è¶³ï¼éœ€è¦ {score_cost} åˆ†ï¼Œä½ ç›®å‰æœ‰ {current_score} åˆ†",
                        ephemeral=True
                    )
                    return
                
                weights = {
                    50: {"ç¶ ç®±": 70, "è—ç®±": 25, "ç´«ç®±": 4.5, "é‡‘ç®±": 0.5},
                    100: {"ç¶ ç®±": 50, "è—ç®±": 40, "ç´«ç®±": 9, "é‡‘ç®±": 1},
                    500: {"ç¶ ç®±": 10, "è—ç®±": 65, "ç´«ç®±": 20, "é‡‘ç®±": 5}
                }
                
                box_weights = weights[score_cost]
                box_types = list(box_weights.keys())
                box_weights_list = list(box_weights.values())
                selected_box = random.choices(box_types, weights=box_weights_list, k=1)[0]
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute(
                    "SELECT id, prize_name FROM prize_pool WHERE box_level = ? AND remaining > 0 ORDER BY RANDOM() LIMIT 1",
                    (selected_box,)
                )
                result = cursor.fetchone()
                
                if not result:
                    await interaction.response.send_message(f"âŒ {selected_box}ä¸­æ²’æœ‰å¯ç”¨çå“ï¼", ephemeral=True)
                    conn.close()
                    return
                
                prize_id, prize_name = result
                
                update_user_score(interaction.user.id, interaction.user.name, -score_cost, f"ç©åˆ†æŠ½ç ({selected_box})")
                cursor.execute("UPDATE prize_pool SET remaining = remaining - 1 WHERE id = ?", (prize_id,))
                
                cursor.execute('''
                    INSERT INTO score_draws (creator_id, score_cost, box_level, winner_prize, winner_id)
                    VALUES (?, ?, ?, ?, ?)
                ''', (interaction.user.id, score_cost, selected_box, prize_name, interaction.user.id))
                
                conn.commit()
                conn.close()
                
                new_current_score, _ = get_user_score(interaction.user.id)
                
                result_embed = discord.Embed(
                    title="ğŸ‰ æŠ½ççµæœ",
                    description=f"ä½ æŠ½ä¸­äº† **{prize_name}**ï¼",
                    color=0x00FF00
                )
                
                result_embed.add_field(name="æ‰£é™¤ç©åˆ†", value=f"{score_cost} åˆ†", inline=True)
                result_embed.add_field(name="å¯¶ç®±é¡å‹", value=selected_box, inline=True)
                result_embed.add_field(name="ä¸­çæ©Ÿç‡", value=f"{box_weights[selected_box]}%", inline=True)
                result_embed.add_field(name="å‰©é¤˜ç©åˆ†", value=f"{new_current_score} åˆ†", inline=True)
                result_embed.add_field(name="çå“åç¨±", value=prize_name, inline=False)
                
                await interaction.response.send_message(embed=result_embed, ephemeral=False)
                
                for child in self.children:
                    child.disabled = True
                
                await interaction.message.edit(view=self)
        
        view = ScoreDrawView(interaction.user.id)
        await interaction.followup.send(embed=embed, view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 6: score_transfer
@bot.tree.command(name="score_transfer", description="è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="è½‰ç§»ç©åˆ†",
    reason="åŸå› ï¼ˆå¯é¸ï¼‰"
)
async def score_transfer_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: Optional[str] = None
):
    """è½‰ç§»ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if amount <= 0:
            await interaction.followup.send("âŒ ç©åˆ†å¿…é ˆå¤§æ–¼ 0")
            return
        
        if user.id == interaction.user.id:
            await interaction.followup.send("âŒ ä¸èƒ½è½‰ç§»ç©åˆ†çµ¦è‡ªå·±")
            return
        
        sender_score, _ = get_user_score(interaction.user.id)
        
        if sender_score < amount:
            await interaction.followup.send(f"âŒ ä½ çš„ç©åˆ†ä¸è¶³ï¼éœ€è¦ {amount} åˆ†ï¼Œä½ ç›®å‰æœ‰ {sender_score} åˆ†")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        update_user_score(interaction.user.id, interaction.user.name, -amount, f"è½‰ç§»çµ¦ {user.name}")
        update_user_score(user.id, user.name, amount, f"ä¾†è‡ª {interaction.user.name} çš„è½‰ç§»")
        
        cursor.execute('''
            INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason)
            VALUES (?, ?, ?, ?)
        ''', (interaction.user.id, user.id, amount, reason or "ç„¡"))
        
        conn.commit()
        conn.close()
        
        new_sender_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ’¸ ç©åˆ†è½‰ç§»æˆåŠŸ",
            description=f"**è½‰å‡ºï¼š** {interaction.user.mention}\n"
                       f"**è½‰å…¥ï¼š** {user.mention}\n"
                       f"**é‡‘é¡ï¼š** {amount} åˆ†\n"
                       f"**åŸå› ï¼š** {reason or 'ç„¡'}\n"
                       f"**ä½ çš„å‰©é¤˜ç©åˆ†ï¼š** {new_sender_score} åˆ†",
            color=0x2ECC71
        )
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è½‰ç§»å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 7: prizelist
@bot.tree.command(name="prizelist", description="æŸ¥çœ‹å½©æ± åˆ—è¡¨")
async def prizelist_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹å½©æ± """
    await interaction.response.defer()
    
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT box_level, 
                   COUNT(*) as total_items,
                   SUM(remaining) as total_remaining
            FROM prize_pool 
            WHERE remaining > 0 
            GROUP BY box_level 
            ORDER BY 
                CASE box_level 
                    WHEN 'é‡‘ç®±' THEN 1 
                    WHEN 'ç´«ç®±' THEN 2 
                    WHEN 'è—ç®±' THEN 3 
                    WHEN 'ç¶ ç®±' THEN 4 
                    ELSE 5 
                END
        """)
        
        results = cursor.fetchall()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ å½©æ± åˆ—è¡¨",
                description="ç›®å‰å½©æ± æ˜¯ç©ºçš„",
                color=0xFFD700
            )
            await interaction.followup.send(embed=embed)
            conn.close()
            return
        
        embed = discord.Embed(
            title="ğŸ å½©æ± åˆ—è¡¨",
            description="å¯ç”¨çš„çå“ï¼ˆæŒ‰å¯¶ç®±ç­‰ç´šåˆ†é¡ï¼‰ï¼š",
            color=0xFFD700
        )
        
        for box_level, total_items, total_remaining in results:
            cursor.execute("""
                SELECT prize_name, remaining 
                FROM prize_pool 
                WHERE box_level = ? AND remaining > 0 
                ORDER BY prize_name
            """, (box_level,))
            
            items = cursor.fetchall()
            
            items_text = ""
            displayed_count = 0
            hidden_count = 0
            
            for prize_name, remaining in items:
                displayed_count += 1
                if displayed_count <= 8:
                    items_text += f"â€¢ {prize_name} (å‰©é¤˜: {remaining})\n"
                else:
                    hidden_count += 1
            
            if hidden_count > 0:
                items_text += f"... é‚„æœ‰ {hidden_count} å€‹çå“\n"
            
            actual_total = sum(item[1] for item in items)
            
            embed.add_field(
                name=f"{box_level} (ç¸½å‰©é¤˜: {actual_total} / çå“ç¨®é¡: {total_items})",
                value=items_text if items_text else "ç„¡çå“",
                inline=False
            )
        
        conn.close()
        
        embed.add_field(
            name="ğŸ“Š ç©åˆ†æŠ½çæ©Ÿç‡",
            value="**50ç©åˆ†ï¼š** ç¶ ç®±70% è—ç®±25% ç´«ç®±4.5% é‡‘ç®±0.5%\n"
                  "**100ç©åˆ†ï¼š** ç¶ ç®±50% è—ç®±40% ç´«ç®±9% é‡‘ç®±1%\n"
                  "**500ç©åˆ†ï¼š** ç¶ ç®±10% è—ç®±65% ç´«ç®±20% é‡‘ç®±5%",
            inline=False
        )
        
        embed.set_footer(text="ä½¿ç”¨ /add_prize æ·»åŠ çå“åˆ°å½©æ± ")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å½©æ± å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 8: random_team
@bot.tree.command(name="random_team", description="éš¨æ©Ÿåˆ†çµ„")
@app_commands.describe(
    team_size="æ¯çµ„äººæ•¸",
    team_count="çµ„æ•¸"
)
async def random_team_slash(
    interaction: discord.Interaction,
    team_size: Optional[int] = None,
    team_count: Optional[int] = None
):
    """éš¨æ©Ÿåˆ†çµ„"""
    await interaction.response.defer()
    
    try:
        if not interaction.guild:
            await interaction.followup.send("âŒ æ­¤æŒ‡ä»¤åªèƒ½åœ¨ä¼ºæœå™¨ä¸­ä½¿ç”¨")
            return
        
        embed = discord.Embed(
            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
            color=0x3498DB
        )
        
        if team_size:
            embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
        if team_count:
            embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
        
        embed.add_field(name="åƒåŠ äººæ•¸", value="0 äºº", inline=True)
        embed.set_footer(text="ç­‰å¾…åƒåŠ è€…...")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ®")
        await message.add_reaction("â–¶ï¸")
        
        participants = []
        
        def check(reaction, user):
            return (
                user != bot.user and
                str(reaction.emoji) in ["ğŸ®", "â–¶ï¸"] and
                reaction.message.id == message.id
            )
        
        try:
            while True:
                reaction, user = await bot.wait_for('reaction_add', timeout=300.0, check=check)
                
                if str(reaction.emoji) == "ğŸ®":
                    if user.id not in participants:
                        participants.append(user.id)
                        
                        new_embed = discord.Embed(
                            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
                            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
                            color=0x3498DB
                        )
                        
                        if team_size:
                            new_embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
                        if team_count:
                            new_embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
                        
                        new_embed.add_field(name="åƒåŠ äººæ•¸", value=f"{len(participants)} äºº", inline=True)
                        
                        if participants:
                            participants_text = ""
                            for i, pid in enumerate(participants[:10], 1):
                                participants_text += f"{i}. <@{pid}>\n"
                            if len(participants) > 10:
                                participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                            
                            new_embed.add_field(name="åƒåŠ è€…", value=participants_text, inline=False)
                        
                        new_embed.set_footer(text=f"ç­‰å¾…ä¸»æŒäººé–‹å§‹... ({len(participants)}äººåƒåŠ )")
                        
                        await message.edit(embed=new_embed)
                        
                elif str(reaction.emoji) == "â–¶ï¸" and user.id == interaction.user.id:
                    if len(participants) < 2:
                        await message.channel.send("âŒ è‡³å°‘éœ€è¦2äººæ‰èƒ½é–‹å§‹åˆ†çµ„", delete_after=5)
                        continue
                    
                    random.shuffle(participants)
                    
                    if team_size:
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    elif team_count:
                        team_size = len(participants) // team_count
                        if len(participants) % team_count != 0:
                            team_size += 1
                    else:
                        if len(participants) <= 4:
                            team_size = 2
                        elif len(participants) <= 8:
                            team_size = 4
                        else:
                            team_size = 5
                        
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    
                    teams = []
                    for i in range(team_count):
                        start_idx = i * team_size
                        end_idx = min((i + 1) * team_size, len(participants))
                        if start_idx < len(participants):
                            teams.append(participants[start_idx:end_idx])
                    
                    result_embed = discord.Embed(
                        title="ğŸ‘¥ åˆ†çµ„çµæœ",
                        description=f"ç¸½äººæ•¸ï¼š{len(participants)} äºº\n"
                                   f"åˆ†çµ„æ–¹å¼ï¼š{team_count} çµ„ï¼Œæ¯çµ„ç´„ {team_size} äºº",
                        color=0x00FF00
                    )
                    
                    for i, team in enumerate(teams, 1):
                        members_list = "\n".join([f"{j+1}. <@{member_id}>" for j, member_id in enumerate(team)])
                        result_embed.add_field(
                            name=f"ç¬¬ {i} çµ„ ({len(team)}äºº)",
                            value=members_list,
                            inline=False
                        )
                    
                    await message.channel.send(embed=result_embed)
                    await message.clear_reactions()
                    break
        
        except asyncio.TimeoutError:
            timeout_embed = discord.Embed(
                title="ğŸ‘¥ åˆ†çµ„è¶…æ™‚",
                description="åˆ†çµ„æ™‚é–“å·²é",
                color=0xFF0000
            )
            await message.edit(embed=timeout_embed)
            await message.clear_reactions()
            
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åˆ†çµ„å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 9: add_prize (ç®¡ç†å“¡)
@bot.tree.command(name="add_prize", description="æ·»åŠ çå“åˆ°å½©æ± ")
@app_commands.describe(
    name="çå“åç¨±",
    box_level="å¯¶ç®±ç­‰ç´š (ç¶ ç®±/è—ç®±/ç´«ç®±/é‡‘ç®±)",
    quantity="æ•¸é‡ (æ­£æ•¸æ·»åŠ , è² æ•¸æ¸›å°‘)"
)
async def add_prize_slash(
    interaction: discord.Interaction,
    name: str,
    box_level: str,
    quantity: int
):
    """æ·»åŠ /æ¸›å°‘çå“"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        valid_levels = ["ç¶ ç®±", "è—ç®±", "ç´«ç®±", "é‡‘ç®±"]
        if box_level not in valid_levels:
            await interaction.followup.send(f"âŒ ç„¡æ•ˆçš„å¯¶ç®±ç­‰ç´šï¼è«‹é¸æ“‡ï¼š{', '.join(valid_levels)}")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        if quantity > 0:
            cursor.execute('''
                INSERT INTO prize_pool (prize_name, box_level, quantity, remaining, added_by)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(prize_name, box_level) 
                DO UPDATE SET 
                    quantity = quantity + excluded.quantity,
                    remaining = remaining + excluded.quantity
            ''', (name, box_level, quantity, quantity, interaction.user.id))
            
            action = "æ·»åŠ "
        elif quantity < 0:
            cursor.execute('''
                UPDATE prize_pool 
                SET quantity = quantity + ?,
                    remaining = CASE 
                                    WHEN remaining + ? > 0 THEN remaining + ?
                                    ELSE 0
                                END
                WHERE prize_name = ? AND box_level = ?
            ''', (quantity, quantity, quantity, name, box_level))
            
            if cursor.rowcount == 0:
                await interaction.followup.send(f"âŒ æ‰¾ä¸åˆ°çå“ '{name}' åœ¨ {box_level} ä¸­")
                conn.close()
                return
            
            action = "æ¸›å°‘"
        else:
            await interaction.followup.send("âŒ æ•¸é‡ä¸èƒ½ç‚º 0")
            conn.close()
            return
        
        cursor.execute("SELECT quantity, remaining FROM prize_pool WHERE prize_name = ? AND box_level = ?", 
                      (name, box_level))
        result = cursor.fetchone()
        
        if result:
            total_qty, remaining_qty = result
            
            embed = discord.Embed(
                title=f"âœ… çå“{action}æˆåŠŸ",
                color=0x2ECC71 if quantity > 0 else 0xE74C3C
            )
            
            embed.add_field(name="çå“åç¨±", value=name, inline=True)
            embed.add_field(name="å¯¶ç®±ç­‰ç´š", value=box_level, inline=True)
            embed.add_field(name=f"{action}æ•¸é‡", value=f"{abs(quantity)} å€‹", inline=True)
            embed.add_field(name="ç¸½æ•¸é‡", value=f"{total_qty} å€‹", inline=True)
            embed.add_field(name="å‰©é¤˜æ•¸é‡", value=f"{remaining_qty} å€‹", inline=True)
            embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
            
            await interaction.followup.send(embed=embed)
        else:
            await interaction.followup.send(f"âŒ æ“ä½œå¤±æ•—")
        
        conn.commit()
        conn.close()
        
    except sqlite3.OperationalError as e:
        if "no such column" in str(e) or "no such table" in str(e):
            error_embed = discord.Embed(
                title="âŒ è³‡æ–™åº«çµæ§‹éŒ¯èª¤",
                description="è«‹åˆªé™¤ bot_data.db æª”æ¡ˆå¾Œé‡æ–°å•Ÿå‹•æ©Ÿå™¨äºº",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
        else:
            error_embed = discord.Embed(
                title="âŒ æ“ä½œå¤±æ•—",
                description=f"è³‡æ–™åº«éŒ¯èª¤ï¼š{str(e)}",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æ“ä½œå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 10: add_score (ç®¡ç†å“¡)
@bot.tree.command(name="add_score", description="èª¿æ•´ç”¨æˆ¶ç©åˆ†")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="ç©åˆ†è®ŠåŒ–ï¼ˆæ­£æ•¸ç‚ºå¢åŠ ï¼Œè² æ•¸ç‚ºæ¸›å°‘ï¼‰",
    reason="åŸå› "
)
async def add_score_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: str
):
    """èª¿æ•´ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        if amount == 0:
            await interaction.followup.send("âŒ ç©åˆ†è®ŠåŒ–ä¸èƒ½ç‚º 0")
            return
        
        old_score, old_total = get_user_score(user.id)
        update_user_score(user.id, user.name, amount, f"ç®¡ç†å“¡èª¿æ•´: {reason}")
        new_score, new_total = get_user_score(user.id)
        
        action = "å¢åŠ " if amount > 0 else "æ¸›å°‘"
        embed = discord.Embed(
            title=f"âœ… ç©åˆ†{action}æˆåŠŸ",
            color=0x2ECC71 if amount > 0 else 0xE74C3C
        )
        
        embed.add_field(name="ç”¨æˆ¶", value=user.mention, inline=True)
        embed.add_field(name=f"{action}ç©åˆ†", value=f"{abs(amount)} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå‰ç©åˆ†", value=f"{old_score} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå¾Œç©åˆ†", value=f"{new_score} åˆ†", inline=True)
        embed.add_field(name="ç¸½ç²å¾—ç©åˆ†", value=f"{new_total} åˆ†", inline=True)
        embed.add_field(name="åŸå› ", value=reason, inline=True)
        embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ èª¿æ•´å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 11: create_event (ç®¡ç†å“¡)
@bot.tree.command(name="create_event", description="å‰µå»ºè©•æ ¸æ´»å‹•")
@app_commands.describe(
    event_name="æ´»å‹•åç¨±",
    signup_time="ç°½åˆ°æ™‚é–“ï¼ˆåˆ†é˜ï¼‰",
    prize="æ´»å‹•çå“"
)
async def create_event_slash(
    interaction: discord.Interaction,
    event_name: str,
    signup_time: int = 5,
    prize: Optional[str] = None
):
    """å‰µå»ºè©•æ ¸æ´»å‹•"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        signup_embed = discord.Embed(
            title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
            color=discord.Color.blue()
        )
        
        if prize:
            signup_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
        
        signup_embed.add_field(
            name="ğŸ“ ç°½åˆ°éšæ®µ",
            value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°",
            inline=False
        )
        
        signup_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value="0 äºº", inline=True)
        signup_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
        
        signup_message = await interaction.followup.send(embed=signup_embed, wait=True)
        await signup_message.add_reaction("âœ…")
        
        class_embed = discord.Embed(
            title=f"ğŸ® è·æ¥­é¸æ“‡ï¼š{event_name}",
            description="è«‹é¸æ“‡ä½ çš„è·æ¥­ï¼š\n\nğŸ›¡ï¸ å¦å…‹\nâš”ï¸ è¾“å‡º\nğŸ’š æ²»ç–—\nğŸ’› è¾…åŠ©\n\n**æ³¨æ„ï¼šè«‹å…ˆå®Œæˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼**",
            color=discord.Color.green()
        )
        class_embed.set_footer(text="ç°½åˆ°æˆåŠŸå¾Œè«‹é¸æ“‡è·æ¥­")
        
        class_msg = await interaction.channel.send(embed=class_embed)
        for emoji in ["ğŸ›¡ï¸", "âš”ï¸", "ğŸ’š", "ğŸ’›"]:
            await class_msg.add_reaction(emoji)
        
        signup_end_time = datetime.now() + timedelta(minutes=signup_time)
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO evaluation_events (event_name, creator_id, signup_message_id, profession_message_id, channel_id, signup_end_time)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (event_name, interaction.user.id, signup_message.id, class_msg.id, interaction.channel.id, signup_end_time))
        conn.commit()
        conn.close()
        
        print(f"âœ… æ´»å‹•å‰µå»ºæˆåŠŸ: {event_name}")
        
        async def signup_countdown():
            remaining_minutes = signup_time
            
            while remaining_minutes > 0:
                await asyncio.sleep(60)
                remaining_minutes -= 1
                
                try:
                    conn = sqlite3.connect(DB_NAME)
                    cursor = conn.cursor()
                    cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                    result = cursor.fetchone()
                    
                    participants_count = 0
                    if result and result[0]:
                        participants = json.loads(result[0])
                        participants_count = len(participants)
                    conn.close()
                    
                    updated_embed = discord.Embed(
                        title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                        color=discord.Color.blue()
                    )
                    
                    if prize:
                        updated_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                    
                    updated_embed.add_field(
                        name="ğŸ“ ç°½åˆ°éšæ®µ",
                        value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°",
                        inline=False
                    )
                    
                    updated_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
                    updated_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{participants_count} äºº", inline=True)
                    updated_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{remaining_minutes} åˆ†é˜", inline=True)
                    updated_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
                    
                    await signup_message.edit(embed=updated_embed)
                    
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
            
            try:
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                result = cursor.fetchone()
                
                participants = []
                if result and result[0]:
                    participants = json.loads(result[0])
                
                for user_id in participants:
                    update_user_score(user_id, f"ç”¨æˆ¶{user_id}", SIGNUP_SCORE, f"æ´»å‹•ç°½åˆ°: {event_name}")
                    update_user_activity(user_id, event_name, attended=True)
                    update_user_rating(user_id, "æ™®é€š")
                
                cursor.execute("UPDATE evaluation_events SET default_rated = ?, is_active = 1 WHERE signup_message_id = ?", 
                             (json.dumps(participants), signup_message.id))
                conn.commit()
                conn.close()
                
                end_embed = discord.Embed(
                    title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                    description="**ç°½åˆ°å·²çµæŸï¼æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ0ç©åˆ†ï¼‰**",
                    color=discord.Color.red()
                )
                
                if prize:
                    end_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                
                end_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value="å·²çµæŸ", inline=True)
                end_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{len(participants)} äºº", inline=True)
                
                if participants:
                    participants_text = "\n".join([f"<@{user_id}>" for user_id in participants[:10]])
                    if len(participants) > 10:
                        participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                    
                    end_embed.add_field(name="ğŸ“‹ åƒèˆ‡è€…åˆ—è¡¨", value=participants_text, inline=False)
                
                end_embed.add_field(name="ğŸ“ è©•æ ¸èªªæ˜", value="ä¸»æŒäººç¾åœ¨å¯ä»¥æŒ‰EMOJIèª¿æ•´è©•ç´šï¼š\nâ­ å„ªç§€ (+40åˆ†)\nğŸ‘ è‰¯å¥½ (+10åˆ†)\nğŸ‘Œ æ™®é€š (0åˆ†ï¼Œé è¨­)\nâŒ ä¸åˆæ ¼ (-5åˆ†)", inline=False)
                end_embed.set_footer(text="åŠæœˆæœŸæ´»å‹•çµ±è¨ˆå·²æ›´æ–° | ç°½åˆ°ç©åˆ†å·²ç™¼æ”¾ | é è¨­è©•ç´šï¼šæ™®é€š")
                
                await signup_message.edit(embed=end_embed)
                await signup_message.clear_reactions()
                
                rating_embed = discord.Embed(
                    title=f"â­ è©•æ ¸éšæ®µï¼š{event_name}",
                    description="**ä¸»æŒäººå¯ä»¥æŒ‰ä¸‹æ–¹EMOJIèª¿æ•´è©•ç´š**\n\n"
                              f"æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ{RATING_SCORES['æ™®é€š']}ç©åˆ†ï¼‰\n",
                    color=discord.Color.gold()
                )
                
                if participants:
                    rating_embed.add_field(
                        name="ğŸ‘¥ åƒèˆ‡è€…åˆ—è¡¨",
                        value="\n".join([f"<@{user_id}>" for user_id in participants[:15]]) + 
                             (f"\n... é‚„æœ‰ {len(participants)-15} äºº" if len(participants) > 15 else ""),
                        inline=False
                    )
                
                rating_msg = await interaction.channel.send(embed=rating_embed)
                
                for emoji in ["â­", "ğŸ‘", "ğŸ‘Œ", "âŒ", RATING_END_EMOJI]:
                    await rating_msg.add_reaction(emoji)
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("UPDATE evaluation_events SET rating_message_id = ? WHERE signup_message_id = ?", 
                             (rating_msg.id, signup_message.id))
                conn.commit()
                conn.close()
                
                print(f"âœ… è©•æ ¸éšæ®µå·²å‰µå»º: {event_name}, è©•æ ¸è¨Šæ¯ID: {rating_msg.id}")
                
            except Exception as e:
                print(f"ç°½åˆ°çµæŸè™•ç†éŒ¯èª¤: {e}")
        
        asyncio.create_task(signup_countdown())
        
        success_embed = discord.Embed(
            title="âœ… æ´»å‹•å‰µå»ºæˆåŠŸ",
            description=f"**æ´»å‹•åç¨±ï¼š** {event_name}\n**ç°½åˆ°æ™‚é–“ï¼š** {signup_time} åˆ†é˜\n**åƒèˆ‡æ–¹å¼ï¼š** æŒ‰ âœ… åæ‡‰ç°½åˆ°",
            color=discord.Color.green()
        )
        
        await interaction.followup.send(embed=success_embed, ephemeral=True)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæ´»å‹•å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 12: all_profiles (ç®¡ç†å“¡)
@bot.tree.command(name="all_profiles", description="æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™")
@app_commands.describe(
    sort_by="æ’åºæ–¹å¼",
    limit="é¡¯ç¤ºæ•¸é‡"
)
@app_commands.choices(sort_by=[
    app_commands.Choice(name="ç¾æœ‰ç©åˆ†(é«˜åˆ°ä½)", value="current_score"),
    app_commands.Choice(name="ç¸½ç²å¾—ç©åˆ†(é«˜åˆ°ä½)", value="total_score"),
    app_commands.Choice(name="åŠ å…¥æ—¥æœŸ(æ—©åˆ°æ™š)", value="join_date"),
    app_commands.Choice(name="æœ€å¾Œæ´»èº(è¿‘åˆ°é )", value="last_active"),
])
async def all_profiles_slash(
    interaction: discord.Interaction,
    sort_by: Optional[str] = "current_score",
    limit: Optional[int] = 20
):
    """æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        if limit > 50:
            limit = 50
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT user_id, username, current_score, total_score, join_date, 
                   last_active, activity_stats
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        processed_users = []
        current_period = get_current_half_month()
        
        for row in results:
            user_id, username, current_score, total_score, join_date, last_active, activity_str = row
            
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            current_period_data = activity_stats.get(current_period, {})
            total_events = current_period_data.get("total", 0)
            attended_events = current_period_data.get("attended", 0)
            current_attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
            
            processed_users.append({
                "user_id": user_id,
                "username": username,
                "current_score": current_score,
                "total_score": total_score,
                "join_date": join_date,
                "last_active": last_active,
                "current_attendance_rate": current_attendance_rate,
                "total_events": total_events,
                "attended_events": attended_events,
            })
        
        sort_functions = {
            "current_score": lambda x: x["current_score"],
            "total_score": lambda x: x["total_score"],
            "join_date": lambda x: x["join_date"],
            "last_active": lambda x: x["last_active"],
        }
        
        reverse_order = {
            "current_score": True,
            "total_score": True,
            "join_date": False,
            "last_active": True,
        }
        
        sort_func = sort_functions.get(sort_by, lambda x: x["current_score"])
        reverse = reverse_order.get(sort_by, True)
        
        sorted_users = sorted(processed_users, key=sort_func, reverse=reverse)
        display_users = sorted_users[:limit]
        
        total_users = len(display_users)
        total_current_score = sum(u["current_score"] for u in display_users)
        total_total_score = sum(u["total_score"] for u in display_users)
        avg_current_score = total_current_score / total_users if total_users > 0 else 0
        
        profiles_per_page = 10
        pages = []
        
        for i in range(0, len(display_users), profiles_per_page):
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™ç¸½è¦½",
                description=f"é¡¯ç¤º {min(i + profiles_per_page, len(display_users))}/{len(display_users)} ä½ç”¨æˆ¶",
                color=0x43B581
            )
            
            embed.add_field(
                name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                      f"**ç¸½ç¾æœ‰ç©åˆ†ï¼š** {total_current_score} åˆ†\n"
                      f"**ç¸½æ­·å²ç©åˆ†ï¼š** {total_total_score} åˆ†\n"
                      f"**å¹³å‡ç¾æœ‰ç©åˆ†ï¼š** {avg_current_score:.1f} åˆ†",
                inline=False
            )
            
            user_list = ""
            for user in display_users[i:i + profiles_per_page]:
                user_id = user["user_id"]
                username = user["username"]
                
                discord_user = interaction.guild.get_member(user_id)
                display_name = discord_user.display_name if discord_user else username
                
                user_list += f"**{display_name}**\n"
                user_list += f"  ğŸ”¹ ç¾æœ‰ç©åˆ†ï¼š{user['current_score']}åˆ†\n"
                user_list += f"  ğŸ“Š ç¸½ç©åˆ†ï¼š{user['total_score']}åˆ†\n"
                user_list += f"  ğŸ“Š å‡ºå¸­ç‡ï¼š{user['current_attendance_rate']:.1f}%\n"
                user_list += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ‘¥ ç”¨æˆ¶åˆ—è¡¨",
                value=user_list if user_list else "ç„¡ç”¨æˆ¶è³‡æ–™",
                inline=False
            )
            
            embed.set_footer(text=f"é é¢ {i//profiles_per_page + 1}/{(len(display_users)-1)//profiles_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            current_page = 0
            
            class ProfilesPaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = ProfilesPaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–ç”¨æˆ¶è³‡æ–™å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 13: attendance_stats (ç®¡ç†å“¡)
@bot.tree.command(name="attendance_stats", description="æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ")
@app_commands.describe(
    period="çµ±è¨ˆæœŸé–“",
    min_events="æœ€ä½æ´»å‹•æ¬¡æ•¸"
)
@app_commands.choices(period=[
    app_commands.Choice(name="ç•¶å‰åŠæœˆæœŸ", value="current"),
    app_commands.Choice(name="æ‰€æœ‰æœŸé–“", value="all"),
])
async def attendance_stats_slash(
    interaction: discord.Interaction,
    period: Optional[str] = "current",
    min_events: Optional[int] = 3
):
    """æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT user_id, username, activity_stats
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        current_period = get_current_half_month()
        attendance_data = []
        
        for user_id, username, activity_str in results:
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            if period == "current":
                period_data = activity_stats.get(current_period, {})
                total_events = period_data.get("total", 0)
                attended_events = period_data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": current_period
                    })
            
            else:  # "all"
                total_events = 0
                attended_events = 0
                
                for data in activity_stats.values():
                    total_events += data.get("total", 0)
                    attended_events += data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": "æ‰€æœ‰æœŸé–“"
                    })
        
        attendance_data.sort(key=lambda x: x["attendance_rate"], reverse=True)
        
        total_users = len(attendance_data)
        if total_users == 0:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description=f"æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ç”¨æˆ¶ï¼ˆæœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ï¼‰",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        avg_attendance_rate = sum(d["attendance_rate"] for d in attendance_data) / total_users
        perfect_attendance = sum(1 for d in attendance_data if d["attendance_rate"] == 100)
        
        users_per_page = 15
        pages = []
        
        for i in range(0, len(attendance_data), users_per_page):
            embed = discord.Embed(
                title=f"ğŸ“Š å‡ºå¸­ç‡æ’è¡Œæ¦œ - {attendance_data[0]['period']}",
                description=f"é¡¯ç¤º {min(i + users_per_page, len(attendance_data))}/{len(attendance_data)} ä½ç”¨æˆ¶",
                color=0x3498DB
            )
            
            embed.add_field(
                name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                      f"**å¹³å‡å‡ºå¸­ç‡ï¼š** {avg_attendance_rate:.1f}%\n"
                      f"**å…¨å‹¤ç”¨æˆ¶ï¼š** {perfect_attendance} äºº (100%)",
                inline=False
            )
            
            leaderboard = ""
            for j, data in enumerate(attendance_data[i:i + users_per_page], i + 1):
                medal = "ğŸ¥‡ " if j == 1 else "ğŸ¥ˆ " if j == 2 else "ğŸ¥‰ " if j == 3 else f"{j}. "
                
                discord_user = interaction.guild.get_member(data["user_id"])
                display_name = discord_user.display_name if discord_user else data["username"]
                
                leaderboard += f"{medal}**{display_name}**\n"
                leaderboard += f"   å‡ºå¸­ç‡ï¼š{data['attendance_rate']:.1f}% "
                leaderboard += f"({data['attended_events']}/{data['total_events']}æ¬¡)\n"
                
                if j % 5 == 0:
                    leaderboard += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ† å‡ºå¸­ç‡æ’è¡Œæ¦œ",
                value=leaderboard,
                inline=False
            )
            
            embed.set_footer(text=f"æœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ | é é¢ {i//users_per_page + 1}/{(len(attendance_data)-1)//users_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            class AttendancePaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = AttendancePaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å‡ºå¸­ç‡å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# é¡å¤–æŒ‡ä»¤: ping
@bot.tree.command(name="ping", description="æ¸¬è©¦æ©Ÿå™¨äººå»¶é²")
async def ping_slash(interaction: discord.Interaction):
    """æ¸¬è©¦å»¶é²"""
    latency = round(bot.latency * 1000)
    
    embed = discord.Embed(
        title="ğŸ“ Pong!",
        description=f"æ©Ÿå™¨äººå»¶é²: **{latency}ms**",
        color=discord.Color.green() if latency < 100 else discord.Color.orange() if latency < 300 else discord.Color.red()
    )
    
    await interaction.response.send_message(embed=embed)

# ========== ä¸»ç¨‹å¼ ==========

def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    print(f"{'='*50}")
    print(f"ğŸš€ å•Ÿå‹• {BOT_NAME} - å®Œæ•´åŠŸèƒ½ç‰ˆæœ¬")
    print(f"ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´")
    print(f"ğŸ”§ æ“æœ‰è€…ID: {OWNER_IDS}")
    print(f"ğŸ“ è³‡æ–™åº«ä½ç½®: {DB_NAME}")
    print(f"ğŸ“‹ ç¸½æŒ‡ä»¤æ•¸: 13å€‹")
    print(f"{'='*50}")
    
    # å¾ç’°å¢ƒè®Šæ•¸è®€å– Token
    token = os.getenv("DISCORD_TOKEN")
    
    if not token or token == "ä½ çš„_bot_token_åœ¨é€™è£¡":
        print("âŒ æ‰¾ä¸åˆ°æœ‰æ•ˆçš„ Tokenï¼")
        print("ğŸ’¡ è«‹åœ¨ Railway è¨­å®šç’°å¢ƒè®Šæ•¸ï¼š")
        print("   1. é€²å…¥ Railway å°ˆæ¡ˆ")
        print("   2. é»æ“Š Settings")
        print("   3. é»æ“Š Variables")
        print("   4. æ–°å¢ DISCORD_TOKEN = ä½ çš„_bot_token")
        sys.exit(1)
    
    print("âœ… Token è®€å–æˆåŠŸ")
    print("ğŸ”„ æ­£åœ¨é€£æ¥ Discord...")
    
    try:
        bot.run(token)
    except discord.LoginFailure:
        print("âŒ ç™»å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º")
        print("ğŸ’¡ è«‹åˆ° Discord Developer Portal é‡ç½® Token")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")

if __name__ == "__main__":
    main()
æˆ‘æ‰¾åˆ°äº†å•é¡Œï¼ä¸»è¦çš„å·®ç•°åœ¨æ–¼æŒ‡ä»¤æ¨¹çš„å¼•ç”¨æ–¹å¼ã€‚

å•é¡Œåˆ†æï¼š
æˆåŠŸç‰ˆæœ¬ï¼ˆ11å€‹æŒ‡ä»¤ï¼‰ï¼š
python
tree = bot.tree  # é‡è¦ï¼é€™è£¡å®šç¾©äº† tree è®Šæ•¸

@tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯")
async def help_slash(interaction: discord.Interaction):
    ...
å¤±æ•—ç‰ˆæœ¬ï¼ˆ13å€‹æŒ‡ä»¤ï¼‰ï¼š
python
# ç¼ºå°‘é€™ä¸€è¡Œï¼
# tree = bot.tree

@bot.tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯")
async def help_slash(interaction: discord.Interaction):
    ...
è§£æ±ºæ–¹æ¡ˆï¼š
å°‡å¤±æ•—ç‰ˆæœ¬æ”¹ç‚ºèˆ‡æˆåŠŸç‰ˆæœ¬ç›¸åŒçš„çµæ§‹ã€‚ä»¥ä¸‹æ˜¯ä¿®æ­£å¾Œçš„å®Œæ•´ç¨‹å¼ç¢¼ï¼Œä¿è­‰13å€‹æŒ‡ä»¤éƒ½èƒ½æ­£å¸¸åŒæ­¥ï¼š

python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å°é›²ALBIONæ©Ÿæ¢°äºº - å®Œæ•´åŠŸèƒ½ç‰ˆæœ¬ (ä¿®æ­£ç‰ˆ)
13å€‹æŒ‡ä»¤å…¨éƒ¨å¯ç”¨
"""

import os
import discord
from discord.ext import commands
from discord import app_commands
import sys
import asyncio
import json
import random
from datetime import datetime, timedelta
from typing import Optional, List
import sqlite3
import time

# ========== è¨­å®š ==========
BOT_NAME = "å°é›²æ©Ÿæ¢°äºº"
OWNER_IDS = [337237662157242368]  # ä½ çš„ Discord ID

# è·æ¥­å°æ‡‰çš„EMOJI
PROFESSION_EMOJIS = {
    "ğŸ›¡ï¸": "å¦å…‹",
    "âš”ï¸": "è¾“å‡º", 
    "ğŸ’š": "æ²»ç–—",
    "ğŸ’›": "è¾…åŠ©"
}

# è©•æ ¸è©•åˆ†é¸é …
RATING_EMOJIS = {
    "â­": "å„ªç§€",
    "ğŸ‘": "è‰¯å¥½", 
    "ğŸ‘Œ": "æ™®é€š",  # é è¨­è©•ç´š
    "âŒ": "ä¸åˆæ ¼"
}

# è©•æ ¸çµæŸEMOJI
RATING_END_EMOJI = "ğŸ"

# ========== ç©åˆ†è¨­å®š ==========
SIGNUP_SCORE = 40  # ç°½åˆ°ç©åˆ†
PROFESSION_BONUS = {
    "å¦å…‹": 0,
    "è¾“å‡º": 0,
    "æ²»ç–—": 20,  # è£œå¸«+20ç©åˆ†
    "è¾…åŠ©": 0
}
RATING_SCORES = {
    "å„ªç§€": 40,    # å„ªç§€+40ç©åˆ†
    "è‰¯å¥½": 10,    # è‰¯å¥½+10ç©åˆ†
    "æ™®é€š": 0,     # æ™®é€š+0ç©åˆ†
    "ä¸åˆæ ¼": -5   # ä¸åˆæ ¼-5ç©åˆ†
}

# Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True
intents.presences = True

bot = commands.Bot(
    command_prefix='!',
    intents=intents,
    help_command=None,
    case_insensitive=True
)

# ========== é—œéµä¿®å¾© ==========
# å®šç¾©æŒ‡ä»¤æ¨¹è®Šæ•¸ï¼Œèˆ‡æˆåŠŸç‰ˆæœ¬ä¿æŒä¸€è‡´
tree = bot.tree

# ========== è³‡æ–™åº«è¨­å®š ==========
DB_NAME = "bot_data.db"

def init_db():
    """åˆå§‹åŒ–è³‡æ–™åº«"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # ç”¨æˆ¶è³‡æ–™è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        total_score INTEGER DEFAULT 0,
        current_score INTEGER DEFAULT 0,
        join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        profession_counts TEXT DEFAULT '{}',
        activity_stats TEXT DEFAULT '{}',
        rating_stats TEXT DEFAULT '{}'
    )
    ''')
    
    # å½©æ± è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS prize_pool (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        prize_name TEXT NOT NULL,
        box_level TEXT NOT NULL,
        quantity INTEGER DEFAULT 1,
        remaining INTEGER DEFAULT 1,
        added_by INTEGER,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(prize_name, box_level)
    )
    ''')
    
    # æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS giveaways (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        prize TEXT,
        winner_count INTEGER DEFAULT 1,
        participants TEXT DEFAULT '[]',
        winners TEXT DEFAULT '[]',
        end_time TIMESTAMP,
        message_id INTEGER,
        channel_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†æŠ½çè¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_draws (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        creator_id INTEGER,
        score_cost INTEGER,
        box_level TEXT,
        participants TEXT DEFAULT '[]',
        winner_prize TEXT,
        winner_id INTEGER,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # ç©åˆ†è½‰ç§»ç´€éŒ„
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS score_transfers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_user_id INTEGER,
        to_user_id INTEGER,
        amount INTEGER,
        reason TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # è©•æ ¸æ´»å‹•
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS evaluation_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        event_name TEXT,
        creator_id INTEGER,
        signup_message_id INTEGER,
        profession_message_id INTEGER,
        rating_message_id INTEGER,
        channel_id INTEGER,
        participants TEXT DEFAULT '[]',
        default_rated TEXT DEFAULT '[]',
        professions TEXT DEFAULT '{}',
        ratings TEXT DEFAULT '{}',
        is_active BOOLEAN DEFAULT 1,
        start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        signup_end_time TIMESTAMP
    )
    ''')
    
    # æ·»åŠ ç¤ºä¾‹çå“
    sample_prizes = [
        ("æ™®é€šæ­¦å™¨", "ç¶ ç®±", 20),
        ("æ™®é€šè£å‚™", "ç¶ ç®±", 15),
        ("åˆç´šè—¥æ°´", "ç¶ ç®±", 30),
        ("ä¸­ç´šæ­¦å™¨", "è—ç®±", 10),
        ("ä¸­ç´šè£å‚™", "è—ç®±", 8),
        ("ä¸­ç´šè—¥æ°´", "è—ç®±", 15),
        ("é«˜ç´šæ­¦å™¨", "ç´«ç®±", 5),
        ("é«˜ç´šè£å‚™", "ç´«ç®±", 4),
        ("é«˜ç´šè—¥æ°´", "ç´«ç®±", 6),
        ("å‚³å¥‡æ­¦å™¨", "é‡‘ç®±", 2),
        ("å‚³å¥‡è£å‚™", "é‡‘ç®±", 1),
        ("å‚³èªªè—¥æ°´", "é‡‘ç®±", 3),
    ]
    
    for prize_name, box_level, quantity in sample_prizes:
        cursor.execute('''
            INSERT OR IGNORE INTO prize_pool (prize_name, box_level, quantity, remaining)
            VALUES (?, ?, ?, ?)
        ''', (prize_name, box_level, quantity, quantity))
    
    conn.commit()
    conn.close()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")

# ========== é€šç”¨å‡½æ•¸ ==========

def get_user_score(user_id):
    """å–å¾—ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        return result[0], result[1]
    return 0, 0

def update_user_score(user_id, username, amount, reason=""):
    """æ›´æ–°ç”¨æˆ¶ç©åˆ†"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if not cursor.fetchone():
        cursor.execute(
            "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
            (user_id, username, max(amount, 0), max(amount, 0))
        )
    else:
        cursor.execute("UPDATE users SET current_score = current_score + ? WHERE user_id = ?", (amount, user_id))
        if amount > 0:
            cursor.execute("UPDATE users SET total_score = total_score + ? WHERE user_id = ?", (amount, user_id))
        cursor.execute("UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE user_id = ?", (user_id,))
    
    if amount < 0 or reason:
        cursor.execute(
            "INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason) VALUES (?, ?, ?, ?)",
            (user_id if amount < 0 else None, 
             user_id if amount > 0 else None, 
             abs(amount), 
             reason if reason else ("ç³»çµ±æ‰£é™¤" if amount < 0 else "ç³»çµ±å¢åŠ "))
        )
    
    conn.commit()
    conn.close()

def get_user_profile(user_id):
    """ç²å–ç”¨æˆ¶å®Œæ•´è³‡æ–™"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT current_score, total_score, join_date, profession_counts, activity_stats, rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    conn.close()
    
    if result:
        current_score, total_score, join_date, profession_str, activity_str, rating_str = result
        
        try:
            join_date_str = datetime.strptime(join_date.split('.')[0], '%Y-%m-%d %H:%M:%S').strftime('%Y-%m-%d')
        except:
            join_date_str = join_date
        
        profession_counts = json.loads(profession_str) if profession_str else {}
        activity_stats = json.loads(activity_str) if activity_str else {}
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        return {
            'user_id': user_id,
            'current_score': current_score,
            'total_score': total_score,
            'join_date': join_date_str,
            'profession_counts': profession_counts,
            'activity_stats': activity_stats,
            'rating_stats': rating_stats
        }
    
    return None

def update_user_profession(user_id, profession):
    """æ›´æ–°ç”¨æˆ¶è·æ¥­çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT profession_counts FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        profession_str = result[0]
        profession_counts = json.loads(profession_str) if profession_str else {}
        
        if profession in profession_counts:
            profession_counts[profession] += 1
        else:
            profession_counts[profession] = 1
        
        bonus_score = PROFESSION_BONUS.get(profession, 0)
        if bonus_score > 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("UPDATE users SET current_score = current_score + ?, total_score = total_score + ? WHERE user_id = ?", 
                         (bonus_score, bonus_score, user_id))
        
        cursor.execute("UPDATE users SET profession_counts = ? WHERE user_id = ?", 
                      (json.dumps(profession_counts), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_activity(user_id, event_name, attended=True):
    """æ›´æ–°ç”¨æˆ¶æ´»å‹•çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT activity_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        activity_str = result[0]
        activity_stats = json.loads(activity_str) if activity_str else {}
        
        # ç²å–ç•¶å‰åŠæœˆæœŸ
        now = datetime.now()
        year_month = now.strftime("%Y-%m")
        day = now.day
        current_period = f"{year_month}-ä¸ŠåŠ" if day <= 15 else f"{year_month}-ä¸‹åŠ"
        
        if current_period not in activity_stats:
            activity_stats[current_period] = {"total": 0, "attended": 0}
        
        activity_stats[current_period]["total"] += 1
        if attended:
            activity_stats[current_period]["attended"] += 1
        
        cursor.execute("UPDATE users SET activity_stats = ? WHERE user_id = ?", 
                      (json.dumps(activity_stats), user_id))
        
        conn.commit()
    
    conn.close()

def update_user_rating(user_id, rating_type):
    """æ›´æ–°ç”¨æˆ¶è©•æ ¸çµ±è¨ˆ"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute("SELECT rating_stats FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if result:
        rating_str = result[0]
        rating_stats = json.loads(rating_str) if rating_str else {}
        
        if rating_type in rating_stats:
            rating_stats[rating_type] += 1
        else:
            rating_stats[rating_type] = 1
        
        score = RATING_SCORES.get(rating_type, 0)
        
        if score != 0:
            cursor.execute("SELECT username FROM users WHERE user_id = ?", (user_id,))
            user_result = cursor.fetchone()
            username = user_result[0] if user_result else "æœªçŸ¥ç”¨æˆ¶"
            
            cursor.execute("""
                UPDATE users 
                SET current_score = current_score + ?, 
                    total_score = CASE 
                                    WHEN total_score + ? > 0 THEN total_score + ?
                                    ELSE 0
                                  END
                WHERE user_id = ?
            """, (score, score, score, user_id))
        
        cursor.execute("UPDATE users SET rating_stats = ? WHERE user_id = ?", 
                      (json.dumps(rating_stats), user_id))
        
        conn.commit()
    
    conn.close()

def get_current_half_month():
    """ç²å–ç•¶å‰åŠæœˆæœŸ"""
    now = datetime.now()
    year_month = now.strftime("%Y-%m")
    day = now.day
    
    if day <= 15:
        return f"{year_month}-ä¸ŠåŠ"
    else:
        return f"{year_month}-ä¸‹åŠ"

async def end_giveaway(message_id: int, manual: bool = False):
    """çµæŸæŠ½ç"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, creator_id, prize, winner_count, participants, winners, channel_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (message_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        giveaway_id, creator_id, prize, winner_count, participants_json, winners_json, channel_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        channel = bot.get_channel(channel_id)
        
        if not channel:
            conn.close()
            return
        
        try:
            message = await channel.fetch_message(message_id)
        except:
            conn.close()
            return
        
        if participants:
            if len(participants) <= winner_count:
                winners_list = participants
            else:
                winners_list = random.sample(participants, winner_count)
            
            cursor.execute("UPDATE giveaways SET winners = ?, is_active = 0 WHERE id = ?", 
                         (json.dumps(winners_list), giveaway_id))
            conn.commit()
            
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ ğŸ‰",
                description="é–‹çå®Œæˆï¼",
                color=0x00FF00
            )
            
            new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
            new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(len(winners_list)), inline=True)
            new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
            
            winners_text = ""
            for i, winner_id in enumerate(winners_list[:5], 1):
                winners_text += f"{i}. <@{winner_id}>\n"
            
            if len(winners_list) > 5:
                winners_text += f"... é‚„æœ‰ {len(winners_list) - 5} äºº"
            
            if winners_text:
                new_embed.add_field(name="ğŸ† ç²çè€…", value=winners_text, inline=False)
            
            await message.edit(embed=new_embed)
            await message.clear_reactions()
            
            for winner_id in winners_list:
                await channel.send(f"ğŸ‰ æ­å–œ <@{winner_id}> ç²å¾—äº† **{prize}**ï¼")
        else:
            new_embed = discord.Embed(
                title="ğŸ‰ æŠ½çå·²çµæŸ",
                description="ç„¡äººåƒèˆ‡æŠ½ç" + ("ï¼ˆæ‰‹å‹•çµæŸï¼‰" if manual else ""),
                color=0xFF0000
            )
            await message.edit(embed=new_embed)
            await message.clear_reactions()
        
        conn.close()
        
    except Exception as e:
        print(f"çµæŸæŠ½çéŒ¯èª¤: {e}")

async def end_evaluation(event_id, channel, event_name):
    """çµæŸè©•æ ¸æ´»å‹•"""
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT participants, professions, ratings, rating_message_id 
            FROM evaluation_events 
            WHERE id = ?
        """, (event_id,))
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return
        
        participants_json, professions_json, ratings_json, rating_message_id = result
        
        participants = json.loads(participants_json) if participants_json else []
        professions = json.loads(professions_json) if professions_json else {}
        ratings = json.loads(ratings_json) if ratings_json else {}
        
        cursor.execute("UPDATE evaluation_events SET is_active = 0 WHERE id = ?", (event_id,))
        conn.commit()
        conn.close()
        
        try:
            rating_message = await channel.fetch_message(rating_message_id)
            await rating_message.clear_reactions()
            
            end_embed = discord.Embed(
                title=f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸï¼š{event_name}",
                description="æ­¤æ´»å‹•çš„è©•æ ¸éšæ®µå·²ç¶“çµæŸï¼Œæ„Ÿè¬æ‰€æœ‰åƒèˆ‡è€…ï¼",
                color=discord.Color.green()
            )
            
            end_embed.add_field(name="ğŸ“Š çµ±è¨ˆä¿¡æ¯", value=f"**ç¸½åƒèˆ‡äººæ•¸ï¼š** {len(participants)} äºº", inline=False)
            
            rating_summary = {}
            for user_id, rating_list in ratings.items():
                if rating_list:
                    latest_rating = rating_list[-1]["rating"]
                    rating_summary[latest_rating] = rating_summary.get(latest_rating, 0) + 1
            
            rating_text = ""
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_summary.get(rating_type, 0)
                if count > 0:
                    rating_text += f"**{rating_type}ï¼š** {count}äºº\n"
            
            if rating_text:
                end_embed.add_field(name="â­ è©•ç´šåˆ†ä½ˆ", value=rating_text, inline=False)
            
            await rating_message.edit(embed=end_embed)
            
        except Exception as e:
            print(f"æ›´æ–°è©•æ ¸è¨Šæ¯éŒ¯èª¤: {e}")
        
        summary_embed = discord.Embed(
            title=f"ğŸ æ´»å‹•ç¸½çµï¼š{event_name}",
            description="è©•æ ¸æ´»å‹•å·²æ­£å¼çµæŸï¼",
            color=discord.Color.gold()
        )
        
        summary_embed.add_field(name="ğŸ‘¥ åƒèˆ‡äººæ•¸", value=f"{len(participants)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ® è·æ¥­é¸æ“‡", value=f"{len(professions)} äºº", inline=True)
        summary_embed.add_field(name="â­ è©•æ ¸å®Œæˆ", value=f"{len(ratings)} äºº", inline=True)
        summary_embed.add_field(name="ğŸ“Š è©•ç´šåˆ†ä½ˆ", value=f"{len(rating_summary)} ç¨®è©•ç´š", inline=True)
        
        await channel.send(embed=summary_embed)
        
        print(f"âœ… è©•æ ¸æ´»å‹•å·²çµæŸ: {event_name}")
        
    except Exception as e:
        print(f"çµæŸè©•æ ¸æ´»å‹•éŒ¯èª¤: {e}")

# ========== äº‹ä»¶è™•ç† ==========

@bot.event
async def on_ready():
    """æ©Ÿå™¨äººä¸Šç·š"""
    print(f"\n{'='*60}")
    print(f"ğŸ¤– {BOT_NAME} å·²ä¸Šç·š")
    print(f"ğŸ“Š ä¼ºæœå™¨æ•¸é‡: {len(bot.guilds)}")
    print(f"{'='*60}")
    
    init_db()
    print("âœ… è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")
    
    try:
        print("\nğŸ”„ æ­£åœ¨åŒæ­¥æŒ‡ä»¤...")
        
        # ä¿®å¾©ï¼šä½¿ç”¨ tree è€Œä¸æ˜¯ bot.tree ä¾†åŒæ­¥
        global_synced = await tree.sync()
        print(f"âœ… å·²åŒæ­¥ {len(global_synced)} å€‹æŒ‡ä»¤")
        
        # é¡¯ç¤ºå¯ç”¨æŒ‡ä»¤
        if global_synced:
            print("\nğŸ“‹ å¯ç”¨æŒ‡ä»¤:")
            for cmd in global_synced:
                print(f"  â€¢ /{cmd.name} - {cmd.description}")
        
    except Exception as e:
        print(f"âŒ åŒæ­¥å¤±æ•—: {e}")
        
        # é‡è©¦ä¸€æ¬¡
        try:
            await asyncio.sleep(3)
            global_synced = await tree.sync()
            print(f"âœ… é‡è©¦å¾Œå·²åŒæ­¥ {len(global_synced)} å€‹æŒ‡ä»¤")
        except Exception as e2:
            print(f"âŒ é‡è©¦ä¹Ÿå¤±æ•—: {e2}")
    
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="/help æŸ¥çœ‹æŒ‡ä»¤"
        )
    )
    
    print(f"\nğŸ® æ©Ÿå™¨äººæº–å‚™å°±ç·’ï¼")

@bot.event
async def on_raw_reaction_add(payload):
    """è™•ç†åæ‡‰äº‹ä»¶"""
    if payload.user_id == bot.user.id:
        return
    
    try:
        emoji = str(payload.emoji)
        user_id = payload.user_id
        
        channel = bot.get_channel(payload.channel_id)
        if not channel:
            return
        
        try:
            message = await channel.fetch_message(payload.message_id)
        except:
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸çµæŸåæ‡‰
        cursor.execute("""
            SELECT id, channel_id, event_name 
            FROM evaluation_events 
            WHERE rating_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        rating_event = cursor.fetchone()
        
        if rating_event and emoji == RATING_END_EMOJI:
            event_id, event_channel_id, event_name = rating_event
            
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥çµæŸè©•æ ¸æ´»å‹•ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            confirm_embed = discord.Embed(
                title="ğŸ ç¢ºèªçµæŸè©•æ ¸æ´»å‹•",
                description=f"ä½ ç¢ºå®šè¦çµæŸ **{event_name}** çš„è©•æ ¸éšæ®µå—ï¼Ÿ",
                color=discord.Color.orange()
            )
            
            class ConfirmEndView(discord.ui.View):
                def __init__(self, event_id, channel, event_name):
                    super().__init__(timeout=60)
                    self.event_id = event_id
                    self.channel = channel
                    self.event_name = event_name
                
                @discord.ui.button(label="ç¢ºå®šçµæŸ", style=discord.ButtonStyle.danger, emoji="âœ…")
                async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.defer()
                    await end_evaluation(self.event_id, self.channel, self.event_name)
                    
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
                    
                    await interaction.followup.send(f"âœ… å·²æˆåŠŸçµæŸ **{self.event_name}** çš„è©•æ ¸éšæ®µï¼")
                
                @discord.ui.button(label="å–æ¶ˆ", style=discord.ButtonStyle.secondary, emoji="âŒ")
                async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if not interaction.user.guild_permissions.administrator:
                        await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                        return
                    
                    await interaction.response.send_message("å·²å–æ¶ˆçµæŸè©•æ ¸æ´»å‹•", ephemeral=True)
                    
                    for child in self.children:
                        child.disabled = True
                    await interaction.message.edit(view=self)
            
            view = ConfirmEndView(event_id, channel, event_name)
            await channel.send(f"<@{user_id}>", embed=confirm_embed, view=view)
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè©•æ ¸åæ‡‰
        if rating_event and emoji in RATING_EMOJIS:
            event_id, event_channel_id, event_name = rating_event
            rating_type = RATING_EMOJIS[emoji]
            
            print(f"æª¢æ¸¬åˆ°è©•æ ¸åæ‡‰: event_id={event_id}, rating_type={rating_type}, user_id={user_id}")
            
            try:
                guild = channel.guild
                member = await guild.fetch_member(user_id)
                if not member.guild_permissions.administrator:
                    try:
                        await message.remove_reaction(emoji, member)
                        await channel.send(f"âŒ <@{user_id}> åªæœ‰ç®¡ç†å“¡å¯ä»¥é€²è¡Œè©•æ ¸ï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as admin_error:
                print(f"æª¢æŸ¥ç®¡ç†å“¡æ¬Šé™éŒ¯èª¤: {admin_error}")
                conn.close()
                return
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            participants = []
            if result and result[0]:
                participants = json.loads(result[0])
            
            if not participants:
                await channel.send("âŒ æ²’æœ‰åƒèˆ‡è€…å¯ä»¥è©•æ ¸", delete_after=5)
                conn.close()
                return
            
            print(f"æ´»å‹• {event_name} æœ‰ {len(participants)} ä½åƒèˆ‡è€…å¯ä»¥è©•æ ¸")
            
            class ParticipantSelectView(discord.ui.View):
                def __init__(self, participants, event_id, rating_type, channel, bot_instance):
                    super().__init__(timeout=60)
                    self.participants = participants
                    self.event_id = event_id
                    self.rating_type = rating_type
                    self.channel = channel
                    self.bot = bot_instance
                    
                    options = []
                    for pid in participants[:25]:
                        member = self.bot.get_user(int(pid))
                        display_name = member.display_name if member else f"ç”¨æˆ¶ID: {pid}"
                        options.append(discord.SelectOption(
                            label=display_name[:100],
                            value=str(pid),
                            description=f"é»æ“Šé¸æ“‡æ­¤ç”¨æˆ¶é€²è¡Œ {rating_type} è©•æ ¸"
                        ))
                    
                    select = discord.ui.Select(
                        placeholder=f"é¸æ“‡è¦è©•æ ¸ç‚º {rating_type} çš„åƒèˆ‡è€…",
                        options=options,
                        min_values=1,
                        max_values=1
                    )
                    
                    async def select_callback(interaction: discord.Interaction):
                        if not interaction.user.guild_permissions.administrator:
                            await interaction.response.send_message("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™", ephemeral=True)
                            return
                        
                        selected_user_id = int(select.values[0])
                        selected_member = self.bot.get_user(selected_user_id)
                        display_name = selected_member.display_name if selected_member else f"ç”¨æˆ¶ID: {selected_user_id}"
                        
                        print(f"é¸æ“‡äº†ç”¨æˆ¶ {display_name} ({selected_user_id}) é€²è¡Œ {rating_type} è©•æ ¸")
                        
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        
                        cursor.execute("SELECT ratings FROM evaluation_events WHERE id = ?", (self.event_id,))
                        result = cursor.fetchone()
                        
                        ratings = {}
                        if result and result[0]:
                            ratings = json.loads(result[0])
                        
                        old_rating = None
                        if str(selected_user_id) in ratings and ratings[str(selected_user_id)]:
                            old_rating = ratings[str(selected_user_id)][-1]["rating"] if ratings[str(selected_user_id)] else None
                        
                        if str(selected_user_id) not in ratings:
                            ratings[str(selected_user_id)] = []
                        
                        ratings[str(selected_user_id)].append({
                            "rater": interaction.user.id,
                            "rating": self.rating_type,
                            "time": datetime.now().isoformat()
                        })
                        
                        cursor.execute("UPDATE evaluation_events SET ratings = ? WHERE id = ?", 
                                     (json.dumps(ratings), self.event_id))
                        conn.commit()
                        conn.close()
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            update_user_score(selected_user_id, display_name, -old_score, f"è©•ç´šè®Šæ›´: {old_rating} â†’ {self.rating_type}")
                            print(f"ç§»é™¤èˆŠè©•ç´šç©åˆ†: {old_rating} (-{old_score}åˆ†)")
                        
                        new_score = RATING_SCORES.get(self.rating_type, 0)
                        update_user_rating(selected_user_id, self.rating_type)
                        
                        if new_score != 0:
                            update_user_score(selected_user_id, display_name, new_score, f"æ´»å‹•è©•æ ¸: {self.rating_type}")
                            print(f"æ·»åŠ æ–°è©•ç´šç©åˆ†: {self.rating_type} (+{new_score}åˆ†)")
                        
                        score_change = RATING_SCORES.get(self.rating_type, 0)
                        
                        if old_rating and old_rating != self.rating_type:
                            old_score = RATING_SCORES.get(old_rating, 0)
                            result_text = f"å·²å°‡ <@{selected_user_id}> ({display_name}) çš„è©•ç´šå¾ **{old_rating}** ({old_score}åˆ†) è®Šæ›´ç‚º **{self.rating_type}** ({'+' if score_change > 0 else ''}{score_change}åˆ†)"
                        else:
                            result_text = f"å·²ç‚º <@{selected_user_id}> ({display_name}) è©•æ ¸ï¼š**{self.rating_type}** ({'+' if score_change > 0 else ''}{score_change}åˆ†)"
                        
                        result_embed = discord.Embed(
                            title="âœ… è©•æ ¸å®Œæˆ",
                            description=result_text,
                            color=discord.Color.green() if score_change >= 0 else discord.Color.red()
                        )
                        
                        result_embed.add_field(name="è©•æ ¸è€…", value=interaction.user.mention, inline=True)
                        result_embed.add_field(name="æ–°è©•ç´š", value=self.rating_type, inline=True)
                        result_embed.add_field(name="ç©åˆ†è®Šå‹•", value=f"{score_change} åˆ†", inline=True)
                        
                        await interaction.response.send_message(embed=result_embed)
                        
                        for child in self.children:
                            child.disabled = True
                        await interaction.message.edit(view=self)
                    
                    select.callback = select_callback
                    self.add_item(select)
            
            view = ParticipantSelectView(participants, event_id, rating_type, channel, bot)
            select_message = await channel.send(f"<@{user_id}> è«‹é¸æ“‡è¦è©•æ ¸ç‚º **{rating_type}** çš„åƒèˆ‡è€…ï¼š", view=view)
            print(f"å·²ç™¼é€é¸æ“‡è¦–çª—: message_id={select_message.id}")
            
            conn.close()
            return
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºæŠ½çè¨Šæ¯
        cursor.execute("""
            SELECT id, participants, creator_id 
            FROM giveaways 
            WHERE message_id = ? AND is_active = 1
        """, (payload.message_id,))
        giveaway = cursor.fetchone()
        
        if giveaway:
            giveaway_id, participants_json, creator_id = giveaway
            
            if emoji == "ğŸ«":
                participants = json.loads(participants_json) if participants_json else []
                
                if user_id not in participants:
                    participants.append(user_id)
                    cursor.execute("UPDATE giveaways SET participants = ? WHERE id = ?", 
                                 (json.dumps(participants), giveaway_id))
                    conn.commit()
                    
                    try:
                        if message.embeds:
                            embed = message.embeds[0]
                            new_embed = discord.Embed(
                                title=embed.title,
                                description=embed.description,
                                color=embed.color
                            )
                            
                            for field in embed.fields:
                                if field.name == "ğŸ« åƒèˆ‡äººæ•¸":
                                    new_embed.add_field(
                                        name="ğŸ« åƒèˆ‡äººæ•¸", 
                                        value=f"{len(participants)} äºº", 
                                        inline=field.inline
                                    )
                                else:
                                    new_embed.add_field(
                                        name=field.name, 
                                        value=field.value, 
                                        inline=field.inline
                                    )
                            
                            if embed.footer:
                                new_embed.set_footer(text=embed.footer.text)
                            
                            await message.edit(embed=new_embed)
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            elif emoji == "â¹ï¸" and user_id == creator_id:
                await end_giveaway(payload.message_id, manual=True)
                await channel.send(f"â¹ï¸ ä¸»è¾¦äººæ‰‹å‹•çµæŸäº†æŠ½çï¼")
        
        # è™•ç†è©•æ ¸æ´»å‹•ç°½åˆ°
        cursor.execute("""
            SELECT id, participants, signup_end_time 
            FROM evaluation_events 
            WHERE signup_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        signup_event = cursor.fetchone()
        
        if signup_event and emoji == "âœ…":
            event_id, participants_json, signup_end_time_str = signup_event
            
            try:
                if signup_end_time_str:
                    try:
                        signup_end_time = datetime.strptime(signup_end_time_str.split('.')[0], '%Y-%m-%d %H:%M:%S')
                    except:
                        try:
                            signup_end_time = datetime.strptime(signup_end_time_str, '%Y-%m-%d %H:%M:%S.%f')
                        except:
                            signup_end_time = None
                else:
                    signup_end_time = None
                
                if signup_end_time and datetime.now() > signup_end_time:
                    try:
                        await message.remove_reaction("âœ…", payload.member)
                        await channel.send(f"âŒ <@{user_id}> ç°½åˆ°æ™‚é–“å·²éï¼", delete_after=5)
                    except:
                        pass
                    conn.close()
                    return
            except Exception as time_error:
                print(f"æ™‚é–“è§£æéŒ¯èª¤: {time_error}")
            
            participants = json.loads(participants_json) if participants_json else []
            
            if user_id not in participants:
                participants.append(user_id)
                cursor.execute("UPDATE evaluation_events SET participants = ? WHERE id = ?", 
                             (json.dumps(participants), event_id))
                conn.commit()
                
                print(f"âœ… ç”¨æˆ¶ {user_id} æˆåŠŸç°½åˆ°æ´»å‹• {event_id}")
                
                try:
                    if message.embeds:
                        embed = message.embeds[0]
                        new_embed = discord.Embed(
                            title=embed.title,
                            description=embed.description,
                            color=embed.color
                        )
                        
                        for field in embed.fields:
                            if field.name == "ğŸ‘¥ å·²ç°½åˆ°":
                                new_embed.add_field(
                                    name="ğŸ‘¥ å·²ç°½åˆ°", 
                                    value=f"{len(participants)} äºº", 
                                    inline=field.inline
                                )
                            elif field.name == "â±ï¸ å‰©é¤˜æ™‚é–“":
                                new_embed.add_field(
                                    name=field.name,
                                    value=field.value,
                                    inline=field.inline
                                )
                            else:
                                new_embed.add_field(
                                    name=field.name, 
                                    value=field.value, 
                                    inline=field.inline
                                )
                        
                        if embed.footer:
                            new_embed.set_footer(text=embed.footer.text)
                        
                        await message.edit(embed=new_embed)
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
        
        # è™•ç†è·æ¥­é¸æ“‡
        cursor.execute("""
            SELECT id, professions 
            FROM evaluation_events 
            WHERE profession_message_id = ? AND is_active = 1
        """, (payload.message_id,))
        profession_event = cursor.fetchone()
        
        if profession_event and emoji in PROFESSION_EMOJIS:
            event_id, professions_json = profession_event
            profession_name = PROFESSION_EMOJIS[emoji]
            
            cursor.execute("SELECT participants FROM evaluation_events WHERE id = ?", (event_id,))
            result = cursor.fetchone()
            
            if result and result[0]:
                participants = json.loads(result[0])
                
                if user_id in participants:
                    professions = json.loads(professions_json) if professions_json else {}
                    
                    if str(user_id) not in professions:
                        professions[str(user_id)] = profession_name
                        cursor.execute("UPDATE evaluation_events SET professions = ? WHERE id = ?", 
                                     (json.dumps(professions), event_id))
                        conn.commit()
                        
                        update_user_profession(user_id, profession_name)
                        
                        try:
                            bonus = PROFESSION_BONUS.get(profession_name, 0)
                            bonus_text = f"ï¼ˆç²å¾—è·æ¥­åŠ æˆï¼š+{bonus}ç©åˆ†ï¼‰" if bonus > 0 else ""
                            await channel.send(f"âœ… <@{user_id}> å·²é¸æ“‡è·æ¥­ï¼š**{profession_name}**{bonus_text}", delete_after=5)
                        except:
                            pass
                    else:
                        try:
                            await message.remove_reaction(emoji, payload.member)
                            await channel.send(f"âš ï¸ <@{user_id}> ä½ å·²ç¶“é¸æ“‡éè·æ¥­äº†ï¼", delete_after=5)
                        except:
                            pass
                else:
                    try:
                        await message.remove_reaction(emoji, payload.member)
                        await channel.send(f"âŒ <@{user_id}> è«‹å…ˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼", delete_after=5)
                    except:
                        pass
        
        conn.close()
        
    except Exception as e:
        print(f"è™•ç†åæ‡‰éŒ¯èª¤: {e}")
        import traceback
        traceback.print_exc()

# ========== æ–œæ§“æŒ‡ä»¤ ==========

# æŒ‡ä»¤ 1: sync (æ“æœ‰è€…)
@tree.command(name="sync", description="åŒæ­¥æ–œæ§“æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰")
async def sync_slash(interaction: discord.Interaction):
    """åŒæ­¥æŒ‡ä»¤"""
    await interaction.response.defer(ephemeral=True)
    
    if interaction.user.id not in OWNER_IDS:
        embed = discord.Embed(
            title="âŒ æ¬Šé™ä¸è¶³",
            description="åªæœ‰æ©Ÿå™¨äººæ“æœ‰è€…å¯ä»¥ä½¿ç”¨æ­¤æŒ‡ä»¤",
            color=0xFF0000
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        return
    
    try:
        print("ğŸ”„ æ‰‹å‹•åŒæ­¥æŒ‡ä»¤ä¸­...")
        global_synced = await tree.sync()
        
        embed = discord.Embed(
            title="ğŸ”„ æŒ‡ä»¤åŒæ­¥å®Œæˆ",
            description=f"å·²åŒæ­¥ {len(global_synced)} å€‹æŒ‡ä»¤",
            color=0x43B581
        )
        
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åŒæ­¥å¤±æ•—",
            description=f"éŒ¯èª¤è¨Šæ¯: {str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed, ephemeral=True)

# æŒ‡ä»¤ 2: help
@tree.command(name="help", description="é¡¯ç¤ºå¹«åŠ©è¨Šæ¯")
async def help_slash(interaction: discord.Interaction):
    """é¡¯ç¤ºå¹«åŠ©"""
    embed = discord.Embed(
        title="ğŸ¤– å°é›²æ©Ÿæ¢°äºº - å¹«åŠ©ä¸­å¿ƒ",
        description="ä»¥ä¸‹æ˜¯å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ï¼š",
        color=0x7289DA
    )
    
    embed.add_field(
        name="ğŸ‘¤ ç”¨æˆ¶æŒ‡ä»¤",
        value=(
            "`/help` - é¡¯ç¤ºæ­¤å¹«åŠ©è¨Šæ¯\n"
            "`/profile` - æŸ¥çœ‹æˆ‘çš„æ•¸æ“š\n"
            "`/giveaway` - å‰µå»ºæŠ½ç\n"
            "`/score_draw` - ä½¿ç”¨ç©åˆ†æŠ½ç\n"
            "`/score_transfer` - è½‰ç§»ç©åˆ†\n"
            "`/prizelist` - æŸ¥çœ‹å½©æ± åˆ—è¡¨\n"
            "`/random_team` - éš¨æ©Ÿåˆ†çµ„"
        ),
        inline=False
    )
    
    embed.add_field(
        name="ğŸ› ï¸ ç®¡ç†å“¡æŒ‡ä»¤",
        value=(
            "`/add_prize` - èª¿æ•´å½©æ± \n"
            "`/add_score` - åŠ æ¸›ç©åˆ†\n"
            "`/create_event` - å‰µå»ºè©•æ ¸æ´»å‹•\n"
            "`/all_profiles` - æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™\n"
            "`/attendance_stats` - æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ\n"
            "`/sync` - åŒæ­¥æŒ‡ä»¤ï¼ˆæ“æœ‰è€…ï¼‰\n"
            "`/ping` - æ¸¬è©¦æ©Ÿå™¨äººå»¶é²"
        ),
        inline=False
    )
    
    embed.set_footer(text="å…±13å€‹æŒ‡ä»¤ | ä½¿ç”¨ / é–‹é ­è¼¸å…¥æŒ‡ä»¤")
    await interaction.response.send_message(embed=embed)

# æŒ‡ä»¤ 3: profile
@tree.command(name="profile", description="æŸ¥çœ‹æˆ‘çš„æ•¸æ“š")
async def profile_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        user_id = interaction.user.id
        username = interaction.user.name
        
        profile = get_user_profile(user_id)
        
        if not profile:
            conn = sqlite3.connect(DB_NAME)
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO users (user_id, username, current_score, total_score) VALUES (?, ?, ?, ?)",
                (user_id, username, 0, 0)
            )
            conn.commit()
            conn.close()
            
            profile = {
                'user_id': user_id,
                'current_score': 0,
                'total_score': 0,
                'join_date': datetime.now().strftime('%Y-%m-%d'),
                'profession_counts': {},
                'activity_stats': {},
                'rating_stats': {}
            }
        
        current_score = profile['current_score']
        total_score = profile['total_score']
        join_date_str = profile['join_date']
        profession_counts = profile['profession_counts']
        activity_stats = profile['activity_stats']
        rating_stats = profile['rating_stats']
        
        current_period = get_current_half_month()
        period_data = activity_stats.get(current_period, {})
        total_events = period_data.get('total', 0)
        attended_events = period_data.get('attended', 0)
        attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
        
        embed = discord.Embed(
            title=f"ğŸ“Š {username} çš„è©•æ ¸æ•¸æ“š",
            color=0x43B581
        )
        
        attendance_info = (
            f"**ç•¶å‰åŠæœˆæœŸï¼š** {current_period}\n"
            f"**ç¸½æ´»å‹•æ•¸ï¼š** {total_events} æ¬¡\n"
            f"**å¯¦éš›å‡ºå¸­ï¼š** {attended_events} æ¬¡\n"
            f"**å‡ºå¸­ç‡ï¼š** {attendance_rate:.1f}%\n"
        )
        
        embed.add_field(
            name="ğŸ“… åŠæœˆæœŸå‡ºå¸­ç‡",
            value=attendance_info,
            inline=False
        )
        
        score_info = f"**ç•¶å‰ç©åˆ†ï¼š** {current_score} åˆ†\n"
        score_info += f"**ç¸½ç²å¾—ç©åˆ†ï¼š** {total_score} åˆ†\n\n"
        score_info += f"**ç©åˆ†è¦å‰‡ï¼š**\n"
        score_info += f"â€¢ ç°½åˆ°ï¼š+{SIGNUP_SCORE}åˆ†\n"
        for profession, bonus in PROFESSION_BONUS.items():
            if bonus > 0:
                score_info += f"â€¢ {profession}ï¼š+{bonus}åˆ†\n"
        score_info += f"â€¢ å„ªç§€ï¼š+{RATING_SCORES['å„ªç§€']}åˆ†\n"
        score_info += f"â€¢ è‰¯å¥½ï¼š+{RATING_SCORES['è‰¯å¥½']}åˆ†\n"
        score_info += f"â€¢ æ™®é€šï¼š{RATING_SCORES['æ™®é€š']}åˆ†ï¼ˆé è¨­ï¼‰\n"
        score_info += f"â€¢ ä¸åˆæ ¼ï¼š{RATING_SCORES['ä¸åˆæ ¼']}åˆ†"
        
        embed.add_field(
            name="ğŸ’° ç©åˆ†çµ±è¨ˆ",
            value=score_info,
            inline=False
        )
        
        if profession_counts:
            profession_info = ""
            total_plays = sum(profession_counts.values())
            for profession, count in profession_counts.items():
                percentage = (count / total_plays * 100) if total_plays > 0 else 0
                profession_info += f"**{profession}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
        else:
            profession_info = "å°šæœªè¨˜éŒ„è·æ¥­æ•¸æ“š"
        
        embed.add_field(
            name="ğŸ® è·æ¥­çµ±è¨ˆ",
            value=profession_info,
            inline=False
        )
        
        if rating_stats:
            rating_info = ""
            total_ratings = sum(rating_stats.values())
            total_rating_score = 0
            
            for rating_type in ["å„ªç§€", "è‰¯å¥½", "æ™®é€š", "ä¸åˆæ ¼"]:
                count = rating_stats.get(rating_type, 0)
                if count > 0:
                    percentage = (count / total_ratings * 100) if total_ratings > 0 else 0
                    score = RATING_SCORES.get(rating_type, 0)
                    rating_info += f"**{rating_type}ï¼š** {count}æ¬¡ ({percentage:.1f}%)\n"
                    total_rating_score += count * score
            
            if total_ratings > 0:
                rating_info += f"\n**è©•æ ¸ç¸½ç²å¾—ç©åˆ†ï¼š** {total_rating_score} åˆ†"
        else:
            rating_info = "å°šæœªæœ‰è©•æ ¸è¨˜éŒ„"
        
        embed.add_field(
            name="â­ è©•æ ¸çµ±è¨ˆ",
            value=rating_info,
            inline=False
        )
        
        embed.add_field(name="ç”¨æˆ¶ID", value=f"`{user_id}`", inline=True)
        embed.add_field(name="åŠ å…¥æ—¥æœŸ", value=join_date_str, inline=True)
        
        if interaction.user.avatar:
            embed.set_thumbnail(url=interaction.user.avatar.url)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ ç™¼ç”ŸéŒ¯èª¤",
            description=f"ç„¡æ³•è®€å–ç”¨æˆ¶è³‡æ–™ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 4: giveaway
@tree.command(name="giveaway", description="å‰µå»ºæŠ½çæ´»å‹•")
@app_commands.describe(
    prize="çå“å…§å®¹",
    duration="æŠ½çæŒçºŒæ™‚é–“ï¼ˆä¾‹å¦‚ï¼š60s, 1m, 1h, 1dï¼‰",
    winners="ç²çäººæ•¸"
)
async def giveaway_slash(
    interaction: discord.Interaction,
    prize: str,
    duration: str = "1h",
    winners: int = 1
):
    """å‰µå»ºæŠ½ç"""
    await interaction.response.defer()
    
    try:
        duration_lower = duration.lower().strip()
        seconds = 3600
        
        if duration_lower.endswith('s'):
            seconds = int(duration_lower[:-1])
        elif duration_lower.endswith('m'):
            seconds = int(duration_lower[:-1]) * 60
        elif duration_lower.endswith('h'):
            seconds = int(duration_lower[:-1]) * 3600
        elif duration_lower.endswith('d'):
            seconds = int(duration_lower[:-1]) * 86400
        elif duration_lower.isdigit():
            seconds = int(duration_lower)
        
        if seconds < 10:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“å¿…é ˆè‡³å°‘10ç§’ï¼")
            return
        
        if seconds > 86400 * 7:
            await interaction.followup.send("âŒ æŠ½çæ™‚é–“ä¸èƒ½è¶…é7å¤©ï¼")
            return
        
        end_time = datetime.now() + timedelta(seconds=seconds)
        
        if seconds < 60:
            time_display = f"{seconds}ç§’"
        elif seconds < 3600:
            time_display = f"{seconds//60}åˆ†{seconds%60}ç§’"
        elif seconds < 86400:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            time_display = f"{hours}å°æ™‚{minutes}åˆ†"
        else:
            days = seconds // 86400
            hours = (seconds % 86400) // 3600
            time_display = f"{days}å¤©{hours}å°æ™‚"
        
        embed = discord.Embed(
            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
            color=0xFFD700
        )
        
        embed.add_field(name="ğŸ çå“", value=prize, inline=True)
        embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
        embed.add_field(name="â° çµæŸæ™‚é–“", value=time_display, inline=True)
        embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value="0 äºº", inline=True)
        embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
        embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
        
        creator_name = interaction.user.display_name
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
        giveaway_id = f"giveaway_{int(time.time())}_{random.randint(1000, 9999)}"
        
        embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{current_time}")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ«")
        await message.add_reaction("â¹ï¸")
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO giveaways (creator_id, prize, winner_count, end_time, message_id, channel_id)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (interaction.user.id, prize, winners, end_time, message.id, interaction.channel.id))
        conn.commit()
        conn.close()
        
        print(f"âœ… æŠ½çå·²å‰µå»º: çå“={prize}, æ™‚é–“={seconds}ç§’, è¨Šæ¯ID={message.id}")
        
        async def countdown_timer():
            remaining = seconds
            last_update = time.time()
            
            while remaining > 0:
                await asyncio.sleep(1)
                remaining -= 1
                
                if time.time() - last_update >= 30:
                    if remaining < 60:
                        time_display = f"{remaining}ç§’"
                    elif remaining < 3600:
                        time_display = f"{remaining//60}åˆ†{remaining%60}ç§’"
                    elif remaining < 86400:
                        hours = remaining // 3600
                        minutes = (remaining % 3600) // 60
                        time_display = f"{hours}å°æ™‚{minutes}åˆ†"
                    else:
                        days = remaining // 86400
                        hours = (remaining % 86400) // 3600
                        time_display = f"{days}å¤©{hours}å°æ™‚"
                    
                    try:
                        conn = sqlite3.connect(DB_NAME)
                        cursor = conn.cursor()
                        cursor.execute("SELECT participants FROM giveaways WHERE message_id = ?", (message.id,))
                        result = cursor.fetchone()
                        participants_count = 0
                        if result and result[0]:
                            participants = json.loads(result[0])
                            participants_count = len(participants)
                        conn.close()
                        
                        new_embed = discord.Embed(
                            title="ğŸ‰ è‡ªå‹•æŠ½çæ´»å‹• ğŸ‰",
                            description="æ™‚é–“åˆ°è‡ªå‹•é–‹çï¼",
                            color=0xFFD700
                        )
                        
                        new_embed.add_field(name="ğŸ çå“", value=prize, inline=True)
                        new_embed.add_field(name="ğŸ‘‘ ä¸­çäººæ•¸", value=str(winners), inline=True)
                        new_embed.add_field(name="â° çµæŸæ™‚é–“", value=f"{time_display}å…§", inline=True)
                        new_embed.add_field(name="ğŸ« åƒèˆ‡äººæ•¸", value=f"{participants_count} äºº", inline=True)
                        new_embed.add_field(name="ğŸ“ åƒèˆ‡æ–¹å¼", value="é»æ“Šä¸‹æ–¹ ğŸ« æŒ‰éˆ•åƒèˆ‡", inline=True)
                        new_embed.add_field(name="ğŸ”§ ä¸»è¾¦äººæ“ä½œ", value="é»æ“Š â¹ï¸ æ‰‹å‹•çµæŸæŠ½ç", inline=True)
                        
                        new_embed.set_footer(text=f"æŠ½çID: {giveaway_id} | ä¸»è¾¦äºº: {creator_name}â€¢{datetime.now().strftime('%Y-%m-%d %H:%M')}")
                        
                        await message.edit(embed=new_embed)
                        last_update = time.time()
                        
                    except Exception as e:
                        print(f"æ›´æ–°æŠ½çè¨Šæ¯éŒ¯èª¤: {e}")
            
            await end_giveaway(message.id)
        
        asyncio.create_task(countdown_timer())
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 5: score_draw
@tree.command(name="score_draw", description="ä½¿ç”¨ç©åˆ†æŠ½ç")
async def score_draw_slash(interaction: discord.Interaction):
    """ç©åˆ†æŠ½ç"""
    await interaction.response.defer()
    
    try:
        current_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ² ç©åˆ†æŠ½çç³»çµ±",
            description="è«‹é¸æ“‡è¦æ‰£é™¤çš„ç©åˆ†é€²è¡ŒæŠ½çï¼š",
            color=0x9B59B6
        )
        
        embed.add_field(
            name="ğŸŸ¢ 50ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 70%\nâ€¢ è—ç®± 25%\nâ€¢ ç´«ç®± 4.5%\nâ€¢ é‡‘ç®± 0.5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ”µ 100ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 50%\nâ€¢ è—ç®± 40%\nâ€¢ ç´«ç®± 9%\nâ€¢ é‡‘ç®± 1%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸŸ£ 500ç©åˆ†æŠ½ç",
            value="â€¢ ç¶ ç®± 10%\nâ€¢ è—ç®± 65%\nâ€¢ ç´«ç®± 20%\nâ€¢ é‡‘ç®± 5%",
            inline=True
        )
        
        embed.add_field(
            name="ğŸ’° ä½ çš„ç©åˆ†",
            value=f"{current_score} åˆ†",
            inline=False
        )
        
        embed.set_footer(text="é»æ“Šä¸‹æ–¹å°æ‡‰çš„emojié¸æ“‡æŠ½çé¡å‹")
        
        class ScoreDrawView(discord.ui.View):
            def __init__(self, user_id):
                super().__init__(timeout=60)
                self.user_id = user_id
            
            @discord.ui.button(label="50åˆ†", style=discord.ButtonStyle.success, emoji="ğŸŸ¢", row=0)
            async def fifty_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 50)
            
            @discord.ui.button(label="100åˆ†", style=discord.ButtonStyle.primary, emoji="ğŸ”µ", row=0)
            async def hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 100)
            
            @discord.ui.button(label="500åˆ†", style=discord.ButtonStyle.secondary, emoji="ğŸŸ£", row=1)
            async def five_hundred_points(self, interaction: discord.Interaction, button: discord.ui.Button):
                await self.process_draw(interaction, 500)
            
            async def process_draw(self, interaction: discord.Interaction, score_cost: int):
                if interaction.user.id != self.user_id:
                    await interaction.response.send_message("âŒ é€™ä¸æ˜¯ä½ çš„æŠ½çï¼", ephemeral=True)
                    return
                
                current_score, _ = get_user_score(interaction.user.id)
                if current_score < score_cost:
                    await interaction.response.send_message(
                        f"âŒ ç©åˆ†ä¸è¶³ï¼éœ€è¦ {score_cost} åˆ†ï¼Œä½ ç›®å‰æœ‰ {current_score} åˆ†",
                        ephemeral=True
                    )
                    return
                
                weights = {
                    50: {"ç¶ ç®±": 70, "è—ç®±": 25, "ç´«ç®±": 4.5, "é‡‘ç®±": 0.5},
                    100: {"ç¶ ç®±": 50, "è—ç®±": 40, "ç´«ç®±": 9, "é‡‘ç®±": 1},
                    500: {"ç¶ ç®±": 10, "è—ç®±": 65, "ç´«ç®±": 20, "é‡‘ç®±": 5}
                }
                
                box_weights = weights[score_cost]
                box_types = list(box_weights.keys())
                box_weights_list = list(box_weights.values())
                selected_box = random.choices(box_types, weights=box_weights_list, k=1)[0]
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute(
                    "SELECT id, prize_name FROM prize_pool WHERE box_level = ? AND remaining > 0 ORDER BY RANDOM() LIMIT 1",
                    (selected_box,)
                )
                result = cursor.fetchone()
                
                if not result:
                    await interaction.response.send_message(f"âŒ {selected_box}ä¸­æ²’æœ‰å¯ç”¨çå“ï¼", ephemeral=True)
                    conn.close()
                    return
                
                prize_id, prize_name = result
                
                update_user_score(interaction.user.id, interaction.user.name, -score_cost, f"ç©åˆ†æŠ½ç ({selected_box})")
                cursor.execute("UPDATE prize_pool SET remaining = remaining - 1 WHERE id = ?", (prize_id,))
                
                cursor.execute('''
                    INSERT INTO score_draws (creator_id, score_cost, box_level, winner_prize, winner_id)
                    VALUES (?, ?, ?, ?, ?)
                ''', (interaction.user.id, score_cost, selected_box, prize_name, interaction.user.id))
                
                conn.commit()
                conn.close()
                
                new_current_score, _ = get_user_score(interaction.user.id)
                
                result_embed = discord.Embed(
                    title="ğŸ‰ æŠ½ççµæœ",
                    description=f"ä½ æŠ½ä¸­äº† **{prize_name}**ï¼",
                    color=0x00FF00
                )
                
                result_embed.add_field(name="æ‰£é™¤ç©åˆ†", value=f"{score_cost} åˆ†", inline=True)
                result_embed.add_field(name="å¯¶ç®±é¡å‹", value=selected_box, inline=True)
                result_embed.add_field(name="ä¸­çæ©Ÿç‡", value=f"{box_weights[selected_box]}%", inline=True)
                result_embed.add_field(name="å‰©é¤˜ç©åˆ†", value=f"{new_current_score} åˆ†", inline=True)
                result_embed.add_field(name="çå“åç¨±", value=prize_name, inline=False)
                
                await interaction.response.send_message(embed=result_embed, ephemeral=False)
                
                for child in self.children:
                    child.disabled = True
                
                await interaction.message.edit(view=self)
        
        view = ScoreDrawView(interaction.user.id)
        await interaction.followup.send(embed=embed, view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æŠ½çå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 6: score_transfer
@tree.command(name="score_transfer", description="è½‰ç§»ç©åˆ†çµ¦å…¶ä»–ç”¨æˆ¶")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="è½‰ç§»ç©åˆ†",
    reason="åŸå› ï¼ˆå¯é¸ï¼‰"
)
async def score_transfer_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: Optional[str] = None
):
    """è½‰ç§»ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if amount <= 0:
            await interaction.followup.send("âŒ ç©åˆ†å¿…é ˆå¤§æ–¼ 0")
            return
        
        if user.id == interaction.user.id:
            await interaction.followup.send("âŒ ä¸èƒ½è½‰ç§»ç©åˆ†çµ¦è‡ªå·±")
            return
        
        sender_score, _ = get_user_score(interaction.user.id)
        
        if sender_score < amount:
            await interaction.followup.send(f"âŒ ä½ çš„ç©åˆ†ä¸è¶³ï¼éœ€è¦ {amount} åˆ†ï¼Œä½ ç›®å‰æœ‰ {sender_score} åˆ†")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        update_user_score(interaction.user.id, interaction.user.name, -amount, f"è½‰ç§»çµ¦ {user.name}")
        update_user_score(user.id, user.name, amount, f"ä¾†è‡ª {interaction.user.name} çš„è½‰ç§»")
        
        cursor.execute('''
            INSERT INTO score_transfers (from_user_id, to_user_id, amount, reason)
            VALUES (?, ?, ?, ?)
        ''', (interaction.user.id, user.id, amount, reason or "ç„¡"))
        
        conn.commit()
        conn.close()
        
        new_sender_score, _ = get_user_score(interaction.user.id)
        
        embed = discord.Embed(
            title="ğŸ’¸ ç©åˆ†è½‰ç§»æˆåŠŸ",
            description=f"**è½‰å‡ºï¼š** {interaction.user.mention}\n"
                       f"**è½‰å…¥ï¼š** {user.mention}\n"
                       f"**é‡‘é¡ï¼š** {amount} åˆ†\n"
                       f"**åŸå› ï¼š** {reason or 'ç„¡'}\n"
                       f"**ä½ çš„å‰©é¤˜ç©åˆ†ï¼š** {new_sender_score} åˆ†",
            color=0x2ECC71
        )
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è½‰ç§»å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 7: prizelist
@tree.command(name="prizelist", description="æŸ¥çœ‹å½©æ± åˆ—è¡¨")
async def prizelist_slash(interaction: discord.Interaction):
    """æŸ¥çœ‹å½©æ± """
    await interaction.response.defer()
    
    try:
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT box_level, 
                   COUNT(*) as total_items,
                   SUM(remaining) as total_remaining
            FROM prize_pool 
            WHERE remaining > 0 
            GROUP BY box_level 
            ORDER BY 
                CASE box_level 
                    WHEN 'é‡‘ç®±' THEN 1 
                    WHEN 'ç´«ç®±' THEN 2 
                    WHEN 'è—ç®±' THEN 3 
                    WHEN 'ç¶ ç®±' THEN 4 
                    ELSE 5 
                END
        """)
        
        results = cursor.fetchall()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ å½©æ± åˆ—è¡¨",
                description="ç›®å‰å½©æ± æ˜¯ç©ºçš„",
                color=0xFFD700
            )
            await interaction.followup.send(embed=embed)
            conn.close()
            return
        
        embed = discord.Embed(
            title="ğŸ å½©æ± åˆ—è¡¨",
            description="å¯ç”¨çš„çå“ï¼ˆæŒ‰å¯¶ç®±ç­‰ç´šåˆ†é¡ï¼‰ï¼š",
            color=0xFFD700
        )
        
        for box_level, total_items, total_remaining in results:
            cursor.execute("""
                SELECT prize_name, remaining 
                FROM prize_pool 
                WHERE box_level = ? AND remaining > 0 
                ORDER BY prize_name
            """, (box_level,))
            
            items = cursor.fetchall()
            
            items_text = ""
            displayed_count = 0
            hidden_count = 0
            
            for prize_name, remaining in items:
                displayed_count += 1
                if displayed_count <= 8:
                    items_text += f"â€¢ {prize_name} (å‰©é¤˜: {remaining})\n"
                else:
                    hidden_count += 1
            
            if hidden_count > 0:
                items_text += f"... é‚„æœ‰ {hidden_count} å€‹çå“\n"
            
            actual_total = sum(item[1] for item in items)
            
            embed.add_field(
                name=f"{box_level} (ç¸½å‰©é¤˜: {actual_total} / çå“ç¨®é¡: {total_items})",
                value=items_text if items_text else "ç„¡çå“",
                inline=False
            )
        
        conn.close()
        
        embed.add_field(
            name="ğŸ“Š ç©åˆ†æŠ½çæ©Ÿç‡",
            value="**50ç©åˆ†ï¼š** ç¶ ç®±70% è—ç®±25% ç´«ç®±4.5% é‡‘ç®±0.5%\n"
                  "**100ç©åˆ†ï¼š** ç¶ ç®±50% è—ç®±40% ç´«ç®±9% é‡‘ç®±1%\n"
                  "**500ç©åˆ†ï¼š** ç¶ ç®±10% è—ç®±65% ç´«ç®±20% é‡‘ç®±5%",
            inline=False
        )
        
        embed.set_footer(text="ä½¿ç”¨ /add_prize æ·»åŠ çå“åˆ°å½©æ± ")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å½©æ± å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 8: random_team
@tree.command(name="random_team", description="éš¨æ©Ÿåˆ†çµ„")
@app_commands.describe(
    team_size="æ¯çµ„äººæ•¸",
    team_count="çµ„æ•¸"
)
async def random_team_slash(
    interaction: discord.Interaction,
    team_size: Optional[int] = None,
    team_count: Optional[int] = None
):
    """éš¨æ©Ÿåˆ†çµ„"""
    await interaction.response.defer()
    
    try:
        if not interaction.guild:
            await interaction.followup.send("âŒ æ­¤æŒ‡ä»¤åªèƒ½åœ¨ä¼ºæœå™¨ä¸­ä½¿ç”¨")
            return
        
        embed = discord.Embed(
            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
            color=0x3498DB
        )
        
        if team_size:
            embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
        if team_count:
            embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
        
        embed.add_field(name="åƒåŠ äººæ•¸", value="0 äºº", inline=True)
        embed.set_footer(text="ç­‰å¾…åƒåŠ è€…...")
        
        await interaction.followup.send(embed=embed)
        message = await interaction.original_response()
        
        await message.add_reaction("ğŸ®")
        await message.add_reaction("â–¶ï¸")
        
        participants = []
        
        def check(reaction, user):
            return (
                user != bot.user and
                str(reaction.emoji) in ["ğŸ®", "â–¶ï¸"] and
                reaction.message.id == message.id
            )
        
        try:
            while True:
                reaction, user = await bot.wait_for('reaction_add', timeout=300.0, check=check)
                
                if str(reaction.emoji) == "ğŸ®":
                    if user.id not in participants:
                        participants.append(user.id)
                        
                        new_embed = discord.Embed(
                            title="ğŸ‘¥ éš¨æ©Ÿåˆ†çµ„",
                            description="é»æ“Š ğŸ® æŒ‰éˆ•åƒåŠ åˆ†çµ„\nä¸»æŒäººé»æ“Š â–¶ï¸ æŒ‰éˆ•é–‹å§‹åˆ†çµ„",
                            color=0x3498DB
                        )
                        
                        if team_size:
                            new_embed.add_field(name="æ¯çµ„äººæ•¸", value=str(team_size), inline=True)
                        if team_count:
                            new_embed.add_field(name="çµ„æ•¸", value=str(team_count), inline=True)
                        
                        new_embed.add_field(name="åƒåŠ äººæ•¸", value=f"{len(participants)} äºº", inline=True)
                        
                        if participants:
                            participants_text = ""
                            for i, pid in enumerate(participants[:10], 1):
                                participants_text += f"{i}. <@{pid}>\n"
                            if len(participants) > 10:
                                participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                            
                            new_embed.add_field(name="åƒåŠ è€…", value=participants_text, inline=False)
                        
                        new_embed.set_footer(text=f"ç­‰å¾…ä¸»æŒäººé–‹å§‹... ({len(participants)}äººåƒåŠ )")
                        
                        await message.edit(embed=new_embed)
                        
                elif str(reaction.emoji) == "â–¶ï¸" and user.id == interaction.user.id:
                    if len(participants) < 2:
                        await message.channel.send("âŒ è‡³å°‘éœ€è¦2äººæ‰èƒ½é–‹å§‹åˆ†çµ„", delete_after=5)
                        continue
                    
                    random.shuffle(participants)
                    
                    if team_size:
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    elif team_count:
                        team_size = len(participants) // team_count
                        if len(participants) % team_count != 0:
                            team_size += 1
                    else:
                        if len(participants) <= 4:
                            team_size = 2
                        elif len(participants) <= 8:
                            team_size = 4
                        else:
                            team_size = 5
                        
                        team_count = len(participants) // team_size
                        if len(participants) % team_size != 0:
                            team_count += 1
                    
                    teams = []
                    for i in range(team_count):
                        start_idx = i * team_size
                        end_idx = min((i + 1) * team_size, len(participants))
                        if start_idx < len(participants):
                            teams.append(participants[start_idx:end_idx])
                    
                    result_embed = discord.Embed(
                        title="ğŸ‘¥ åˆ†çµ„çµæœ",
                        description=f"ç¸½äººæ•¸ï¼š{len(participants)} äºº\n"
                                   f"åˆ†çµ„æ–¹å¼ï¼š{team_count} çµ„ï¼Œæ¯çµ„ç´„ {team_size} äºº",
                        color=0x00FF00
                    )
                    
                    for i, team in enumerate(teams, 1):
                        members_list = "\n".join([f"{j+1}. <@{member_id}>" for j, member_id in enumerate(team)])
                        result_embed.add_field(
                            name=f"ç¬¬ {i} çµ„ ({len(team)}äºº)",
                            value=members_list,
                            inline=False
                        )
                    
                    await message.channel.send(embed=result_embed)
                    await message.clear_reactions()
                    break
        
        except asyncio.TimeoutError:
            timeout_embed = discord.Embed(
                title="ğŸ‘¥ åˆ†çµ„è¶…æ™‚",
                description="åˆ†çµ„æ™‚é–“å·²é",
                color=0xFF0000
            )
            await message.edit(embed=timeout_embed)
            await message.clear_reactions()
            
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ åˆ†çµ„å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 9: add_prize (ç®¡ç†å“¡)
@tree.command(name="add_prize", description="æ·»åŠ çå“åˆ°å½©æ± ")
@app_commands.describe(
    name="çå“åç¨±",
    box_level="å¯¶ç®±ç­‰ç´š (ç¶ ç®±/è—ç®±/ç´«ç®±/é‡‘ç®±)",
    quantity="æ•¸é‡ (æ­£æ•¸æ·»åŠ , è² æ•¸æ¸›å°‘)"
)
async def add_prize_slash(
    interaction: discord.Interaction,
    name: str,
    box_level: str,
    quantity: int
):
    """æ·»åŠ /æ¸›å°‘çå“"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        valid_levels = ["ç¶ ç®±", "è—ç®±", "ç´«ç®±", "é‡‘ç®±"]
        if box_level not in valid_levels:
            await interaction.followup.send(f"âŒ ç„¡æ•ˆçš„å¯¶ç®±ç­‰ç´šï¼è«‹é¸æ“‡ï¼š{', '.join(valid_levels)}")
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        if quantity > 0:
            cursor.execute('''
                INSERT INTO prize_pool (prize_name, box_level, quantity, remaining, added_by)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(prize_name, box_level) 
                DO UPDATE SET 
                    quantity = quantity + excluded.quantity,
                    remaining = remaining + excluded.quantity
            ''', (name, box_level, quantity, quantity, interaction.user.id))
            
            action = "æ·»åŠ "
        elif quantity < 0:
            cursor.execute('''
                UPDATE prize_pool 
                SET quantity = quantity + ?,
                    remaining = CASE 
                                    WHEN remaining + ? > 0 THEN remaining + ?
                                    ELSE 0
                                END
                WHERE prize_name = ? AND box_level = ?
            ''', (quantity, quantity, quantity, name, box_level))
            
            if cursor.rowcount == 0:
                await interaction.followup.send(f"âŒ æ‰¾ä¸åˆ°çå“ '{name}' åœ¨ {box_level} ä¸­")
                conn.close()
                return
            
            action = "æ¸›å°‘"
        else:
            await interaction.followup.send("âŒ æ•¸é‡ä¸èƒ½ç‚º 0")
            conn.close()
            return
        
        cursor.execute("SELECT quantity, remaining FROM prize_pool WHERE prize_name = ? AND box_level = ?", 
                      (name, box_level))
        result = cursor.fetchone()
        
        if result:
            total_qty, remaining_qty = result
            
            embed = discord.Embed(
                title=f"âœ… çå“{action}æˆåŠŸ",
                color=0x2ECC71 if quantity > 0 else 0xE74C3C
            )
            
            embed.add_field(name="çå“åç¨±", value=name, inline=True)
            embed.add_field(name="å¯¶ç®±ç­‰ç´š", value=box_level, inline=True)
            embed.add_field(name=f"{action}æ•¸é‡", value=f"{abs(quantity)} å€‹", inline=True)
            embed.add_field(name="ç¸½æ•¸é‡", value=f"{total_qty} å€‹", inline=True)
            embed.add_field(name="å‰©é¤˜æ•¸é‡", value=f"{remaining_qty} å€‹", inline=True)
            embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
            
            await interaction.followup.send(embed=embed)
        else:
            await interaction.followup.send(f"âŒ æ“ä½œå¤±æ•—")
        
        conn.commit()
        conn.close()
        
    except sqlite3.OperationalError as e:
        if "no such column" in str(e) or "no such table" in str(e):
            error_embed = discord.Embed(
                title="âŒ è³‡æ–™åº«çµæ§‹éŒ¯èª¤",
                description="è«‹åˆªé™¤ bot_data.db æª”æ¡ˆå¾Œé‡æ–°å•Ÿå‹•æ©Ÿå™¨äºº",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
        else:
            error_embed = discord.Embed(
                title="âŒ æ“ä½œå¤±æ•—",
                description=f"è³‡æ–™åº«éŒ¯èª¤ï¼š{str(e)}",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed)
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ æ“ä½œå¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 10: add_score (ç®¡ç†å“¡)
@tree.command(name="add_score", description="èª¿æ•´ç”¨æˆ¶ç©åˆ†")
@app_commands.describe(
    user="ç›®æ¨™ç”¨æˆ¶",
    amount="ç©åˆ†è®ŠåŒ–ï¼ˆæ­£æ•¸ç‚ºå¢åŠ ï¼Œè² æ•¸ç‚ºæ¸›å°‘ï¼‰",
    reason="åŸå› "
)
async def add_score_slash(
    interaction: discord.Interaction,
    user: discord.Member,
    amount: int,
    reason: str
):
    """èª¿æ•´ç©åˆ†"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        if amount == 0:
            await interaction.followup.send("âŒ ç©åˆ†è®ŠåŒ–ä¸èƒ½ç‚º 0")
            return
        
        old_score, old_total = get_user_score(user.id)
        update_user_score(user.id, user.name, amount, f"ç®¡ç†å“¡èª¿æ•´: {reason}")
        new_score, new_total = get_user_score(user.id)
        
        action = "å¢åŠ " if amount > 0 else "æ¸›å°‘"
        embed = discord.Embed(
            title=f"âœ… ç©åˆ†{action}æˆåŠŸ",
            color=0x2ECC71 if amount > 0 else 0xE74C3C
        )
        
        embed.add_field(name="ç”¨æˆ¶", value=user.mention, inline=True)
        embed.add_field(name=f"{action}ç©åˆ†", value=f"{abs(amount)} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå‰ç©åˆ†", value=f"{old_score} åˆ†", inline=True)
        embed.add_field(name="æ“ä½œå¾Œç©åˆ†", value=f"{new_score} åˆ†", inline=True)
        embed.add_field(name="ç¸½ç²å¾—ç©åˆ†", value=f"{new_total} åˆ†", inline=True)
        embed.add_field(name="åŸå› ", value=reason, inline=True)
        embed.add_field(name="æ“ä½œè€…", value=interaction.user.mention, inline=True)
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ èª¿æ•´å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 11: create_event (ç®¡ç†å“¡)
@tree.command(name="create_event", description="å‰µå»ºè©•æ ¸æ´»å‹•")
@app_commands.describe(
    event_name="æ´»å‹•åç¨±",
    signup_time="ç°½åˆ°æ™‚é–“ï¼ˆåˆ†é˜ï¼‰",
    prize="æ´»å‹•çå“"
)
async def create_event_slash(
    interaction: discord.Interaction,
    event_name: str,
    signup_time: int = 5,
    prize: Optional[str] = None
):
    """å‰µå»ºè©•æ ¸æ´»å‹•"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            await interaction.followup.send("âŒ éœ€è¦ç®¡ç†å“¡æ¬Šé™")
            return
        
        signup_embed = discord.Embed(
            title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
            color=discord.Color.blue()
        )
        
        if prize:
            signup_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
        
        signup_embed.add_field(
            name="ğŸ“ ç°½åˆ°éšæ®µ",
            value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°",
            inline=False
        )
        
        signup_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value="0 äºº", inline=True)
        signup_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
        signup_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
        
        signup_message = await interaction.followup.send(embed=signup_embed, wait=True)
        await signup_message.add_reaction("âœ…")
        
        class_embed = discord.Embed(
            title=f"ğŸ® è·æ¥­é¸æ“‡ï¼š{event_name}",
            description="è«‹é¸æ“‡ä½ çš„è·æ¥­ï¼š\n\nğŸ›¡ï¸ å¦å…‹\nâš”ï¸ è¾“å‡º\nğŸ’š æ²»ç–—\nğŸ’› è¾…åŠ©\n\n**æ³¨æ„ï¼šè«‹å…ˆå®Œæˆç°½åˆ°å†é¸æ“‡è·æ¥­ï¼**",
            color=discord.Color.green()
        )
        class_embed.set_footer(text="ç°½åˆ°æˆåŠŸå¾Œè«‹é¸æ“‡è·æ¥­")
        
        class_msg = await interaction.channel.send(embed=class_embed)
        for emoji in ["ğŸ›¡ï¸", "âš”ï¸", "ğŸ’š", "ğŸ’›"]:
            await class_msg.add_reaction(emoji)
        
        signup_end_time = datetime.now() + timedelta(minutes=signup_time)
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO evaluation_events (event_name, creator_id, signup_message_id, profession_message_id, channel_id, signup_end_time)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (event_name, interaction.user.id, signup_message.id, class_msg.id, interaction.channel.id, signup_end_time))
        conn.commit()
        conn.close()
        
        print(f"âœ… æ´»å‹•å‰µå»ºæˆåŠŸ: {event_name}")
        
        async def signup_countdown():
            remaining_minutes = signup_time
            
            while remaining_minutes > 0:
                await asyncio.sleep(60)
                remaining_minutes -= 1
                
                try:
                    conn = sqlite3.connect(DB_NAME)
                    cursor = conn.cursor()
                    cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                    result = cursor.fetchone()
                    
                    participants_count = 0
                    if result and result[0]:
                        participants = json.loads(result[0])
                        participants_count = len(participants)
                    conn.close()
                    
                    updated_embed = discord.Embed(
                        title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                        color=discord.Color.blue()
                    )
                    
                    if prize:
                        updated_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                    
                    updated_embed.add_field(
                        name="ğŸ“ ç°½åˆ°éšæ®µ",
                        value=f"è«‹åœ¨æ´»å‹•é–‹å§‹å¾Œ {signup_time} åˆ†é˜å…§æŒ‰ âœ… ç°½åˆ°",
                        inline=False
                    )
                    
                    updated_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value=f"{signup_time} åˆ†é˜", inline=True)
                    updated_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{participants_count} äºº", inline=True)
                    updated_embed.add_field(name="â±ï¸ å‰©é¤˜æ™‚é–“", value=f"{remaining_minutes} åˆ†é˜", inline=True)
                    updated_embed.set_footer(text=f"åŠæœˆæœŸ: {get_current_half_month()}")
                    
                    await signup_message.edit(embed=updated_embed)
                    
                except Exception as e:
                    print(f"æ›´æ–°ç°½åˆ°è¨Šæ¯éŒ¯èª¤: {e}")
            
            try:
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("SELECT participants FROM evaluation_events WHERE signup_message_id = ?", (signup_message.id,))
                result = cursor.fetchone()
                
                participants = []
                if result and result[0]:
                    participants = json.loads(result[0])
                
                for user_id in participants:
                    update_user_score(user_id, f"ç”¨æˆ¶{user_id}", SIGNUP_SCORE, f"æ´»å‹•ç°½åˆ°: {event_name}")
                    update_user_activity(user_id, event_name, attended=True)
                    update_user_rating(user_id, "æ™®é€š")
                
                cursor.execute("UPDATE evaluation_events SET default_rated = ?, is_active = 1 WHERE signup_message_id = ?", 
                             (json.dumps(participants), signup_message.id))
                conn.commit()
                conn.close()
                
                end_embed = discord.Embed(
                    title=f"ğŸ“‹ è©•æ ¸æ´»å‹•ï¼š{event_name}",
                    description="**ç°½åˆ°å·²çµæŸï¼æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ0ç©åˆ†ï¼‰**",
                    color=discord.Color.red()
                )
                
                if prize:
                    end_embed.add_field(name="ğŸ çå“", value=prize, inline=False)
                
                end_embed.add_field(name="â° ç°½åˆ°æ™‚é–“", value="å·²çµæŸ", inline=True)
                end_embed.add_field(name="ğŸ‘¥ å·²ç°½åˆ°", value=f"{len(participants)} äºº", inline=True)
                
                if participants:
                    participants_text = "\n".join([f"<@{user_id}>" for user_id in participants[:10]])
                    if len(participants) > 10:
                        participants_text += f"\n... é‚„æœ‰ {len(participants) - 10} äºº"
                    
                    end_embed.add_field(name="ğŸ“‹ åƒèˆ‡è€…åˆ—è¡¨", value=participants_text, inline=False)
                
                end_embed.add_field(name="ğŸ“ è©•æ ¸èªªæ˜", value="ä¸»æŒäººç¾åœ¨å¯ä»¥æŒ‰EMOJIèª¿æ•´è©•ç´šï¼š\nâ­ å„ªç§€ (+40åˆ†)\nğŸ‘ è‰¯å¥½ (+10åˆ†)\nğŸ‘Œ æ™®é€š (0åˆ†ï¼Œé è¨­)\nâŒ ä¸åˆæ ¼ (-5åˆ†)", inline=False)
                end_embed.set_footer(text="åŠæœˆæœŸæ´»å‹•çµ±è¨ˆå·²æ›´æ–° | ç°½åˆ°ç©åˆ†å·²ç™¼æ”¾ | é è¨­è©•ç´šï¼šæ™®é€š")
                
                await signup_message.edit(embed=end_embed)
                await signup_message.clear_reactions()
                
                rating_embed = discord.Embed(
                    title=f"â­ è©•æ ¸éšæ®µï¼š{event_name}",
                    description="**ä¸»æŒäººå¯ä»¥æŒ‰ä¸‹æ–¹EMOJIèª¿æ•´è©•ç´š**\n\n"
                              f"æ‰€æœ‰åƒèˆ‡è€…å·²ç²å¾—é è¨­ã€Œæ™®é€šã€è©•ç´šï¼ˆ{RATING_SCORES['æ™®é€š']}ç©åˆ†ï¼‰\n",
                    color=discord.Color.gold()
                )
                
                if participants:
                    rating_embed.add_field(
                        name="ğŸ‘¥ åƒèˆ‡è€…åˆ—è¡¨",
                        value="\n".join([f"<@{user_id}>" for user_id in participants[:15]]) + 
                             (f"\n... é‚„æœ‰ {len(participants)-15} äºº" if len(participants) > 15 else ""),
                        inline=False
                    )
                
                rating_msg = await interaction.channel.send(embed=rating_embed)
                
                for emoji in ["â­", "ğŸ‘", "ğŸ‘Œ", "âŒ", RATING_END_EMOJI]:
                    await rating_msg.add_reaction(emoji)
                
                conn = sqlite3.connect(DB_NAME)
                cursor = conn.cursor()
                cursor.execute("UPDATE evaluation_events SET rating_message_id = ? WHERE signup_message_id = ?", 
                             (rating_msg.id, signup_message.id))
                conn.commit()
                conn.close()
                
                print(f"âœ… è©•æ ¸éšæ®µå·²å‰µå»º: {event_name}, è©•æ ¸è¨Šæ¯ID: {rating_msg.id}")
                
            except Exception as e:
                print(f"ç°½åˆ°çµæŸè™•ç†éŒ¯èª¤: {e}")
        
        asyncio.create_task(signup_countdown())
        
        success_embed = discord.Embed(
            title="âœ… æ´»å‹•å‰µå»ºæˆåŠŸ",
            description=f"**æ´»å‹•åç¨±ï¼š** {event_name}\n**ç°½åˆ°æ™‚é–“ï¼š** {signup_time} åˆ†é˜\n**åƒèˆ‡æ–¹å¼ï¼š** æŒ‰ âœ… åæ‡‰ç°½åˆ°",
            color=discord.Color.green()
        )
        
        await interaction.followup.send(embed=success_embed, ephemeral=True)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ å‰µå»ºæ´»å‹•å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 12: all_profiles (ç®¡ç†å“¡)
@tree.command(name="all_profiles", description="æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™")
@app_commands.describe(
    sort_by="æ’åºæ–¹å¼",
    limit="é¡¯ç¤ºæ•¸é‡"
)
@app_commands.choices(sort_by=[
    app_commands.Choice(name="ç¾æœ‰ç©åˆ†(é«˜åˆ°ä½)", value="current_score"),
    app_commands.Choice(name="ç¸½ç²å¾—ç©åˆ†(é«˜åˆ°ä½)", value="total_score"),
    app_commands.Choice(name="åŠ å…¥æ—¥æœŸ(æ—©åˆ°æ™š)", value="join_date"),
    app_commands.Choice(name="æœ€å¾Œæ´»èº(è¿‘åˆ°é )", value="last_active"),
])
async def all_profiles_slash(
    interaction: discord.Interaction,
    sort_by: Optional[str] = "current_score",
    limit: Optional[int] = 20
):
    """æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        if limit > 50:
            limit = 50
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT user_id, username, current_score, total_score, join_date, 
                   last_active, activity_stats
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        processed_users = []
        current_period = get_current_half_month()
        
        for row in results:
            user_id, username, current_score, total_score, join_date, last_active, activity_str = row
            
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            current_period_data = activity_stats.get(current_period, {})
            total_events = current_period_data.get("total", 0)
            attended_events = current_period_data.get("attended", 0)
            current_attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
            
            processed_users.append({
                "user_id": user_id,
                "username": username,
                "current_score": current_score,
                "total_score": total_score,
                "join_date": join_date,
                "last_active": last_active,
                "current_attendance_rate": current_attendance_rate,
                "total_events": total_events,
                "attended_events": attended_events,
            })
        
        sort_functions = {
            "current_score": lambda x: x["current_score"],
            "total_score": lambda x: x["total_score"],
            "join_date": lambda x: x["join_date"],
            "last_active": lambda x: x["last_active"],
        }
        
        reverse_order = {
            "current_score": True,
            "total_score": True,
            "join_date": False,
            "last_active": True,
        }
        
        sort_func = sort_functions.get(sort_by, lambda x: x["current_score"])
        reverse = reverse_order.get(sort_by, True)
        
        sorted_users = sorted(processed_users, key=sort_func, reverse=reverse)
        display_users = sorted_users[:limit]
        
        total_users = len(display_users)
        total_current_score = sum(u["current_score"] for u in display_users)
        total_total_score = sum(u["total_score"] for u in display_users)
        avg_current_score = total_current_score / total_users if total_users > 0 else 0
        
        profiles_per_page = 10
        pages = []
        
        for i in range(0, len(display_users), profiles_per_page):
            embed = discord.Embed(
                title="ğŸ“Š æ‰€æœ‰ç”¨æˆ¶è³‡æ–™ç¸½è¦½",
                description=f"é¡¯ç¤º {min(i + profiles_per_page, len(display_users))}/{len(display_users)} ä½ç”¨æˆ¶",
                color=0x43B581
            )
            
            embed.add_field(
                name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                      f"**ç¸½ç¾æœ‰ç©åˆ†ï¼š** {total_current_score} åˆ†\n"
                      f"**ç¸½æ­·å²ç©åˆ†ï¼š** {total_total_score} åˆ†\n"
                      f"**å¹³å‡ç¾æœ‰ç©åˆ†ï¼š** {avg_current_score:.1f} åˆ†",
                inline=False
            )
            
            user_list = ""
            for user in display_users[i:i + profiles_per_page]:
                user_id = user["user_id"]
                username = user["username"]
                
                discord_user = interaction.guild.get_member(user_id)
                display_name = discord_user.display_name if discord_user else username
                
                user_list += f"**{display_name}**\n"
                user_list += f"  ğŸ”¹ ç¾æœ‰ç©åˆ†ï¼š{user['current_score']}åˆ†\n"
                user_list += f"  ğŸ“Š ç¸½ç©åˆ†ï¼š{user['total_score']}åˆ†\n"
                user_list += f"  ğŸ“Š å‡ºå¸­ç‡ï¼š{user['current_attendance_rate']:.1f}%\n"
                user_list += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ‘¥ ç”¨æˆ¶åˆ—è¡¨",
                value=user_list if user_list else "ç„¡ç”¨æˆ¶è³‡æ–™",
                inline=False
            )
            
            embed.set_footer(text=f"é é¢ {i//profiles_per_page + 1}/{(len(display_users)-1)//profiles_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            current_page = 0
            
            class ProfilesPaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = ProfilesPaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–ç”¨æˆ¶è³‡æ–™å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 13: attendance_stats (ç®¡ç†å“¡)
@tree.command(name="attendance_stats", description="æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ")
@app_commands.describe(
    period="çµ±è¨ˆæœŸé–“",
    min_events="æœ€ä½æ´»å‹•æ¬¡æ•¸"
)
@app_commands.choices(period=[
    app_commands.Choice(name="ç•¶å‰åŠæœˆæœŸ", value="current"),
    app_commands.Choice(name="æ‰€æœ‰æœŸé–“", value="all"),
])
async def attendance_stats_slash(
    interaction: discord.Interaction,
    period: Optional[str] = "current",
    min_events: Optional[int] = 3
):
    """æŸ¥çœ‹ç”¨æˆ¶å‡ºå¸­ç‡çµ±è¨ˆ"""
    await interaction.response.defer()
    
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="âŒ æ¬Šé™ä¸è¶³",
                description="åªæœ‰ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹å‡ºå¸­ç‡çµ±è¨ˆ",
                color=0xFF0000
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT user_id, username, activity_stats
            FROM users
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description="è³‡æ–™åº«ä¸­æ²’æœ‰ç”¨æˆ¶è³‡æ–™",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        current_period = get_current_half_month()
        attendance_data = []
        
        for user_id, username, activity_str in results:
            activity_stats = json.loads(activity_str) if activity_str else {}
            
            if period == "current":
                period_data = activity_stats.get(current_period, {})
                total_events = period_data.get("total", 0)
                attended_events = period_data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": current_period
                    })
            
            else:  # "all"
                total_events = 0
                attended_events = 0
                
                for data in activity_stats.values():
                    total_events += data.get("total", 0)
                    attended_events += data.get("attended", 0)
                
                if total_events >= min_events:
                    attendance_rate = (attended_events / total_events * 100) if total_events > 0 else 0.0
                    attendance_data.append({
                        "user_id": user_id,
                        "username": username,
                        "attendance_rate": attendance_rate,
                        "total_events": total_events,
                        "attended_events": attended_events,
                        "period": "æ‰€æœ‰æœŸé–“"
                    })
        
        attendance_data.sort(key=lambda x: x["attendance_rate"], reverse=True)
        
        total_users = len(attendance_data)
        if total_users == 0:
            embed = discord.Embed(
                title="ğŸ“Š å‡ºå¸­ç‡çµ±è¨ˆ",
                description=f"æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ç”¨æˆ¶ï¼ˆæœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ï¼‰",
                color=0xFFFF00
            )
            await interaction.followup.send(embed=embed)
            return
        
        avg_attendance_rate = sum(d["attendance_rate"] for d in attendance_data) / total_users
        perfect_attendance = sum(1 for d in attendance_data if d["attendance_rate"] == 100)
        
        users_per_page = 15
        pages = []
        
        for i in range(0, len(attendance_data), users_per_page):
            embed = discord.Embed(
                title=f"ğŸ“Š å‡ºå¸­ç‡æ’è¡Œæ¦œ - {attendance_data[0]['period']}",
                description=f"é¡¯ç¤º {min(i + users_per_page, len(attendance_data))}/{len(attendance_data)} ä½ç”¨æˆ¶",
                color=0x3498DB
            )
            
            embed.add_field(
                name="ğŸ“ˆ çµ±è¨ˆæ‘˜è¦",
                value=f"**ç¸½ç”¨æˆ¶æ•¸ï¼š** {total_users} äºº\n"
                      f"**å¹³å‡å‡ºå¸­ç‡ï¼š** {avg_attendance_rate:.1f}%\n"
                      f"**å…¨å‹¤ç”¨æˆ¶ï¼š** {perfect_attendance} äºº (100%)",
                inline=False
            )
            
            leaderboard = ""
            for j, data in enumerate(attendance_data[i:i + users_per_page], i + 1):
                medal = "ğŸ¥‡ " if j == 1 else "ğŸ¥ˆ " if j == 2 else "ğŸ¥‰ " if j == 3 else f"{j}. "
                
                discord_user = interaction.guild.get_member(data["user_id"])
                display_name = discord_user.display_name if discord_user else data["username"]
                
                leaderboard += f"{medal}**{display_name}**\n"
                leaderboard += f"   å‡ºå¸­ç‡ï¼š{data['attendance_rate']:.1f}% "
                leaderboard += f"({data['attended_events']}/{data['total_events']}æ¬¡)\n"
                
                if j % 5 == 0:
                    leaderboard += "  â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n"
            
            embed.add_field(
                name="ğŸ† å‡ºå¸­ç‡æ’è¡Œæ¦œ",
                value=leaderboard,
                inline=False
            )
            
            embed.set_footer(text=f"æœ€ä½æ´»å‹•æ¬¡æ•¸ï¼š{min_events}æ¬¡ | é é¢ {i//users_per_page + 1}/{(len(attendance_data)-1)//users_per_page + 1}")
            pages.append(embed)
        
        if len(pages) == 1:
            await interaction.followup.send(embed=pages[0])
        else:
            class AttendancePaginator(discord.ui.View):
                def __init__(self, pages, timeout=180):
                    super().__init__(timeout=timeout)
                    self.pages = pages
                    self.current_page = 0
                    self.update_buttons()
                
                def update_buttons(self):
                    self.children[0].disabled = self.current_page == 0
                    self.children[1].disabled = self.current_page == len(self.pages) - 1
                
                @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¬…ï¸")
                async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page > 0:
                        self.current_page -= 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
                
                @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.secondary, emoji="â¡ï¸")
                async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if self.current_page < len(self.pages) - 1:
                        self.current_page += 1
                        self.update_buttons()
                        await interaction.response.edit_message(embed=self.pages[self.current_page], view=self)
            
            view = AttendancePaginator(pages)
            await interaction.followup.send(embed=pages[0], view=view)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="âŒ è®€å–å‡ºå¸­ç‡å¤±æ•—",
            description=f"éŒ¯èª¤ï¼š{str(e)}",
            color=0xFF0000
        )
        await interaction.followup.send(embed=error_embed)

# æŒ‡ä»¤ 14: ping
@tree.command(name="ping", description="æ¸¬è©¦æ©Ÿå™¨äººå»¶é²")
async def ping_slash(interaction: discord.Interaction):
    """æ¸¬è©¦å»¶é²"""
    latency = round(bot.latency * 1000)
    
    embed = discord.Embed(
        title="ğŸ“ Pong!",
        description=f"æ©Ÿå™¨äººå»¶é²: **{latency}ms**",
        color=discord.Color.green() if latency < 100 else discord.Color.orange() if latency < 300 else discord.Color.red()
    )
    
    await interaction.response.send_message(embed=embed)

# ========== ä¸»ç¨‹å¼ ==========

def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    print(f"{'='*50}")
    print(f"ğŸš€ å•Ÿå‹• {BOT_NAME} - å®Œæ•´åŠŸèƒ½ç‰ˆæœ¬ (ä¿®æ­£ç‰ˆ)")
    print(f"ğŸ’¡ ä¸»è¦æŒ‡ä»¤: ä½¿ç”¨ / å‰ç¶´")
    print(f"ğŸ”§ æ“æœ‰è€…ID: {OWNER_IDS}")
    print(f"ğŸ“ è³‡æ–™åº«ä½ç½®: {DB_NAME}")
    print(f"ğŸ“‹ ç¸½æŒ‡ä»¤æ•¸: 14å€‹ (å«/ping)")
    print(f"{'='*50}")
    
    # å¾ç’°å¢ƒè®Šæ•¸è®€å– Token
    token = os.getenv("DISCORD_TOKEN")
    
    if not token or token == "ä½ çš„_bot_token_åœ¨é€™è£¡":
        print("âŒ æ‰¾ä¸åˆ°æœ‰æ•ˆçš„ Tokenï¼")
        print("ğŸ’¡ è«‹åœ¨ Railway è¨­å®šç’°å¢ƒè®Šæ•¸ï¼š")
        print("   1. é€²å…¥ Railway å°ˆæ¡ˆ")
        print("   2. é»æ“Š Settings")
        print("   3. é»æ“Š Variables")
        print("   4. æ–°å¢ DISCORD_TOKEN = ä½ çš„_bot_token")
        sys.exit(1)
    
    print("âœ… Token è®€å–æˆåŠŸ")
    print("ğŸ”„ æ­£åœ¨é€£æ¥ Discord...")
    
    try:
        bot.run(token)
    except discord.LoginFailure:
        print("âŒ ç™»å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ Token æ˜¯å¦æ­£ç¢º")
        print("ğŸ’¡ è«‹åˆ° Discord Developer Portal é‡ç½® Token")
    except Exception as e:
        print(f"âŒ å•Ÿå‹•å¤±æ•—: {e}")

if __name__ == "__main__":
    main()
